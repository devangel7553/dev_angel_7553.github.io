import requests
import base64
import os
import threading
import time
import uuid
import re
import hashlib
from urllib.parse import quote
from datetime import datetime
from io import BytesIO
from java.util import Locale, ArrayList
from java.io import File
from java.lang import Class as JClass, Float as JFloat
from PIL import Image, ImageFilter, ImageDraw, ImageFont, ImageOps
from android.content import Intent, ClipData, Context
from android.net import Uri
from android.os import Build
from android.provider import Settings
from org.telegram.messenger import ApplicationLoader
from org.telegram.ui.ActionBar import AlertDialog
from ui.settings import Header, Divider, Input, Switch, Text, Selector
from ui.alert import AlertDialogBuilder
from ui.bulletin import BulletinHelper
from client_utils import get_send_messages_helper, run_on_queue, get_last_fragment, get_user_config, get_messages_controller, send_request
from android_utils import run_on_ui_thread, log
from markdown_utils import parse_markdown
from base_plugin import BasePlugin, HookResult, HookStrategy, MenuItemData, MenuItemType
from org.telegram.tgnet.tl import TL_account
from org.telegram.messenger import R
from com.exteragram.messenger.plugins import PluginsController
from com.exteragram.messenger.plugins.ui import PluginSettingsActivity
import json
import math
import random
from hook_utils import find_class
from java import dynamic_proxy
from android.view import WindowManager, Gravity, View, MotionEvent
from android.widget import TextView, LinearLayout, FrameLayout
from android.graphics import Color, PixelFormat, BitmapFactory, Canvas, Matrix, Paint
from org.telegram.messenger import AndroidUtilities

__id__ = "nowfy"
__name__ = "Nowfy"
__description__ = "Shows and controls the current playing track with a styled preview.\n\nSupported services:\n• Spotify (API)\n• Last.fm (scrobble)\n• Stats.fm (Spotify tracking)\n\nHow to use:\n• Use .now to show the current playing track (Spotify)\n• Use .fm to show the current scrobbling track (Last.fm)\n• Use .stats to show the current playing track (Stats.fm)\n• Use .etg to show the current playing track from exteraGram\n• Use .ayu to show the current playing track from AyuGram\n• Use .help to see all available commands\n• Use .guide for instructions"
__author__ = "@AGeekApple, @exteraDevPlugins"
__version__ = "1.1.0"
__min_version__ = "11.12.1"
__icon__ = "ApplePlugins/16"
__priority__ = 0


# Nowfy: Modo silencioso de logs (utilidades)
# Permite desativar logs deste plugin sem afetar outros módulos.
try:
    _ORIGINAL_LOG = log  # guarda referência ao log original
except Exception:
    _ORIGINAL_LOG = None

_NOWFY_LOGS_MUTED = True  # estado de silêncio por padrão; __init__ ajusta conforme settings

def _set_log_muted(muted: bool):
    """Ativa/desativa o modo silencioso de logs do Nowfy."""
    global _NOWFY_LOGS_MUTED
    _NOWFY_LOGS_MUTED = bool(muted)

def _log_wrapper(*args, **kwargs):
    """Encapsula o log original respeitando o estado silencioso.
    Usa *args/**kwargs para compatibilidade, evitando quebra da UI.
    """
    try:
        if _NOWFY_LOGS_MUTED:
            return  # silencia completamente
        if _ORIGINAL_LOG:
            _ORIGINAL_LOG(*args, **kwargs)
    except Exception:
        # Evita que erros no log interrompam abertura dos Settings
        pass

def _apply_log_wrapper(enabled: bool):
    """Alterna entre o log original e o wrapper silencioso.
    Importante: rebinda apenas o símbolo local `log` deste arquivo.
    """
    global log
    # Sempre aplicar o wrapper; o estado 'muted' controla a saída
    if _ORIGINAL_LOG:
        log = _log_wrapper
    else:
        log = _ORIGINAL_LOG

# Aplicar wrapper imediatamente para garantir que todos os logs passem por ele
_apply_log_wrapper(True)

# Mapeamento de backgrounds para o tema Apple unificado
APPLE_BACKGROUNDS = {
    "Spotify": {
        "Light": "https://i.postimg.cc/7L9Hf5Pd/applelight.png",
        "Dark":  "https://i.postimg.cc/d10qdJL1/appledark.png",
        "Red":   "https://i.postimg.cc/269phvZb/applered.png",
    },
    "YouTube": {
        "Light": "https://i.postimg.cc/rFPT53z2/appleredyoutubelight.png",
        "Dark":  "https://i.postimg.cc/0yKsnnJM/appleredyoutubedark.png",
        "Red":   "https://i.postimg.cc/bvXjBnQ6/appleredyoutubered.png",
    },
    "YouTube Music": {
        "Light": "https://i.postimg.cc/Wz7HXFsH/applelightytmusic.png",
        "Dark":  "https://i.postimg.cc/C502GHp8/appledarkytmusic.png",
        "Red":   "https://i.postimg.cc/44vqJMpQ/appleredytmusic.png",
    },
    "exteraGram": {
        "Light": "https://i.postimg.cc/qvtSs7Cp/etglight.png",
        "Dark":  "https://i.postimg.cc/cJwzz5mj/etgdark.png",
        "Red":   "https://i.postimg.cc/6pDSYNdn/etgred.png",
    },
    "AyuGram": {
        "Light": "https://i.postimg.cc/2yR4VrBj/ayulight.png",
        "Dark":  "https://i.postimg.cc/ryx170vD/ayudark.png",
        "Red":   "https://i.postimg.cc/8cRLv9hR/ayured.png",
    },
    "SoundCloud": {
        "Light": "https://i.postimg.cc/5N8J5ZST/applelightsoundcloud.png", # Manutenção
        "Dark":  "https://i.postimg.cc/qv0T1jmR/appledarksoundcloud.png",
        "Red":   "https://i.postimg.cc/6p0NgnSh/appleredsoundcloud.png",
    },
    "Apple Music": {
        "Light": "https://i.postimg.cc/HxxBVMzT/applelightapplelight.png",
        "Dark":  "https://i.postimg.cc/hvQs0qNw/appledarkapple.png",
        "Red":   "https://i.postimg.cc/hvQs0qNw/appledarkapple.png",
    },
    "Yandex Music": {
        "Light": "https://raw.githubusercontent.com/soumaki/nowFy/refs/heads/main/plataform/yandexlight.png",  # Usando background padrão por enquanto
        "Dark":  "https://raw.githubusercontent.com/soumaki/nowFy/refs/heads/main/plataform/yandexdark.png",   # Usando background padrão por enquanto
        "Red":   "https://raw.githubusercontent.com/soumaki/nowFy/refs/heads/main/plataform/yandexred.png",    # Usando background padrão por enquanto
    },
    "Yandex Music": {
        "Light": "https://i.postimg.cc/7L9Hf5Pd/applelight.png",
        "Dark":  "https://i.postimg.cc/d10qdJL1/appledark.png",
        "Red":   "https://i.postimg.cc/269phvZb/applered.png",
    },
}

# Mensagens do NowCast
NOWCAST_MESSAGES = {
    "music_detected": "Música detectada! Card será enviado nos próximos 2 minutos...",
    "card_sent": "Card enviado!",
    "card_updated": "Card atualizado!",
    "music_stopped": "Música parou. NowCast pausado.",
    "worker_started": "Worker iniciado",
    "worker_stopping": "Worker será parado na próxima verificação",
    "error_worker": "Erro no worker: {}",
    "error_check_music": "Erro ao verificar música: {}",
    "error_send_test": "Erro ao enviar mensagem de teste: {}",
    "nowcast_enabled": "NowCast ativado! Sistema monitorando música...",
    "nowcast_disabled": "NowCast desativado.",
    "nowcast_ready": "NowCast configurado e pronto para uso!",
    "nowcast_error": "Erro: Configure as credenciais e canal primeiro."
}

# Variantes de estilo (cores + exteraBar) por skin
APPLE_SKIN_STYLE = {
    0: {  # Light
        "playing_color": "#888888",
        "title_color": "#000000",
        "artist_color": "#888888",
        "exteraBar_fn": "exteraBarSeek_light_opposite",
    },
    1: {  # Dark
        "playing_color": "#DDDDDD",
        "title_color": "#FFFFFF",
        "artist_color": "#CCCCCC",
        "exteraBar_fn": "exteraBarSeek_dark_opposite",
    },
    2: {  # Red
        "playing_color": "#DDDDDD",
        "title_color": "#FFFFFF",
        "artist_color": "#CCCCCC",
        "exteraBar_fn": "exteraBarSeek_red_opposite",
    },
}

# Variantes de estilo para o tema Spotlight
SPOTLIGHT_SKIN_STYLE = {
    0: {  # Light
        "time_color": (0, 0, 0, 255),  # Preto
        "bar_bg_color": (200, 200, 200, 255),  # Cinza claro
        "bar_fill_color": (0, 0, 0, 255),  # Preto
        "bg_color": (255, 255, 255),  # Fundo branco
        "use_blur_bg": False,
    },
    1: {  # Dark
        "time_color": (255, 255, 255, 255),  # Branco
        "bar_bg_color": (60, 60, 60, 255),  # Cinza escuro
        "bar_fill_color": (255, 255, 255, 255),  # Branco
        "bg_color": (0, 0, 0),  # Fundo preto
        "use_blur_bg": False,
    },
    2: {  # Blur
        "time_color": (255, 255, 255, 255),  # Branco (cores invertidas do Dark)
        "bar_bg_color": (60, 60, 60, 255),  # Cinza escuro
        "bar_fill_color": (255, 255, 255, 255),  # Branco
        "bg_color": (255, 255, 255),  # Fundo será substituído pelo blur
        "use_blur_bg": True,
    },
}

# Traduções básicas (pode ser expandido)
TRANSLATIONS = {
    "client_id": {"pt": "Client ID", "en": "Client ID", "es": "Client ID", "fr": "Client ID", "ru": "Client ID"},
    "client_secret": {"pt": "Client Secret", "en": "Client Secret", "es": "Client Secret", "fr": "Client Secret", "ru": "Client Secret"},
    "refresh_token": {"pt": "Refresh Token", "en": "Refresh Token", "es": "Refresh Token", "fr": "Refresh Token", "ru": "Refresh Token"},
    "custom_command": {"pt": "Comando Personalizado", "en": "Custom Command", "es": "Comando Personalizado", "fr": "Commande personnalisée", "ru": "Пользовательская команда"},
    "custom_command_sub": {"pt": "Comando para mostrar o card (ex: .now)", "en": "Command to show card (e.g. .now)", "es": "Comando para mostrar la tarjeta (ej: .now)", "fr": "Commande pour afficher la carte (ex: .now)", "ru": "Команда для показа карточки (например, .now)"},
    "autobio": {"pt": "Atualizar bio automaticamente", "en": "Auto-update bio", "es": "Actualizar bio automáticamente", "fr": "Mise à jour automatique de la bio", "ru": "Автообновление био"},
    "autobio_sub": {"pt": "Atualiza a bio automaticamente com a música atual", "en": "Automatically updates bio with current track", "es": "Actualiza la bio automáticamente con la canción actual", "fr": "Met à jour automatiquement la bio avec la chanson en cours", "ru": "Автоматически обновляет био с текущей песней"},
    "autobio_text": {"pt": "Texto da bio", "en": "Bio text", "es": "Texto de la bio", "fr": "Texte de la bio", "ru": "Текст био"},
    "autobio_text_sub": {"pt": "Texto para atualizar a bio com a música atual", "en": "Text to update bio with current track", "es": "Texto para actualizar la bio con la canción atual", "fr": "Texte pour mettre à jour la bio avec la chanson en cours", "ru": "Текст для обновления био с текущей песней"},
    "playing": {"pt": "Tocando", "en": "Playing", "es": "Reproduciendo", "fr": "Lecture", "ru": "Сейчас играет"},
    "show_caption": {"pt": "Mostrar legenda", "en": "Show Caption", "es": "Mostrar leyenda", "fr": "Afficher la légende", "ru": "Показать подпись"},
    "show_caption_sub": {"pt": "Mostra a legenda com o card", "en": "Shows caption with the card", "es": "Muestra la leyenda con la tarjeta", "fr": "Affiche la légende avec la carte", "ru": "Показывать подпись с карточкой"},
    "caption_style": {"pt": "Estilo da legenda", "en": "Caption Style", "es": "Estilo de leyenda", "fr": "Style de légende", "ru": "Стиль подписи"},
    "caption_style_sub": {"pt": "Escolha o estilo da legenda do card", "en": "Choose the card caption style", "es": "Elige el estilo de leyenda de la tarjeta", "fr": "Choisissez le style de légende de la carte", "ru": "Выберите стиль подписи карточки"},
    "enable_cache": {"pt": "Ativar cache de imagem", "en": "Enable image cache", "es": "Activar caché de imagen", "fr": "Activer le cache d'image", "ru": "Включить кэш изображений"},
    "enable_cache_sub": {"pt": "Cache de imagens para melhor performance", "en": "Image cache for better performance", "es": "Caché de imágenes para mejor rendimiento", "fr": "Cache d'images pour de meilleures performances", "ru": "Кэш изображений для лучшей производительности"},
    "enable_compression": {"pt": "Ativar compressão de imagem", "en": "Enable image compression", "es": "Activar compresión de imagen", "fr": "Activer la compression d'image", "ru": "Включить сжатие изображений"},
    "enable_compression_sub": {"pt": "Comprimir imagens para economizar espaço", "en": "Compress images to save space", "es": "Comprimir imágenes para ahorrar espacio", "fr": "Compresser les images pour économiser de l'espace", "ru": "Сжимать изображения для экономии места"},
    "cache_ttl": {"pt": "TTL do cache (min)", "en": "Cache TTL (min)", "es": "TTL de caché (min)", "fr": "Durée de vie du cache (min)", "ru": "Время жизни кэша (мин)"},
    "cache_ttl_sub": {"pt": "Tempo de vida do cache em minutos", "en": "Cache lifetime in minutes", "es": "Tiempo de vida del caché en minutos", "fr": "Durée de vie du cache en minutes", "ru": "Время жизни кэша в минутах"},
    "performance_mode": {"pt": "Modo de Performance", "en": "Performance Mode", "es": "Modo de Rendimiento", "fr": "Mode de Performance", "ru": "Режим производительности"},
    "performance_mode_sub": {"pt": "Balanceamento entre velocidade e qualidade", "en": "Balance between speed and quality", "es": "Balance entre velocidad y calidad", "fr": "Équilibre entre vitesse et qualité", "ru": "Баланс между скоростью и качеством"},
    "enable_preload_sub": {"pt": "Pré-carregar próximas faixas da playlist", "en": "Preload next tracks from playlist", "es": "Precargar siguientes pistas de la lista", "fr": "Précharger les pistes suivantes de la playlist", "ru": "Предзагружать следующие треки из плейлиста"},
    "enhanced_cache": {"pt": "Cache Avançado", "en": "Enhanced Cache", "es": "Caché Avanzado", "fr": "Cache Avancé", "ru": "Расширенный кэш"},
    "enhanced_cache_sub": {"pt": "Sistema de cache otimizado para melhor performance", "en": "Optimized cache system for better performance", "es": "Sistema de caché optimizado para mejor rendimiento", "fr": "Système de cache optimisé pour de meilleures performances", "ru": "Оптимизированная система кэша для лучшей производительности"},
    "turbo_mode": {"pt": "Turbo", "en": "Turbo", "es": "Turbo", "fr": "Turbo", "ru": "Турбо"},
    "balanced_mode": {"pt": "Balanceado", "en": "Balanced", "es": "Equilibrado", "fr": "Équilibré", "ru": "Сбалансированный"},
    "quality_mode": {"pt": "Qualidade", "en": "Quality", "es": "Calidad", "fr": "Qualité", "ru": "Качество"},
    "enable_preload": {"pt": "Pré-carregar próximas faixas", "en": "Preload next tracks", "es": "Precargar próximas pistas", "fr": "Précharger les pistes suivantes", "ru": "Предзагрузка следующих треков"},
    "enhanced_cache_sub": {"pt": "Ativa otimizações avançadas de cache para melhor performance", "en": "Enables advanced cache optimizations for better performance", "es": "Activa optimizaciones avanzadas de caché para mejor rendimiento", "fr": "Active les optimisations de cache avancées pour de meilleures performances", "ru": "Включает расширенные оптимизации кэша для лучшей производительности"},
    "cache_performance_section": {"pt": "Otimizações de Performance", "en": "Performance Optimizations", "es": "Optimizaciones de Rendimiento", "fr": "Optimisations de Performance", "ru": "Оптимизации производительности"},
    "cache_management_section": {"pt": "Gerenciamento de Cache", "en": "Cache Management", "es": "Gestión de Caché", "fr": "Gestion du Cache", "ru": "Управление кэшем"},
    "bio_automation_section": {"pt": "Automação da Bio", "en": "Bio Automation", "es": "Automatización de Bio", "fr": "Automatisation de Bio", "ru": "Автоматизация биографии"},
    "bio_customization_section": {"pt": "Personalização da Bio", "en": "Bio Customization", "es": "Personalización de Bio", "fr": "Personnalisation de Bio", "ru": "Настройка биографии"},
    "spotify_search_title": {"pt": "Pesquisar no Spotify", "en": "Search on Spotify", "es": "Buscar en Spotify", "fr": "Rechercher sur Spotify", "ru": "Поиск в Spotify"},
    "spotify_search_message": {"pt": "Digite o nome da música, artista ou álbum:", "en": "Enter song name, artist or album:", "es": "Ingresa el nombre de la canción, artista o álbum:", "fr": "Entrez le nom de la chanson, artiste ou album:", "ru": "Введите название песни, исполнителя или альбома:"},
    "spotify_search_hint": {"pt": "Ex: Bohemian Rhapsody Queen", "en": "Ex: Bohemian Rhapsody Queen", "es": "Ej: Bohemian Rhapsody Queen", "fr": "Ex: Bohemian Rhapsody Queen", "ru": "Пример: Bohemian Rhapsody Queen"},
    "search_button": {"pt": "Pesquisar", "en": "Search", "es": "Buscar", "fr": "Rechercher", "ru": "Поиск"},
    "cancel_button": {"pt": "Cancelar", "en": "Cancel", "es": "Cancelar", "fr": "Annuler", "ru": "Отмена"},
    "search_results_title": {"pt": "Resultados", "en": "Results", "es": "Resultados", "fr": "Résultats", "ru": "Результаты"},
    "no_results_found": {"pt": "Nenhum resultado encontrado", "en": "No results found", "es": "No se encontraron resultados", "fr": "Aucun résultat trouvé", "ru": "Результаты не найдены"},
    "search_error": {"pt": "Erro na pesquisa", "en": "Search error", "es": "Error en la búsqueda", "fr": "Erreur de recherche", "ru": "Ошибка поиска"},
    "spotify_api_not_configured": {"pt": "Spotify API não configurada. Configure nas configurações do plugin.", "en": "Spotify API not configured. Configure in plugin settings.", "es": "API de Spotify no configurada. Configura en los ajustes del plugin.", "fr": "API Spotify non configurée. Configurez dans les paramètres du plugin.", "ru": "API Spotify не настроен. Настройте в параметрах плагина."},
    "playing_track": {"pt": "Reproduzindo", "en": "Playing", "es": "Reproduciendo", "fr": "Lecture", "ru": "Воспроизведение"},
    "play_error": {"pt": "Erro ao reproduzir", "en": "Error playing", "es": "Error al reproducir", "fr": "Erreur de lecture", "ru": "Ошибка воспроизведения"},
    "results_found": {"pt": "encontrados", "en": "found", "es": "encontrados", "fr": "trouvés", "ru": "найдено"},
    "bio_help_section": {"pt": "Ajuda e Informações", "en": "Help and Information", "es": "Ayuda e Información", "fr": "Aide et Informations", "ru": "Помощь и информация"},
    "theme_selection_section": {"pt": "Seleção de Tema", "en": "Theme Selection", "es": "Selección de Tema", "fr": "Sélection de Thème", "ru": "Выбор темы"},
    "appearance_options_section": {"pt": "Efeitos de Envio", "en": "Send Effects", "es": "Efectos de Envío", "fr": "Effets d’Envoi", "ru": "Эффекты при отправке"},
    "quick_dismiss_label": {"pt": "Quick Dismiss", "en": "Quick Dismiss", "es": "Descartar Rápido", "fr": "Fermeture Rapide", "ru": "Быстрое закрытие"},
    "quick_dismiss_subtext": {
        "pt": "Fecha o diálogo imediatamente após enviar o card; ajuda a cancelar rápido se mudar de ideia.",
        "en": "Dismisses the loading dialog right after sending the card; helps cancel quickly if you change your mind.",
        "es": "Descarta el diálogo justo después de enviar la tarjeta; ayuda a cancelar rápido si cambias de opinión.",
        "fr": "Ferme le dialogue juste après l’envoi de la carte; aide à annuler rapidement en cas de changement d’avis.",
        "ru": "Закрывает диалог сразу после отправки карточки; помогает быстро отменить, если передумали."
    },
    "chat_list_divider_label": {
        "pt": "Chat List • β",
        "en": "Chat List • β",
        "es": "Chat List • β",
        "fr": "Chat List • β",
        "ru": "Chat List • β"
    },
    
    "customization_section": {"pt": "Personalização", "en": "Customization", "es": "Personalización", "fr": "Personnalisation", "ru": "Настройка"},
    "help_info_section": {"pt": "Ajuda e Informações", "en": "Help and Information", "es": "Ayuda e Información", "fr": "Aide et Informations", "ru": "Помощь и информация"},
    "credentials_section": {"pt": "Credenciais e Autenticação", "en": "Credentials & Authentication", "es": "Credenciales y Autenticación", "fr": "Identifiants et Authentification", "ru": "Учетные данные и аутентификация"},
    "multi_resolution_cache": {"pt": "Cache Multi-Resolução", "en": "Multi-Resolution Cache", "es": "Caché Multi-Resolución", "fr": "Cache Multi-Résolution", "ru": "Многоразрешающий кэш"},
    "multi_resolution_cache_sub": {"pt": "Armazena imagens em múltiplas resoluções", "en": "Stores images in multiple resolutions", "es": "Almacena imágenes en múltiples resoluciones", "fr": "Stocke les images en plusieurs résolutions", "ru": "Сохраняет изображения в нескольких разрешениях"},
    "persistent_cache": {"pt": "Cache Persistente", "en": "Persistent Cache", "es": "Caché Persistente", "fr": "Cache Persistant", "ru": "Постоянный кэш"},
    "persistent_cache_sub": {"pt": "Mantém cache entre reinicializações", "en": "Keeps cache between restarts", "es": "Mantiene caché entre reinicios", "fr": "Conserve le cache entre les redémarrages", "ru": "Сохраняет кэш между перезапусками"},
    "setid": {"pt": "Salvando Client ID...", "en": "Saving Client ID...", "es": "Guardando Client ID...", "fr": "Enregistrement du Client ID...", "ru": "Сохранение Client ID..."},
    "setsecret": {"pt": "Salvando Client Secret...", "en": "Saving Client Secret...", "es": "Guardando Client Secret...", "fr": "Enregistrement du Client Secret...", "ru": "Сохранение Client Secret..."},
    "code": {"pt": "Trocando código...", "en": "Exchanging code...", "es": "Intercambiando código...", "fr": "Échange du code...", "ru": "Обмен кода..."},
    "exchanging_code": {"pt": "Trocando código de autorização...", "en": "Exchanging authorization code...", "es": "Intercambiando código de autorización...", "fr": "Échange du code d'autorisation...", "ru": "Обмен кода авторизации..."},
    "update": {"pt": "Gerar link de autorização", "en": "Generate auth link", "es": "Generar enlace de autorización", "fr": "Générer le lien d'autorisation", "ru": "Создать ссылку авторизации"},
    "check": {"pt": "Validando credenciais...", "en": "Validating credentials...", "es": "Validando credenciales...", "fr": "Validation des identifiants...", "ru": "Проверка учетных данных..."},
    "valid": {"pt": "Credenciais válidas!", "en": "Credentials are valid!", "es": "¡Credenciales válidas!", "fr": "Identifiants valides!", "ru": "Данные действительны!"},
    "client_id_or_secret_missing": {"pt": "Client ID ou Secret não configurados nas configurações!", "en": "Client ID or Secret not set in settings!", "es": "¡Client ID o Secret no configurados en la configuración!", "fr": "Client ID ou Secret non configurés dans les paramètres!", "ru": "Client ID или Secret не указаны в настройках!"},
    "error_missing_code": {"pt": "Use .code <código> para trocar o código de autorização.", "en": "Use .code <code> to exchange the authorization code.", "es": "Usa .code <código> para intercambiar el código de autorización.", "fr": "Utilisez .code <code> pour échanger le code d'autorisation.", "ru": "Используйте .code <код> для обмена кода авторизации."},
    "refresh_token_saved": {"pt": "Refresh Token salvo com sucesso", "en": "Refresh token saved successfully", "es": "Refresh token guardado con éxito", "fr": "Refresh token enregistré avec succès", "ru": "Токен обновления успешно сохранён"},
    "code_exchange_error": {"pt": "Erro ao trocar código", "en": "Error exchanging code", "es": "Error al intercambiar el código", "fr": "Erreur lors de l'échange du code", "ru": "Ошибка обмена кода"},
    "bio_updated": {"pt": "Bio atualizada!", "en": "Bio updated!", "es": "Bio actualizada!", "fr": "Bio mise à jour!", "ru": "Био обновлено!"},
    "bio_error": {"pt": "Erro ao atualizar bio.", "en": "Failed to update bio.", "es": "Error al actualizar la bio.", "fr": "Erreur lors de la mise à jour de la bio.", "ru": "Ошибка при обновлении био."},
    "cache_cleared": {"pt": "Cache limpo!", "en": "Cache cleared!", "es": "Caché limpiado!", "fr": "Cache vidé!", "ru": "Кэш очищен!"},
    "cache_cleared_mode": {"pt": "Cache limpo! Modo: {mode}", "en": "Cache cleared! Mode: {mode}", "es": "Caché limpiado! Modo: {mode}", "fr": "Cache vidé! Mode: {mode}", "ru": "Кэш очищен! Режим: {mode}"},
    "open_auth_link": {"pt": "Abra o link para autorizar: {url}", "en": "Open the link to authorize: {url}", "es": "Abre el enlace para autorizar: {url}", "fr": "Ouvrez le lien pour autoriser: {url}", "ru": "Откройте ссылку для авторизации: {url}"},
    "show_credentials": {"pt": "Configurações de Credenciais", "en": "Credentials Settings", "es": "Configuración de Credenciales", "fr": "Paramètres des identifiants", "ru": "Настройки учетных данных"},
    "show_credentials_sub": {"pt": "Expandir para configurar credenciais do Spotify", "en": "Expand to configure Spotify credentials", "es": "Expandir para configurar credenciales de Spotify", "fr": "Développer pour configurer les identifiants Spotify", "ru": "Развернуть для настройки учетных данных Spotify"},
    "spotify_credentials": {"pt": "Spotify", "en": "Spotify", "es": "Spotify", "fr": "Spotify", "ru": "Spotify"},
    "spotify_credentials_sub": {"pt": "Configure as credenciais da API do Spotify", "en": "Configure Spotify API credentials", "es": "Configurar credenciales de la API de Spotify", "fr": "Configurer les identifiants de l'API Spotify", "ru": "Настроить учетные данные API Spotify"},
    "spotify_auth_toggle": {"pt": "Spotify Auth", "en": "Spotify Auth", "es": "Spotify Auth", "fr": "Spotify Auth", "ru": "Spotify Auth"},
    "spotify_auth_toggle_sub": {
        "pt": "Se ativado, o Client ID, Secret e Refresh Token serão exibidos. Se desativado, ficam ocultos para privacidade.",
        "en": "If enabled, Client ID, Secret and Refresh Token will be shown. If disabled, they remain hidden for privacy.",
        "es": "Si está activado, se mostrarán Client ID, Secret y Refresh Token. Si está desactivado, permanecen ocultos por privacidad.",
        "fr": "Si activé, le Client ID, Secret et Refresh Token seront affichés. Si désactivé, ils restent masqués pour la confidentialité.",
        "ru": "Если включено, будут показаны Client ID, Secret и Refresh Token. Если отключено, они остаются скрытыми для конфиденциальности."
    },
    "spotify_auth_hidden_notice": {
        "pt": "As credenciais estão ocultas.",
        "en": "Credentials are hidden.",
        "es": "Las credenciales están ocultas.",
        "fr": "Les identifiants sont masqués.",
        "ru": "Учетные данные скрыты."
    },
    "spotify_control": {"pt": "Spotify Control", "en": "Spotify Control", "es": "Spotify Control", "fr": "Spotify Control", "ru": "Spotify Control"},
    "spotify_control_dialog": {
        "pt": "Comandos principais da integração Spotify:\n\n• .now — mostra a faixa atual\n• .play [ID] — reproduz faixa\n• .pause — pausa reprodução\n• .skip — próxima faixa (requer Premium)\n• .back — faixa anterior (requer Premium)\n• .vol [0-100] — ajusta volume\n• .repeat [modo] — alterna repetição\n• .search [termo] — busca faixas\n• .like now — favorita a faixa atual\n• .connect — conecta sua conta\n\nObservação: ações de controle de reprodução (pular/voltar) podem exigir Spotify Premium, uma limitação da plataforma.",
        "en": "Main commands for Spotify integration:\n\n• .now — show current track\n• .play [ID] — play track\n• .pause — pause playback\n• .skip — next track (Premium required)\n• .back — previous track (Premium required)\n• .vol [0-100] — set volume\n• .repeat [mode] — toggle repeat\n• .search [term] — search tracks\n• .like now — like current track\n• .connect — connect your account\n\nNote: playback control actions (skip/back) may require Spotify Premium due to platform limitations.",
        "es": "Comandos principales de la integración de Spotify:\n\n• .now — muestra la pista actual\n• .play [ID] — reproduce pista\n• .pause — pausa reproducción\n• .skip — siguiente pista (requiere Premium)\n• .back — pista anterior (requiere Premium)\n• .vol [0-100] — ajustar volumen\n• .repeat [modo] — alternar repetición\n• .search [término] — buscar pistas\n• .like now — marcar como favorita la pista actual\n• .connect — conectar tu cuenta\n\nNota: las acciones de control de reproducción (saltar/volver) pueden requerir Spotify Premium por limitaciones de la plataforma.",
        "fr": "Commandes principales pour l'intégration Spotify:\n\n• .now — affiche le titre en cours\n• .play [ID] — lire le titre\n• .pause — mettre en pause\n• .skip — piste suivante (Premium requis)\n• .back — piste précédente (Premium requis)\n• .vol [0-100] — régler le volume\n• .repeat [mode] — basculer la répétition\n• .search [terme] — rechercher des titres\n• .like now — ajouter le titre actuel aux favoris\n• .connect — connecter votre compte\n\nRemarque: les actions de contrôle (suivant/précédent) peuvent nécessiter Spotify Premium en raison des limitations de la plateforme.",
        "ru": "Основные команды интеграции Spotify:\n\n• .now — показать текущий трек\n• .play [ID] — воспроизвести трек\n• .pause — пауза\n• .skip — следующий трек (требуется Premium)\n• .back — предыдущий трек (требуется Premium)\n• .vol [0-100] — установить громкость\n• .repeat [режим] — переключить повтор\n• .search [запрос] — искать треки\n• .like now — добавить текущий трек в избранное\n• .connect — подключить аккаунт\n\nПримечание: действия управления воспроизведением (вперед/назад) могут требовать Spotify Premium из‑за ограничений платформы."
    },
    "statsfm_credentials": {"pt": "Stats.FM", "en": "Stats.FM", "es": "Stats.FM", "fr": "Stats.FM", "ru": "Stats.FM"},
    "statsfm_credentials_sub": {"pt": "Configure as credenciais do Stats.FM", "en": "Configure Stats.FM credentials", "es": "Configurar credenciales de Stats.FM", "fr": "Configurer les identifiants Stats.FM", "ru": "Настроить учетные данные Stats.FM"},
    
    # NowCast Settings
    "nowcast_section": {"pt": "NowCast (Beta)", "en": "NowCast (Beta)", "es": "NowCast (Beta)", "fr": "NowCast", "ru": "NowCast (Beta)"},
    "nowcast_enable": {"pt": "Ativar NowCast", "en": "Enable NowCast", "es": "Activar NowCast", "fr": "Activer NowCast", "ru": "Включить NowCast"},
    "nowcast_enable_sub": {
        "pt": "Posta automaticamente o Now Playing no canal sempre que o NowCast estiver ativo (músicas em tempo real).",
        "en": "Automatically posts Now Playing in the channel whenever NowCast is active (real-time music).",
        "es": "Publica automáticamente el Now Playing en el canal siempre que NowCast esté activo (música en tiempo real).",
        "fr": "Publie automatiquement le Now Playing dans le canal chaque fois que NowCast est actif (musique en temps réel).",
        "ru": "Автоматически публикует Now Playing в канале, когда активен NowCast (музыка в реальном времени)."
    },
    "nowcast_bot_token": {"pt": "Bot Token", "en": "Bot Token", "es": "Bot Token", "fr": "Bot Token", "ru": "Bot Token"},
    "nowcast_channel_id": {"pt": "Channel ID", "en": "Channel ID", "es": "Channel ID", "fr": "Channel ID", "ru": "Channel ID"},
    "nowcast_post_interval": {"pt": "Intervalo de Postagem", "en": "Post Interval", "es": "Intervalo de Publicación", "fr": "Intervalle de Publication", "ru": "Интервал Публикации"},
    "test_nowcast_connection": {"pt": "Testar Conexão NowCast", "en": "Test NowCast Connection", "es": "Probar Conexión NowCast", "fr": "Tester la Connexion NowCast", "ru": "Тест соединения NowCast"},
    "clear_nowcast_history": {"pt": "Limpar Histórico NowCast", "en": "Clear NowCast History", "es": "Limpiar Historial NowCast", "fr": "Effacer l'Historique NowCast", "ru": "Очистить историю NowCast"},
    
    # NowCast Link Options
    "nowcast_link_option": {"pt": "Link da Música", "en": "Music Link", "es": "Enlace de Música", "fr": "Lien Musical", "ru": "Музыкальная ссылка"},
    "nowcast_link_none": {"pt": "Nenhum", "en": "None", "es": "Ninguno", "fr": "Aucun", "ru": "Нет"},
    "nowcast_link_spotify": {"pt": "Spotify", "en": "Spotify", "es": "Spotify", "fr": "Spotify", "ru": "Spotify"},
    "nowcast_link_songlink": {"pt": "song.link", "en": "song.link", "es": "song.link", "fr": "song.link", "ru": "song.link"},
    "statsfm_username": {"pt": "Usuário do Stats.fm", "en": "Stats.fm Username", "es": "Usuario de Stats.fm", "fr": "Nom d'utilisateur Stats.fm", "ru": "Имя пользователя Stats.fm"},
    "statsfm_username_sub": {"pt": "Seu nome de usuário do stats.fm", "en": "Your stats.fm username", "es": "Tu usuario de stats.fm", "fr": "Votre nom d'utilisateur stats.fm", "ru": "Ваше имя пользователя stats.fm"},
    "show_cache_settings": {"pt": "Configurações de Cache", "en": "Cache Settings", "es": "Configuración de Caché", "fr": "Paramètres du cache", "ru": "Настройки кэша"},
    "show_cache_settings_sub": {
        "pt": "Expandir para opções avançadas de cache, compressão e desempenho",
        "en": "Expand to advanced cache, compression and performance settings",
        "es": "Expandir para opciones avanzadas de caché, compresión y rendimiento",
        "fr": "Développer pour les paramètres avancés de cache, compression et performance",
        "ru": "Развернуть для доступа к расширенным настройкам кэша, сжатия и производительности"
    },
    "clear_cache": {"pt": "Limpar Cache", "en": "Clear Cache", "es": "Limpiar Caché", "fr": "Vider le cache", "ru": "Очистить кэш"},
    "show_advanced_options": {"pt": "Opções Avançadas", "en": "Advanced Options", "es": "Opciones Avanzadas", "fr": "Options avancées", "ru": "Дополнительные параметры"},
    "show_advanced_options_sub": {"pt": "Expandir para configurar opções avançadas", "en": "Expand to configure advanced options", "es": "Expandir para configurar opciones avançadas", "fr": "Développer pour configurer les options avancées", "ru": "Развернуть для настройки дополнительных параметров"},
    "thumbnail_cache_section": {"pt": "Cache de Thumbnails", "en": "Thumbnail Cache", "es": "Caché de Miniaturas", "fr": "Cache des vignettes", "ru": "Кэш миниатюр"},
    "quality_options_section": {"pt": "Opções de Qualidade", "en": "Quality Options", "es": "Opciones de Calidad", "fr": "Options de qualité", "ru": "Параметры качества"},
    "youtube_cache": {"pt": "YouTube Cache", "en": "YouTube Cache", "es": "Caché YouTube", "fr": "Cache YouTube", "ru": "Кэш YouTube"},
    "youtube_cache_sub": {"pt": "Armazena thumbnails do YouTube para acesso mais rápido", "en": "Stores YouTube thumbnails for faster access", "es": "Almacena miniaturas de YouTube para acceso más rápido", "fr": "Stocke les vignettes YouTube pour un accès plus rapide", "ru": "Сохраняет миниатюры YouTube для быстрого доступа"},
    "soundcloud_cache": {"pt": "SoundCloud Cache", "en": "SoundCloud Cache", "es": "Caché SoundCloud", "fr": "Cache SoundCloud", "ru": "Кэш SoundCloud"},
    "soundcloud_cache_sub": {"pt": "Cache otimizado para thumbnails do SoundCloud", "en": "Optimized cache for SoundCloud thumbnails", "es": "Caché optimizado para miniaturas de SoundCloud", "fr": "Cache optimisé pour les vignettes SoundCloud", "ru": "Оптимизированный кэш для миниатюр SoundCloud"},
    "quality_fallback": {"pt": "Fallback Qualidade", "en": "Quality Fallback", "es": "Respaldo Calidad", "fr": "Basculement Qualité", "ru": "Резерв качества"},
    "quality_fallback_sub": {"pt": "Tenta diferentes qualidades se a principal falhar", "en": "Tries different qualities if main one fails", "es": "Intenta diferentes calidades si la principal falla", "fr": "Essaie différentes qualités si la principale échoue", "ru": "Пробует разные качества, если основное не работает"},
    "url_cache": {"pt": "Cache de URLs", "en": "URL Cache", "es": "Caché de URLs", "fr": "Cache d'URLs", "ru": "Кэш URL"},
    "url_cache_sub": {"pt": "Armazena URLs válidas para evitar verificações repetidas", "en": "Stores valid URLs to avoid repeated checks", "es": "Almacena URLs válidas para evitar verificaciones repetidas", "fr": "Stocke les URLs valides pour éviter les vérifications répétées", "ru": "Сохраняет действительные URL, чтобы избежать повторных проверок"},
    "adaptive_compression": {"pt": "Compressão Adaptativa", "en": "Adaptive Compression", "es": "Compresión Adaptativa", "fr": "Compression Adaptative", "ru": "Адаптивное Сжатие"},
    "adaptive_compression_sub": {"pt": "Ajusta qualidade automaticamente baseada na velocidade de conexão", "en": "Automatically adjusts quality based on connection speed", "es": "Ajusta automáticamente la calidad según la velocidad de conexión", "fr": "Ajuste automatiquement la qualité selon la vitesse de connexion", "ru": "Автоматически настраивает качество в зависимости от скорости соединения"},
    "enable_youtube_thumbnail_cache": {"pt": "Cache de thumbnails do YouTube", "en": "YouTube thumbnail cache", "es": "Caché de miniaturas de YouTube", "fr": "Cache des vignettes YouTube", "ru": "Кэш миниатюр YouTube"},
    "enable_youtube_thumbnail_cache_sub": {"pt": "Armazena thumbnails do YouTube para acesso mais rápido", "en": "Stores YouTube thumbnails for faster access", "es": "Almacena miniaturas de YouTube para acceso más rápido", "fr": "Stocke les vignettes YouTube pour un accès plus rapide", "ru": "Сохраняет миниатюры YouTube для быстрого доступа"},
    # Backup System Translations
    "backup_export_success": {"pt": "Backup exportado com sucesso!", "en": "Backup exported successfully!", "es": "Backup exportado exitosamente!", "fr": "Sauvegarde exportée avec succès!", "ru": "Резервная копия успешно экспортирована!"},
    "backup_export_error": {"pt": "Erro ao exportar backup", "en": "Error exporting backup", "es": "Error al exportar backup", "fr": "Erreur lors de l'exportation de la sauvegarde", "ru": "Ошибка при экспорте резервной копии"},
    "backup_import_error": {"pt": "Erro ao importar backup", "en": "Error importing backup", "es": "Error al importar backup", "fr": "Erreur lors de l'importation de la sauvegarde", "ru": "Ошибка при импорте резервной копии"},
    "backup_list_error": {"pt": "Erro ao listar backups", "en": "Error listing backups", "es": "Error al listar backups", "fr": "Erreur lors de la liste des sauvegardes", "ru": "Ошибка при получении списка резервных копий"},
    "backup_location": {"pt": "Local", "en": "Location", "es": "Ubicación", "fr": "Emplacement", "ru": "Расположение"},
    "backup_date": {"pt": "Data", "en": "Date", "es": "Fecha", "fr": "Date", "ru": "Дата"},
    "backup_no_files_found": {"pt": "Nenhum arquivo de backup encontrado!", "en": "No backup files found!", "es": "No se encontraron archivos de backup!", "fr": "Aucun fichier de sauvegarde trouvé!", "ru": "Файлы резервных копий не найдены!"},
    "backup_check_directory": {"pt": "Verifique se há arquivos em", "en": "Check if there are files in", "es": "Verifique si hay archivos en", "fr": "Vérifiez s'il y a des fichiers dans", "ru": "Проверьте наличие файлов в"},
    "backup_select_title": {"pt": "Selecionar Backup", "en": "Select Backup", "es": "Seleccionar Backup", "fr": "Sélectionner la sauvegarde", "ru": "Выбрать резервную копию"},
    "backup_cancel": {"pt": "Cancelar", "en": "Cancel", "es": "Cancelar", "fr": "Annuler", "ru": "Отмена"},
    "backup_imported_success": {"pt": "Backup importado com sucesso! Reinicie o Telegram para aplicar todas as mudanças.", "en": "Backup imported successfully! Restart Telegram to apply all changes.", "es": "Backup importado exitosamente! Reinicia Telegram para aplicar todos los cambios.", "fr": "Sauvegarde importée avec succès! Redémarrez Telegram pour appliquer tous les changements.", "ru": "Резервная копия успешно импортирована! Перезапустите Telegram для применения всех изменений."},
    "backup_checking_directory": {"pt": "Verificando diretório de backup...", "en": "Checking backup directory...", "es": "Verificando directorio de backup...", "fr": "Vérification du répertoire de sauvegarde...", "ru": "Проверка директории резервных копий..."},
    "backup_listing_files": {"pt": "Listando arquivos de backup...", "en": "Listing backup files...", "es": "Listando archivos de backup...", "fr": "Liste des fichiers de sauvegarde...", "ru": "Получение списка файлов резервных копий..."},
    "backup_selecting_recent": {"pt": "Selecionando backup mais recente...", "en": "Selecting most recent backup...", "es": "Seleccionando backup más reciente...", "fr": "Sélection de la sauvegarde la plus récente...", "ru": "Выбор самой последней резервной копии..."},
    "backup_reading_file": {"pt": "Lendo arquivo de backup...", "en": "Reading backup file...", "es": "Leyendo archivo de backup...", "fr": "Lecture du fichier de sauvegarde...", "ru": "Чтение файла резервной копии..."},
    "backup_validating_structure": {"pt": "Validando estrutura do backup...", "en": "Validating backup structure...", "es": "Validando estructura del backup...", "fr": "Validation de la structure de sauvegarde...", "ru": "Проверка структуры резервной копии..."},
    "backup_preparing_import": {"pt": "Preparando importação das configurações...", "en": "Preparing settings import...", "es": "Preparando importación de configuraciones...", "fr": "Préparation de l'importation des paramètres...", "ru": "Подготовка импорта настроек..."},
    "backup_applying_settings": {"pt": "Aplicando configurações do backup...", "en": "Applying backup settings...", "es": "Aplicando configuraciones del backup...", "fr": "Application des paramètres de sauvegarde...", "ru": "Применение настроек из резервной копии..."},
    "backup_verifying_settings": {"pt": "Verificando configurações aplicadas...", "en": "Verifying applied settings...", "es": "Verificando configuraciones aplicadas...", "fr": "Vérification des paramètres appliqués...", "ru": "Проверка примененных настроек..."},
    "backup_cleaning_cache": {"pt": "Limpando cache...", "en": "Cleaning cache...", "es": "Limpiando caché...", "fr": "Nettoyage du cache...", "ru": "Очистка кэша..."},
    "backup_import_completed": {"pt": "Importação concluída!", "en": "Import completed!", "es": "Importación completada!", "fr": "Importation terminée!", "ru": "Импорт завершен!"},
    "backup_directory_not_found": {"pt": "Diretório de backup não encontrado", "en": "Backup directory not found", "es": "Directorio de backup no encontrado", "fr": "Répertoire de sauvegarde introuvable", "ru": "Директория резервных копий не найдена"},
    "backup_no_files_available": {"pt": "Nenhum arquivo de backup encontrado", "en": "No backup files found", "es": "No se encontraron archivos de backup", "fr": "Aucun fichier de sauvegarde trouvé", "ru": "Файлы резервных копий не найдены"},
    "backup_read_error": {"pt": "Erro ao ler arquivo de backup", "en": "Error reading backup file", "es": "Error al leer archivo de backup", "fr": "Erreur lors de la lecture du fichier de sauvegarde", "ru": "Ошибка чтения файла резервной копии"},
    "backup_invalid_structure": {"pt": "Estrutura de backup inválida", "en": "Invalid backup structure", "es": "Estructura de backup inválida", "fr": "Structure de sauvegarde invalide", "ru": "Неверная структура резервной копии"},
    "backup_file_not_found": {"pt": "Arquivo de backup não encontrado", "en": "Backup file not found", "es": "Archivo de backup no encontrado", "fr": "Fichier de sauvegarde introuvable", "ru": "Файл резервной копии не найден"},
    "backup_invalid_file": {"pt": "Arquivo de backup inválido ou corrompido!", "en": "Invalid or corrupted backup file!", "es": "Archivo de backup inválido o corrupto!", "fr": "Fichier de sauvegarde invalide ou corrompu!", "ru": "Недействительный или поврежденный файл резервной копии!"},
    "backup_confirm_restore": {"pt": "Confirmar Restauração", "en": "Confirm Restore", "es": "Confirmar Restauración", "fr": "Confirmer la restauration", "ru": "Подтвердить восстановление"},
    "backup_restore_title": {"pt": "Restaurar Backup", "en": "Restore Backup", "es": "Restaurar Backup", "fr": "Restaurer la sauvegarde", "ru": "Восстановить резервную копию"},
    "backup_file": {"pt": "Arquivo", "en": "File", "es": "Archivo", "fr": "Fichier", "ru": "Файл"},
    "backup_version": {"pt": "Versão", "en": "Version", "es": "Versión", "fr": "Version", "ru": "Версия"},
    "backup_settings_count": {"pt": "Configurações", "en": "Settings", "es": "Configuraciones", "fr": "Paramètres", "ru": "Настройки"},
    "error_fragment_not_found": {"pt": "Erro: Fragment não encontrado", "en": "Error: Fragment not found", "es": "Error: Fragment no encontrado", "fr": "Erreur: Fragment introuvable", "ru": "Ошибка: Фрагмент не найден"},
    "unknown": {"pt": "Desconhecido", "en": "Unknown", "es": "Desconocido", "fr": "Inconnu", "ru": "Неизвестно"},

    "backup_warning_replace": {"pt": "Suas configurações atuais serão substituídas!", "en": "Your current settings will be replaced!", "es": "Sus configuraciones actuales serán reemplazadas!", "fr": "Vos paramètres actuels seront remplacés!", "ru": "Ваши текущие настройки будут заменены!"},
    "backup_confirm_button": {"pt": "Confirmar", "en": "Confirm", "es": "Confirmar", "fr": "Confirmer", "ru": "Подтвердить"},
    "backup_restore_success": {"pt": "Backup restaurado com sucesso!", "en": "Backup restored successfully!", "es": "Backup restaurado exitosamente!", "fr": "Sauvegarde restaurée avec succès!", "ru": "Резервная копия успешно восстановлена!"},
    "backup_settings_applied": {"pt": "Configurações aplicadas", "en": "Settings applied", "es": "Configuraciones aplicadas", "fr": "Paramètres appliqués", "ru": "Настройки применены"},
    "backup_restart_app": {"pt": "Reinicie o app para aplicar todas as mudanças.", "en": "Restart the app to apply all changes.", "es": "Reinicie la app para aplicar todos los cambios.", "fr": "Redémarrez l'application pour appliquer tous les changements.", "ru": "Перезапустите приложение, чтобы применить все изменения."},
    "backup_apply_error": {"pt": "Erro ao aplicar configurações", "en": "Error applying settings", "es": "Error al aplicar configuraciones", "fr": "Erreur lors de l'application des paramètres", "ru": "Ошибка при применении настроек"},
    "backup_restore_error": {"pt": "Erro ao restaurar backup", "en": "Error restoring backup", "es": "Error al restaurar backup", "fr": "Erreur lors de la restauration", "ru": "Ошибка при восстановлении"},
    "backup_import_starting": {"pt": "Iniciando processo de importação", "en": "Starting import process", "es": "Iniciando proceso de importación", "fr": "Démarrage du processus d'importation", "ru": "Запуск процесса импорта"},
    "backup_using_recent": {"pt": "Usando backup mais recente", "en": "Using most recent backup", "es": "Usando backup más reciente", "fr": "Utilisation de la sauvegarde la plus récente", "ru": "Использование самой последней резервной копии"},
    "backup_directory_not_found": {"pt": "Diretório de backup não encontrado", "en": "Backup directory not found", "es": "Directorio de backup no encontrado", "fr": "Répertoire de sauvegarde introuvable", "ru": "Каталог резервных копий не найден"},
    "backup_restart_required": {"pt": "Algumas mudanças exigem reiniciar o app", "en": "Some changes require restarting the app", "es": "Algunos cambios requieren reiniciar la app", "fr": "Certains changements nécessitent le redémarrage de l'app", "ru": "Некоторые изменения требуют перезапуска приложения"},
    "backup_create_first": {"pt": "Use .export para criar seu primeiro backup!", "en": "Use .export to create your first backup!", "es": "Use .export para crear su primer backup!", "fr": "Utilisez .export pour créer votre première sauvegarde!", "ru": "Используйте .export для создания первой резервной копии!"},
    "backup_list_title": {"pt": "Backups Disponíveis", "en": "Available Backups", "es": "Backups Disponibles", "fr": "Sauvegardes disponibles", "ru": "Доступные резервные копии"},
    "backup_total_size": {"pt": "Tamanho total", "en": "Total size", "es": "Tamaño total", "fr": "Taille totale", "ru": "Общий размер"},
    "backup_use_import": {"pt": "Use .import para restaurar um backup", "en": "Use .import to restore a backup", "es": "Use .import para restaurar un backup", "fr": "Utilisez .import pour restaurer une sauvegarde", "ru": "Используйте .import для восстановления резервной копии"},
    "backup_use_export": {"pt": "Use .export para criar seu primeiro backup", "en": "Use .export to create your first backup", "es": "Use .export para crear su primer backup", "fr": "Utilisez .export pour créer votre première sauvegarde", "ru": "Используйте .export для создания первой резервной копии"},
    "backup_directory": {"pt": "Diretório", "en": "Directory", "es": "Directorio", "fr": "Répertoire", "ru": "Каталог"},
    "backup_and_more": {"pt": "e mais {} backups", "en": "and {} more backups", "es": "y {} backups más", "fr": "et {} sauvegardes de plus", "ru": "и еще {} резервных копий"},
    "backup_read_error": {"pt": "erro ao ler", "en": "read error", "es": "error de lectura", "fr": "erreur de lecture", "ru": "ошибка чтения"},
    "backup_no_backups_found": {"pt": "Nenhum backup encontrado", "en": "No backups found", "es": "No se encontraron backups", "fr": "Aucune sauvegarde trouvée", "ru": "Резервные копии не найдены"},
    "enable_soundcloud_thumbnail_cache": {"pt": "Sistema de cache específico para SoundCloud", "en": "SoundCloud specific cache system", "es": "Sistema de caché específico para SoundCloud", "fr": "Système de cache spécifique à SoundCloud", "ru": "Специальная система кэша для SoundCloud"},
    "enable_soundcloud_thumbnail_cache_sub": {"pt": "Cache otimizado para thumbnails do SoundCloud", "en": "Optimized cache for SoundCloud thumbnails", "es": "Caché optimizado para miniaturas de SoundCloud", "fr": "Cache optimisé pour les vignettes SoundCloud", "ru": "Оптимизированный кэш для миниатюр SoundCloud"},
    "enable_quality_fallback": {"pt": "Fallback entre diferentes qualidades", "en": "Fallback between different qualities", "es": "Respaldo entre diferentes calidades", "fr": "Basculement entre différentes qualités", "ru": "Переключение между разными качествами"},
    "enable_quality_fallback_sub": {"pt": "Tenta diferentes qualidades se a principal falhar", "en": "Tries different qualities if main one fails", "es": "Intenta diferentes calidades si la principal falla", "fr": "Essaie différentes qualités si la principale échoue", "ru": "Пробует разные качества, если основное не работает"},
    "enable_url_cache": {"pt": "Cache de URLs de thumbnails válidas", "en": "Cache of valid thumbnail URLs", "es": "Caché de URLs de miniaturas válidas", "fr": "Cache des URLs de vignettes valides", "ru": "Кэш действительных URL миниатюр"},
    "enable_url_cache_sub": {"pt": "Armazena URLs válidas para evitar verificações repetidas", "en": "Stores valid URLs to avoid repeated checks", "es": "Almacena URLs válidas para evitar verificaciones repetidas", "fr": "Stocke les URLs valides pour éviter les vérifications répétées", "ru": "Сохраняет действительные URL, чтобы избежать повторных проверок"},
    "enable_auto_bio_update": {"pt": "Ativar atualização automática da bio", "en": "Enable automatic bio update", "es": "Activar actualización automática de la bio", "fr": "Activer la mise à jour automatique de la bio", "ru": "Включить автообновление био"},
    "enable_auto_bio_update_sub": {"pt": "Atualiza a bio automaticamente a cada 2 minutos", "en": "Updates bio automatically every 2 minutes", "es": "Actualiza la bio automáticamente cada 2 minutos", "fr": "Met à jour automatiquement la bio toutes les 2 minutes", "ru": "Автоматически обновляет био каждые 2 минуты"},
    "theme_selector": {"pt": "Tema do Card", "en": "Card Theme", "es": "Tema de la Tarjeta", "fr": "Thème de la carte", "ru": "Тема карточки"},
    "theme_selector_sub": {"pt": "Escolha o tema para o card", "en": "Choose the theme for the card", "es": "Elige el tema para la tarjeta", "fr": "Choisissez le thème de la carte", "ru": "Выберите тему карточки"},
    "apple_skin": {"pt": "Variante Apple", "en": "Apple Skin", "es": "Variante Apple", "fr": "Variante Apple", "ru": "Вариант Apple"},
    "apple_skin_sub": {"pt": "Escolha a variante Light / Dark / Red para o fundo e estilo do tema Apple.", "en": "Choose Light / Dark / Red variant for the Apple theme background and style.", "es": "Elige la variante Light / Dark / Red para el fondo y estilo del tema Apple.", "fr": "Choisissez la variante Light / Dark / Red pour l'arrière-plan et le style du thème Apple.", "ru": "Выберите вариант Light / Dark / Red для фона и стиля темы Apple."},
    "apple_light": {"pt": "Apple Light", "en": "Apple Light", "es": "Apple Light", "fr": "Apple Light", "ru": "Apple Light"},
    "minimal": {"pt": "Minimal", "en": "Minimal", "es": "Minimal", "fr": "Minimal", "ru": "Minimal"},
    "custom_caption": {"pt": "Legenda Personalizada", "en": "Custom Caption", "es": "Leyenda Personalizada", "fr": "Légende personnalisée", "ru": "Пользовательская подпись"},
    "custom_caption_sub": {
        "pt": "Texto personalizado para a legenda do card. Suporte aos placeholders: {track}, {artist}, {album}, {spotify}, {song}",
        "en": "Custom text for card caption. Supports placeholders: {track}, {artist}, {album}, {spotify}, {song}",
        "es": "Texto personalizado para la leyenda de la tarjeta. Soporta marcadores: {track}, {artist}, {album}, {spotify}, {song}",
        "fr": "Texte personnalisé pour la légende de la carte. Prend en charge les variables: {track}, {artist}, {album}, {spotify}, {song}",
        "ru": "Пользовательский текст для подписи карточки. Поддерживаются плейсхолдеры: {track}, {artist}, {album}, {spotify}, {song}"
    },
    "bot_caption": {"pt": "Legenda do Bot", "en": "Bot Caption", "es": "Leyenda del Bot", "fr": "Légende du Bot", "ru": "Подпись Бота"},
    "bot_caption_sub": {"pt": "Texto personalizado para a legenda do NowCast (apenas para o bot)", "en": "Custom text for NowCast caption (bot only)", "es": "Texto personalizado para la leyenda del NowCast (solo para el bot)", "fr": "Texte personnalisé pour la légende NowCast (bot uniquement)", "ru": "Пользовательский текст для подписи NowCast (только для бота)"},
    "show_chat_menu": {"pt": "Mostrar no Menu do Chat", "en": "Show in Chat Menu", "es": "Mostrar en el menú del chat", "fr": "Afficher dans le menu du chat", "ru": "Показать в меню чата"},
    "show_chat_menu_sub": {"pt": "Mostrar configurações do Nowfy no menu do chat", "en": "Show Nowfy settings in chat menu", "es": "Mostrar la configuración de Nowfy en el menú del chat", "fr": "Afficher les paramètres Nowfy dans le menu du chat", "ru": "Показать настройки Nowfy в меню чата"},
    "show_bio_notification": {"pt": "Mostrar notificação de bio", "en": "Show bio notification", "es": "Mostrar notificación de bio", "fr": "Afficher la notification de bio", "ru": "Показывать уведомление о био"},
    "show_bio_notification_sub": {"pt": "Mostra notificação quando a bio é atualizada", "en": "Shows notification when bio is updated", "es": "Muestra notificación cuando la bio se actualiza", "fr": "Affiche une notification lors de la mise à jour de la bio", "ru": "Показывать уведомление при обновлении био"},
    "show_track_link": {"pt": "Mostrar link da música", "en": "Show track link", "es": "Mostrar enlace de la canción", "fr": "Afficher le lien de la chanson", "ru": "Показать ссылку на трек"},
    "show_track_link_sub": {"pt": "Mostra o link da música na legenda", "en": "Shows track link in caption", "es": "Muestra el enlace de la canción en la leyenda", "fr": "Affiche le lien de la chanson dans la légende", "ru": "Показывать ссылку на трек в подписи"},
    "no_track_playing": {"pt": "Nenhuma música tocando no Spotify.", "en": "No track playing on Spotify.", "es": "No hay música reproduciéndose en Spotify.", "fr": "Aucune musique en cours sur Spotify.", "ru": "Нет воспроизводимой музыки в Spotify."},
    "no_track_playing_generic": {"pt": "Nenhuma música tocando no momento.", "en": "No track playing at the moment.", "es": "No hay música reproduciéndose en este momento.", "fr": "Aucune musique en cours de lecture en ce moment.", "ru": "Нет воспроизводимой музыки в данный момент."},
    "no_track_playing_title": {"pt": "Nenhuma música tocando", "en": "No track playing", "es": "No hay música reproduciéndose", "fr": "Aucune musique en cours", "ru": "Нет воспроизводимой музыки"},
    "no_track_playing_artist_spotify": {"pt": "no Spotify", "en": "on Spotify", "es": "en Spotify", "fr": "sur Spotify", "ru": "в Spotify"},
    "now_spotify_only": {
        "en": "Unsupported player. Switch to Spotify.",
        "pt": "Player não suportado. Altere para Spotify.",
        "es": "Reproductor no compatible. Cambia a Spotify.",
        "fr": "Lecteur non pris en charge. Passez à Spotify.",
        "ru": "Неподдерживаемый плеер. Переключитесь на Spotify."
    },
    "no_track_lastfm": {"pt": "Nenhuma música tocando no Last.fm no momento.", "en": "No track currently playing on Last.fm", "es": "No hay música reproduciéndose en Last.fm en este momento.", "fr": "Aucune musique en cours de lecture sur Last.fm en ce moment.", "ru": "Нет воспроизводимой музыки на Last.fm в данный момент."},
    "bio_restored": {"pt": "Bio restaurada!", "en": "Bio restored!", "es": "Bio restaurada!", "fr": "Bio restaurée!", "ru": "Био восстановлено!"},
    "restore_bio_text": {"pt": "Bio padrão/restaurar", "en": "Restore Bio Text", "es": "Restaurar texto de bio", "fr": "Restaurer le texte de la bio", "ru": "Восстановить био"},

    "restore_bio_text_sub": {
        "pt": "Bio será restaurada automaticamente ao usar .now e não houver música tocando, ou ao usar .bio.",
        "en": "Bio will be restored automatically when you use .now and no music is playing, or when using .bio.",
        "es": "La bio se restaurará automáticamente al usar .now y no haya música, o al usar .bio.",
        "fr": "La bio sera restaurée automatiquement lors de l'utilisation de .now sans musique ou avec .bio.",
        "ru": "Био будет восстановлено автоматически при использовании .now без музыки или при использовании .bio."
    },
    "original_bio_captured": {
        "pt": "Bio original capturada automaticamente",
        "en": "Original bio captured automatically",
        "es": "Bio original capturada automáticamente",
        "fr": "Bio originale capturée automatiquement",
        "ru": "Оригинальная био захвачена автоматически"
    },
    "bio_command_info": {
        "pt": "Sobre a bio",
        "en": "About bio",
        "es": "Sobre la bio",
        "fr": "À propos de la bio",
        "ru": "О био"
    },
    "now_playing_section": {
    "pt": "Configurações do Now Playing",
    "en": "Now Playing Settings",
    "es": "Configuración de Now Playing",
    "fr": "Paramètres de Now Playing",
    "ru": "Настройки Now Playing"
    },
    "extra_section": {
        "pt": "Opções Extras",
        "en": "Extra Options",
        "es": "Opciones Extra",
        "fr": "Options Supplémentaires",
        "ru": "Дополнительные параметры"
    },
    "bio_command_info_dialog": {
        "pt": "Como usar os recursos da Bio\n\nEste painel permite automatizar e personalizar sua bio do Telegram com informações da música atual. Veja o que cada opção faz:\n\n• Ativar atualização automática da bio: liga/desliga a atualização automática da bio com a música em reprodução.\n• Mostrar notificação de bio: exibe uma notificação quando você executa um comando (como .now) e a bio é atualizada com uma música em reprodução.\n• Texto da bio: define o texto que será usado enquanto uma música estiver tocando. Você pode usar {track} e {artist} para inserir o nome da música e do artista.\n• Bio padrão/restaurar: define o texto que será restaurado na bio quando não houver música tocando ou ao usar o comando .bio.\n\nLimitações do Telegram:\n- A bio do Telegram tem limite de 70 caracteres. Textos maiores serão cortados.\n- Mudanças muito frequentes podem ser temporariamente bloqueadas.\n\nSobre o comando .bio:\n- O comando .bio restaura manualmente sua bio para o texto padrão.\n- Útil para remover rapidamente a música da bio.\n- Sempre exibe uma notificação ao restaurar.\n\nDica: personalize o texto da bio para deixar seu perfil mais interessante!\n\n• Smart Bio: permite atualizar a bio em tempo real com a música que você está ouvindo no Spotify.",

        "en": "How to Use Bio Features\n\nThis panel lets you automate and customize your Telegram bio with information about the current track. Here's what each option does:\n\n• Enable automatic bio update: turns automatic bio updates on or off based on the currently playing song.\n• Show bio notification: displays a notification when you run a command (like .now) and your bio is updated with a playing track.\n• Bio text: sets the text that will be used in your bio while a song is playing. You can use {track} and {artist} to insert the song title and artist name.\n• Restore bio text: sets the text that will be restored in your bio when no music is playing or when you use the .bio command.\n\nTelegram limitations:\n- Telegram limits the bio to 70 characters. Longer texts will be cut off.\n- Frequent changes may be temporarily blocked.\n\nAbout the .bio command:\n- The .bio command manually restores your bio to the default text.\n- Useful for quickly removing the song from your bio.\n- Always displays a notification when restoring.\n\nTip: customize your bio text to make your profile more interesting!\n\n• Smart Bio: allows real-time bio updates with the song you're currently listening to on Spotify.",

        "es": "Cómo usar las funciones de Bio\n\nEste panel te permite automatizar y personalizar tu biografía de Telegram con información sobre la canción en reproducción. Esto es lo que hace cada opción:\n\n• Activar actualización automática de la bio: activa o desactiva la actualización automática de la biografía con la canción en reproducción.\n• Mostrar notificación de bio: muestra una notificación cuando usas un comando (como .now) y se actualiza la biografía con la canción actual.\n• Texto de la bio: define el texto que se usará mientras haya una canción en reproducción. Puedes usar {track} y {artist} para insertar el nombre de la canción y el artista.\n• Restaurar texto de bio: define el texto que se restaurará en la biografía cuando no haya música o al usar el comando .bio.\n\nLimitaciones de Telegram:\n- Telegram limita la biografía a 70 caracteres. Los textos más largos serán cortados.\n- Cambios frecuentes pueden ser bloqueados temporalmente.\n\nSobre el comando .bio:\n- El comando .bio restaura manualmente tu biografía al texto predeterminado.\n- Útil para quitar rápidamente la canción de la biografía.\n- Siempre muestra una notificación al restaurar.\n\nConsejo: personaliza tu biografía para hacer tu perfil más interesante.\n\n• Smart Bio: permite actualizar la biografía en tiempo real con la canción que estás escuchando en Spotify.",

        "fr": "Comment utiliser les fonctions Bio\n\nCe panneau vous permet d'automatiser et de personnaliser votre bio Telegram avec les informations sur la musique en cours. Voici ce que fait chaque option :\n\n• Activer la mise à jour automatique de la bio : active ou désactive la mise à jour automatique de la bio avec la musique en cours.\n• Afficher la notification de bio : affiche une notification lorsque vous exécutez une commande (par exemple .now) et que la bio est mise à jour avec la musique en cours.\n• Texte de la bio : définit le texte utilisé dans votre bio pendant qu'une chanson est en cours de lecture. Vous pouvez utiliser {track} et {artist} pour insérer le nom du morceau et de l'artiste.\n• Restaurer le texte de la bio : définit le texte qui sera restauré dans la bio lorsque plus aucune musique ne joue ou lors de l'utilisation de la commande .bio.\n\nLimitations de Telegram :\n- La bio est limitée à 70 caractères. Les textes plus longs seront tronqués.\n- Les changements fréquents peuvent être temporairement bloqués.\n\nÀ propos de la commande .bio :\n- La commande .bio restaure manuellement votre bio au texte par défaut.\n- Utile pour retirer rapidement la musique de la bio.\n- Affiche toujours une notification lors de la restauration.\n\nAstuce : personnalisez votre bio pour rendre votre profil plus intéressant !\n\n• Smart Bio : permet de mettre à jour la bio en temps réel avec la musique que vous écoutez sur Spotify.",

        "ru": "Как использовать функции био\n\nЭтот раздел позволяет автоматизировать и настроить вашу био в Telegram с информацией о текущем треке. Вот что делает каждая опция:\n\n• Включить автообновление био: включает или отключает автоматическое обновление био в зависимости от текущей песни.\n• Показывать уведомление о био: показывает уведомление, когда вы выполняете команду (например, .now), и био обновляется с текущим треком.\n• Текст био: задаёт текст, который будет использоваться в био во время воспроизведения музыки. Можно использовать {track} и {artist} для вставки названия трека и исполнителя.\n• Восстановить био: задаёт текст, который будет восстановлен в био, если музыка не играет или при использовании команды .bio.\n\nОграничения Telegram:\n- Био ограничено 70 символами. Более длинные тексты будут обрезаны.\n- Частые изменения могут быть временно заблокированы.\n\nО команде .bio:\n- Команда .bio вручную восстанавливает био к стандартному тексту.\n- Полезно для быстрого удаления трека из био.\n- Всегда отображает уведомление при восстановлении.\n\nСовет: настройте текст био, чтобы сделать профиль более интересным!\n\n• Smart Bio: позволяет обновлять био в реальном времени с песней, которую вы слушаете в Spotify."
    }, 
    "bulletin_pausing": {"pt": "Pausando música...", "en": "Pausing music...", "es": "Pausando música...", "fr": "Pause de la musique...", "ru": "Пауза музыки..."},
    "bulletin_playing": {"pt": "Tocando música...", "en": "Playing music...", "es": "Reproduciendo música...", "fr": "Lecture de la musique...", "ru": "Воспроизведение музыки..."},
    "search_results": {"pt": "Resultados da busca:", "en": "Search results:", "es": "Resultados de la búsqueda:", "fr": "Résultats de la recherche:", "ru": "Результаты поиска:"},
    "font_selector_label": {"pt": "Fontes", "en": "Fonts", "es": "Fuentes", "fr": "Polices", "ru": "Шрифты"},
    "extera_bar_label": {"pt": "exteraBar", "en": "exteraBar", "es": "exteraBar", "fr": "exteraBar", "ru": "exteraBar"},
    "extera_bar_sub": {
        "pt": "Barra de progresso da música (funciona apenas com Spotify ou .fm usando Spotify).",
        "en": "Music progress bar (works only with Spotify or .fm using Spotify).",
        "es": "Barra de progreso de la música (funciona solo con Spotify o .fm usando Spotify).",
        "fr": "Barre de progression musicale (fonctionne uniquement avec Spotify ou .fm utilisant Spotify).",
        "ru": "Индикатор прогресса музыки (работает только со Spotify или .fm используя Spotify)."
    },
    "liked_success": {"pt": "Faixa curtida!", "en": "Liked!", "es": "¡Favorito!", "fr": "Favori!", "ru": "Понравилось!"},
    "unliked_success": {"pt": "Faixa removida dos curtidos!", "en": "Unliked!", "es": "¡Desfavorito!", "fr": "Désaimé!", "ru": "Не понравилось!"},
    "error_invalid_number": {"pt": "Número inválido.", "en": "Invalid number.", "es": "Número inválido.", "fr": "Nombre invalide.", "ru": "Неверный номер."},
    "queue_success": {"pt": "Adicionado à fila!", "en": "Added to queue!", "es": "Adicionado a la fila!", "fr": "Ajouté à la file d'attente!", "ru": "Добавлено в очередь!"},
    "error_premium_required": {"pt": "Requer Spotify Premium.", "en": "Requires Spotify Premium.", "es": "Requiere Spotify Premium.", "fr": "Requiert Spotify Premium.", "ru": "Требуется Spotify Premium."},
    "error_no_active_device": {"pt": "Nenhum dispositivo ativo encontrado.", "en": "No active device found.", "es": "No se encontró dispositivo activo.", "fr": "Aucun appareil actif trouvé.", "ru": "Активное устройство не найдено."},
    "exchanging_code": {
        "pt": "Trocando código de autorização...",
        "en": "Exchanging authorization code...",
        "es": "Intercambiando código de autorización...",
        "fr": "Échange du code d'autorisation...",
        "ru": "Обмен кода авторизации..."
    },
    "code_exchange_error": {
        "pt": "Erro ao trocar código.",
        "en": "Error exchanging code.",
        "es": "Error al intercambiar código.",
        "fr": "Erreur lors de l'échange du code.",
        "ru": "Ошибка при обмене кода."
    },
    "client_id_or_secret_missing": {
        "pt": "Client ID ou Secret não configurados nas configurações!",
        "en": "Client ID or Secret not set in settings!",
        "es": "¡Client ID o Secret no configurados en la configuración!",
        "fr": "Client ID ou Secret non configurés dans les paramètres!",
        "ru": "Client ID или Secret не указаны в настройках!"
    },
    "visual_effects_section": {
        "pt": "Efeitos Visuais",
        "en": "Visual Effects",
        "es": "Efectos Visuales",
        "fr": "Effets Visuels",
        "ru": "Визуальные эффекты"
    },
    "random_theme_mode": {
        "pt": "Modo Aleatório de Tema",
        "en": "Random Theme Mode",
        "es": "Modo de Tema Aleatorio",
        "fr": "Mode Thème Aléatoire",
        "ru": "Случайный режим темы"
    },
    "random_theme_mode_sub": {
        "pt": "Ative para usar um tema de card aleatório a cada vez",
        "en": "Enable to use a random card theme each time",
        "es": "Activa para usar un tema de tarjeta aleatorio cada vez",
        "fr": "Activez pour utiliser un thème de carte aléatoire à chaque fois",
        "ru": "Включите, чтобы использовать случайную тему карточки каждый раз"
    },
    "use_play_command": {
        "en": "To play a result, use .play followed by its number or ID",
        "pt": "Para tocar um resultado, use .play seguido do número ou ID",
        "es": "Para reproducir un resultado, usa .play seguido del número o ID",
        "fr": "Pour lire un résultat, utilisez .play suivi du numéro ou de l'ID",
        "ru": "Чтобы воспроизвести результат, используйте .play с номером или ID"
    },
    "bio_updated_short": {"pt": "Bio atualizada com música", "en": "Bio updated with song", "es": "Bio actualizada con música", "fr": "Bio mise à jour avec musique", "ru": "Био обновлено с треком"},
    "bio_restored_auto": {"pt": "Bio restaurada automaticamente", "en": "Bio restored automatically", "es": "Bio restaurada automáticamente", "fr": "Bio restaurée automatiquement", "ru": "Био восстановлено автоматически"},
    "bio_notification_disabled": {
        "pt": "Notificação ativada, mas auto-refresh desativado",
        "en": "Notification enabled, but auto-refresh disabled",
        "es": "Notificación activada, pero auto-actualización desactivada",
        "fr": "Notification activée, mais actualisation auto désactivée",
        "ru": "Уведомление включено, но автообновление отключено"
    },
    "lastfm_settings": {
        "pt": "Configurações do LastFM",
        "en": "LastFM Settings",
        "es": "Configuración de LastFM",
        "fr": "Paramètres LastFM",
        "ru": "Настройки LastFM"
    },
    "tg_command": {
        "pt": "Comando Telegram",
        "en": "Telegram Command",
        "es": "Comando Telegram",
        "fr": "Commande Telegram",
        "ru": "Команда Telegram"
    },
    "tg_command_sub": {
        "pt": "Mostra a música atual do Telegram/Exteragram/Ayugram",
        "en": "Shows current track from Telegram/Exteragram/Ayugram",
        "es": "Muestra la pista actual de Telegram/Exteragram/Ayugram",
        "fr": "Affiche la piste actuelle de Telegram/Exteragram/Ayugram",
        "ru": "Показывает текущий трек из Telegram/Exteragram/Ayugram"
    },
    "help_title": {
        "pt": "Comandos Disponíveis",
        "en": "Available Commands",
        "es": "Comandos Disponibles",
        "fr": "Commandes Disponibles",
        "ru": "Доступные команды"
    },
    "help_message": {
        "pt": "˪ Comandos disponíveis do nowFy:\n\n• .now - Mostra a música atual do Spotify\n• .fm - Mostra a música atual do LastFM\n• .stats - Mostra a música atual do Stats.fm\n• .etg - Mostra a música atual do exteraGram\n• .ayu - Mostra a música atual do AyuGram\n• .clear - Limpar cache do plugin\n• .list - Mostra as últimas 5 músicas tocadas\n• .play - Toca a música atual ou .play <número> para tocar da lista\n• .pause - Pausa a reprodução\n• .skip - Pula para a próxima música\n• .back - Volta para a música anterior\n• .vol - Mostra o volume atual ou .vol <valor> para definir\n• .repeat - Mostra o modo de repetição ou .repeat <modo> para definir\n• .like - Adiciona a música atual aos favoritos ou .like <track_id>\n• .bio - Restaura a bio padrão\n• .code - Mostra instruções para autenticação ou .code <código>\n• .setid <id> - Define o Client ID do Spotify\n• .setsecret <secret> - Define o Client Secret do Spotify\n• .check - Valida as credenciais do Spotify\n• .connect - Gera o link para conectar sua conta Spotify\n• .search <termo> - Busca músicas no Spotify\n• .like now - Adiciona a música atual aos favoritos\n\nBackup e Restauração:\n• .export - Exporta todas as configurações para backup\n• .import - Importa configurações de um backup\n• .backups - Lista todos os backups disponíveis\n\nLastFM:\n• .setuser <usuário> - Define o usuário do LastFM\n• .setkey <api_key> - Define a chave da API do LastFM",
        "en": "˪ Available nowFy Commands:\n\n• .now - Show current playing track from Spotify (or your custom command)\n• .fm - Show current track from LastFM\n• .stats - Show current track from Stats.fm\n• .etg - Show current track from exteraGram\n• .ayu - Show current track from AyuGram\n• .clear - Clear plugin cache\n• .list - Show last 5 played tracks\n• .play - Play current track or .play <number> to play from list\n• .pause - Pause playback\n• .skip - Skip to next track\n• .back - Go back to previous track\n• .vol - Show current volume or .vol <value> to set\n• .repeat - Show repeat mode or .repeat <mode> to set\n• .like - Add current track to favorites or .like <track_id>\n• .bio - Restore default bio\n• .code - Show authentication instructions or .code <code>\n• .setid <id> - Set Spotify Client ID\n• .setsecret <secret> - Set Spotify Client Secret\n• .check - Validate Spotify credentials\n• .connect - Generate link to connect your Spotify account\n• .search <term> - Search tracks on Spotify\n• .like now - Add current track to favorites\n\nBackup & Restore:\n• .export - Export all settings to backup\n• .import - Import settings from backup\n• .backups - List all available backups\n\nLastFM:\n• .setuser <username> - Set LastFM username\n• .setkey <api_key> - Set LastFM API key",
        "es": "˪ Comandos disponibles de nowFy:\n\n• .now - Muestra la pista actual de Spotify\n• .fm - Muestra la pista actual de LastFM\n• .list - Muestra las últimas 5 pistas reproducidas\n• .play - Reproduce la pista actual o .play <número> para reproducir de la lista\n• .pause - Pausa la reproducción\n• .skip - Salta a la siguiente pista\n• .back - Vuelve a la pista anterior\n• .vol - Muestra el volumen actual o .vol <valor> para definir\n• .repeat - Muestra el modo de repetición o .repeat <modo> para definir\n• .like - Añade la pista actual a favoritos o .like <track_id>\n• .bio - Restaura la bio por defecto\n• .code - Muestra instrucciones de autenticación o .code <código>\n• .setid <id> - Define el Client ID de Spotify\n• .setsecret <secret> - Define el Client Secret de Spotify\n• .check - Valida las credenciales de Spotify\n• .connect - Genera el enlace para conectar tu cuenta de Spotify\n• .search <término> - Busca pistas en Spotify\n• .like now - Añade la pista actual a favoritos\n\nCopia de Seguridad:\n• .export - Exporta todas las configuraciones\n• .import - Importa configuraciones desde copia\n• .backups - Lista todas las copias disponibles\n\nLastFM:\n• .setuser <usuario> - Define el usuario de LastFM\n• .setkey <api_key> - Define la clave API de LastFM",
        "fr": "˪ Commandes nowFy disponibles:\n\n• .now - Afficher la piste en cours de Spotify\n• .fm - Afficher la piste en cours de LastFM\n• .list - Afficher les 5 dernières pistes\n• .play - Lire la piste actuelle ou .play <numéro> pour lire depuis la liste\n• .pause - Mettre en pause la lecture\n• .skip - Passer à la piste suivante\n• .back - Revenir à la piste précédente\n• .vol - Afficher le volume actuel ou .vol <valeur> pour définir\n• .repeat - Afficher le mode répétition ou .repeat <mode> pour définir\n• .like - Ajouter la piste actuelle aux favoris ou .like <track_id>\n• .bio - Restaurer la bio par défaut\n• .code - Afficher les instructions d'authentification ou .code <code>\n• .setid <id> - Définir le Client ID Spotify\n• .setsecret <secret> - Définir le Client Secret Spotify\n• .check - Valider les identifiants Spotify\n• .connect - Générer le lien pour connecter votre compte Spotify\n• .search <terme> - Rechercher des pistes sur Spotify\n• .like now - Ajouter la piste actuelle aux favoris\n\nSauvegarde et Restauration:\n• .export - Exporter toutes les configurations\n• .import - Importer les configurations\n• .backups - Lister toutes les sauvegardes\n\nLastFM:\n• .setuser <utilisateur> - Définir le nom d'utilisateur LastFM\n• .setkey <api_key> - Définir la clé API LastFM",
        "ru": "˪ Доступные команды nowFy:\n\n• .now - Показать текущий трек Spotify\n• .fm - Показать текущий трек LastFM\n• .list - Показать последние 5 треков\n• .play - Воспроизвести текущий трек или .play <номер> для воспроизведения из списка\n• .pause - Пауза воспроизведения\n• .skip - Следующий трек\n• .back - Предыдущий трек\n• .vol - Показать текущую громкость или .vol <значение> для установки\n• .repeat - Показать режим повтора или .repeat <режим> для установки\n• .like - Добавить текущий трек в избранное или .like <track_id>\n• .bio - Восстановить био по умолчанию\n• .code - Показать инструкции по авторизации или .code <код>\n• .setid <id> - Установить Client ID Spotify\n• .setsecret <secret> - Установить Client Secret Spotify\n• .check - Проверить учетные данные Spotify\n• .connect - Сгенерировать ссылку для подключения аккаунта Spotify\n• .search <запрос> - Поиск треков в Spotify\n• .like now - Добавить текущий трек в избранное\n\nРезервное копирование:\n• .export - Экспорт всех настроек\n• .import - Импорт настроек из резервной копии\n• .backups - Список всех резервных копий\n\nLastFM:\n• .setuser <имя> - Установить имя пользователя LastFM\n• .setkey <api_key> - Установить API ключ LastFM"
    },
    "error_youtube_api_key": {
        "pt": "Chave da API do YouTube não configurada",
        "en": "YouTube API key not configured",
        "es": "Clave API de YouTube no configurada",
        "fr": "Clé API YouTube non configurée",
        "ru": "Ключ API YouTube не настроен"
    },
    "error_youtube_api": {
        "pt": "Erro na API do YouTube: {}",
        "en": "YouTube API error: {}",
        "es": "Error en la API de YouTube: {}",
        "fr": "Erreur API YouTube: {}",
        "ru": "Ошибка API YouTube: {}"
    },
    "about_plugin_header": {
        "en": "Support the Project",
        "pt": "Incentivo ao Projeto",
        "es": "Apoya el Proyecto",
        "fr": "Soutenir le projet",
        "ru": "Поддержать проект"
    },
    "about_plugin_donate": {
        "en": "Donate (PIX Brazil)",
        "pt": "Doar (PIX Brasil)",
        "es": "Donar (PIX Brazil)",
        "fr": "Faire un don (PIX Brazil)",
        "ru": "Донат (PIX Brazil)"
    },
    "about_plugin_donate_kofi": {
        "en": "Donate (Ko-fi)",
        "pt": "Doar (Ko-fi)",
        "es": "Donar (Ko-fi)",
        "fr": "Faire un don (Ko-fi)",
        "ru": "Донат (Ko-fi)"
    },
    "about_plugin_description": {
        "en": "This plugin was created to integrate Spotify and LastFM/StatsFM into exteraGram/AyuGram in a visual and functional way. It allows you to show what you're listening to with a stylish image and automatically updates your bio with the currently playing track.\n\nIt also offers multi-language support and simple configuration options to make it your own, without complication.",
        "pt": "Esse plugin foi criado para integrar Spotify e LastFM/StatsFM ao exteraGram/AyuGram de forma visual e funcional. Ele permite mostrar o que você está ouvindo com uma imagem estilizada e atualiza a bio automaticamente com a faixa em reprodução.\n\nTambém oferece suporte a múltiplos idiomas e opções simples de configuração para deixar do seu jeito, sem complicação.",
        "es": "Este plugin fue creado para integrar Spotify y LastFM/StatsFM en exteraGram/AyuGram de forma visual y funcional. Permite mostrar lo que estás escuchando con una imagen estilizada y actualiza la bio automáticamente con la pista en reproducción.\n\nTambién ofrece soporte multilingüe y opciones de configuración simples para dejarlo a tu gusto, sin complicaciones.",
        "fr": "Ce plugin a été créé pour intégrer Spotify et LastFM/StatsFM à exteraGram/AyuGram de manière visuelle et fonctionnelle. Il permet d'afficher ce que vous écoutez avec une image stylisée et met à jour automatiquement la bio avec la piste en cours de lecture.\n\nIl offre également la prise en charge de plusieurs langues et des options de configuration simples pour l'adapter à vos besoins, sans complication.",
        "ru": "Этот плагин создан для интеграции Spotify и LastFM/StatsFM в exteraGram/AyuGram визуально и функционально. Он позволяет показывать, что вы слушаете, с помощью стильного изображения и автоматически обновляет био с текущим треком.\n\nТакже поддерживает несколько языков и простые настройки, чтобы сделать всё по-своему, без лишних сложностей."
    },
    "error_youtube_quota": {
        "pt": "Cota da API do YouTube excedida",
        "en": "YouTube API quota exceeded",
        "es": "Cuota de la API de YouTube excedida",
        "fr": "Quota API YouTube dépassé",
        "ru": "Квота API YouTube превышена"
    },
    "backup_exported": {
        "pt": "Backup exportado com sucesso!",
        "en": "Backup exported successfully!",
        "es": "Backup exportado exitosamente!",
        "fr": "Sauvegarde exportée avec succès!",
        "ru": "Резервная копия успешно экспортирована!"
    },
    "backup_imported": {
        "pt": "Backup importado com sucesso!",
        "en": "Backup imported successfully!",
        "es": "Backup importado exitosamente!",
        "fr": "Sauvegarde importée avec succès!",
        "ru": "Резервная копия успешно импортирована!"
    },
    "backup_error": {
        "pt": "Erro no sistema de backup: {}",
        "en": "Backup system error: {}",
        "es": "Error en el sistema de backup: {}",
        "fr": "Erreur du système de sauvegarde: {}",
        "ru": "Ошибка системы резервного копирования: {}"
    },
    "no_backups_found": {
        "pt": "Nenhum backup encontrado",
        "en": "No backups found",
        "es": "No se encontraron backups",
        "fr": "Aucune sauvegarde trouvée",
        "ru": "Резервные копии не найдены"
    },
    "about_custom_fonts": {
        "pt": "Fontes Personalizadas",
        "en": "Custom Fonts",
        "es": "Fuentes Personalizadas",
        "ru": "Пользовательские шрифты",
        "fr": "Polices personnalisées"
    },
    "custom_fonts_help": {
        "pt": "Ajuda sobre fontes personalizadas",
        "en": "Custom Fonts Help",
        "es": "Ayuda de fuentes personalizadas",
        "fr": "Aide sur les polices personnalisées",
        "ru": "Справка по пользовательским шрифтам"
    },
    "how_to_use_premium_emoji": {
        "pt": "Premium Emoji",
        "en": "Premium Emoji",
        "es": "Emoji Premium",
        "fr": "Emoji Premium",
        "ru": "Премиум Эмодзи"
    },
    "premium_emoji_help_title": {
        "pt": "Como Usar Premium Emoji",
        "en": "How to Use Premium Emoji",
        "es": "Cómo Usar Emoji Premium",
        "fr": "Comment Utiliser les Emoji Premium",
        "ru": "Как Использовать Премиум Эмодзи"
    },
    "premium_emoji_help_content": {
    "pt": "Para usar emojis Premium personalizados, é obrigatório ser um usuário Premium do Telegram.\n\nPara adicionar um emoji Premium no custom caption, você deve usar o formato:\n\n \n\n(Substitua o ID pelo do seu emoji)\n\nVocê pode descobrir o ID de qualquer emoji Premium enviando o emoji para o bot @AdsMarkdownBot e copiando o ID retornado. O formato final sempre será assim: [emoji](id).",
    "en": "To use custom Premium emojis, you must be a Telegram Premium user.\n\nTo add a Premium emoji in the custom caption, use the format:\n\n \n\n(Replace the ID with your emoji's ID)\n\nYou can find the ID of any Premium emoji by sending it to the @AdsMarkdownBot and copying the returned ID. The final format will always be: [emoji](id).",
    "es": "Para usar emojis Premium personalizados, debes ser usuario Premium de Telegram.\n\nPara agregar un emoji Premium en el pie de foto personalizado, usa el formato:\n\n \n\n(Reemplaza el ID por el de tu emoji)\n\nPuedes encontrar el ID de cualquier emoji Premium enviándolo al bot @AdsMarkdownBot y copiando el ID devuelto. El formato final siempre será: [emoji](id).",
    "fr": "Pour utiliser des emojis Premium personnalisés, vous devez être utilisateur Telegram Premium.\n\nPour ajouter un emoji Premium dans la légende personnalisée, utilisez le format :\n\n \n\n(Remplacez l'ID par celui de votre emoji)\n\nVous pouvez trouver l'ID d'un emoji Premium en l'envoyant au bot @AdsMarkdownBot et en copiant l'ID retourné. Le format final sera toujours : [emoji](id).",
    "ru": "Чтобы использовать пользовательские премиум-эмодзи, вы должны быть пользователем Telegram Premium.\n\nЧтобы добавить премиум-эмодзи в пользовательскую подпись, используйте формат:\n\n \n\n(Замените ID на ID вашего эмодзи)\n\nВы можете узнать ID любого премиум-эмодзи, отправив его боту @AdsMarkdownBot и скопировав возвращённый ID. Итоговый формат всегда будет таким: [emoji](id)."
    },
    "custom_fonts_help_dialog": {
        "pt": "Para usar fontes personalizadas, coloque arquivos .ttf ou .otf na pasta:\n/storage/emulated/0/Android/media/com.exteragram.messenger/fonts\nDepois, selecione a fonte desejada no seletor de fontes.",
        "en": "To use custom fonts, place .ttf or .otf files in the folder:\n/storage/emulated/0/Android/media/com.exteragram.messenger/fonts\nThen select the desired font in the font selector.",
        "es": "Para usar fuentes personalizadas, coloque archivos .ttf o .otf en la carpeta:\n/storage/emulated/0/Android/media/com.exteragram.messenger/fonts\nLuego seleccione la fuente deseada en el selector de fuentes.",
        "fr": "Pour utiliser des polices personnalisées, placez les fichiers .ttf ou .otf dans le dossier :\n/storage/emulated/0/Android/media/com.exteragram.messenger/fonts\nEnsuite, sélectionnez la police souhaitée dans le sélecteur de polices.",
        "ru": "Чтобы использовать пользовательские шрифты, поместите файлы .ttf или .otf в папку:\n/storage/emulated/0/Android/media/com.exteragram.messenger/fonts\nЗатем выберите нужный шрифт в селекторе шрифтов."
    },
    "client_id_missing": {
        "pt": "Client ID não configurado nas credenciais!",
        "en": "Client ID not set in credentials!",
        "es": "¡Client ID no configurado en las credenciales!",
        "fr": "Client ID non configuré dans les identifiants!",
        "ru": "Client ID не указан в учетных данных!"
    },
    "error_auth": {"pt": "Erro de autenticação", "en": "Authentication error", "es": "Error de autenticación", "fr": "Erreur d'authentification", "ru": "Ошибка авторизации"},
    "credentials_missing_title": {"pt": "Credenciais Ausentes", "en": "Missing Credentials", "es": "Credenciales Ausentes", "fr": "Identifiants Manquants", "ru": "Отсутствуют Учетные Данные"},
    "credentials_missing_message": {"pt": "As seguintes credenciais estão ausentes: {fields}. Configure-as nas configurações do plugin.", "en": "The following credentials are missing: {fields}. Configure them in the plugin settings.", "es": "Las siguientes credenciais están ausentes: {fields}. Configúralas en la configuración del plugin.", "fr": "Les identifiants suivants sont manquants : {fields}. Configurez-les dans les paramètres du plugin.", "ru": "Отсутствуют следующие учетные данные: {fields}. Настройте их в параметрах плагина."},
    "credentials_invalid_title": {"pt": "Credenciais Inválidas", "en": "Invalid Credentials", "es": "Credenciales Inválidas", "fr": "Identifiants Invalides", "ru": "Неверные Учетные Данные"},
    "credentials_invalid_message": {"pt": "As credenciais {fields} estão incorretas. Verifique se foram inseridas corretamente.", "en": "The credentials {fields} are incorrect. Please verify they were entered correctly.", "es": "Las credenciales {fields} son incorrectas. Verifica que se hayan ingresado correctamente.", "fr": "Les identifiants {fields} sont incorrects. Vérifiez qu'ils ont été saisis correctement.", "ru": "Учетные данные {fields} неверны. Проверьте правильность ввода."},
    "refresh_token_invalid_title": {"pt": "Token de Refresh Inválido", "en": "Invalid Refresh Token", "es": "Token de Refresh Inválido", "fr": "Token de Rafraîchissement Invalide", "ru": "Неверный Токен Обновления"},
    "refresh_token_invalid_message": {"pt": "O token de refresh expirou ou é inválido. Faça a autenticação novamente.", "en": "The refresh token has expired or is invalid. Please authenticate again.", "es": "El token de refresh ha expirado o es inválido. Autentica nuevamente.", "fr": "Le token de rafraîchissement a expiré ou est invalide. Veuillez vous authentifier à nouveau.", "ru": "Токен обновления истек или недействителен. Пожалуйста, пройдите аутентификацию снова."},
    "api_error_title": {"pt": "Erro da API do Spotify", "en": "Spotify API Error", "es": "Error de la API de Spotify", "fr": "Erreur de l'API Spotify", "ru": "Ошибка API Spotify"},
    "api_error_message": {"pt": "Ocorreu um erro na comunicação com a API do Spotify. Tente novamente mais tarde.", "en": "An error occurred while communicating with the Spotify API. Please try again later.", "es": "Ocurrió un error al comunicarse con la API de Spotify. Inténtalo de nuevo más tarde.", "fr": "Une erreur s'est produite lors de la communication avec l'API Spotify. Veuillez réessayer plus tard.", "ru": "Произошла ошибка при обращении к API Spotify. Попробуйте еще раз позже."},
    "connection_error_title": {"pt": "Erro de Conexão", "en": "Connection Error", "es": "Error de Conexión", "fr": "Erreur de Connexion", "ru": "Ошибка Соединения"},
    "connection_error_message": {"pt": "Não foi possível conectar com o Spotify. Verifique sua conexão com a internet.", "en": "Could not connect to Spotify. Please check your internet connection.", "es": "No se pudo conectar con Spotify. Verifica tu conexión a internet.", "fr": "Impossible de se connecter à Spotify. Vérifiez votre connexion internet.", "ru": "Не удалось подключиться к Spotify. Проверьте подключение к интернету."},
    "no_active_device": {
        "pt": "Nenhum dispositivo ativo encontrado.",
        "en": "No active device found.",
        "es": "No se encontró ningún dispositivo activo.",
        "fr": "Aucun appareil actif trouvé.",
        "ru": "Активное устройство не найдено."
    },
    "error_playback": {"pt": "Erro ao reproduzir", "en": "Error playing", "es": "Error al reproducir", "fr": "Erreur lors de la lecture", "ru": "Ошибка воспроизведения"},
    "error_no_device": {"pt": "Nenhum dispositivo encontrado", "en": "No device found", "es": "Ningún dispositivo encontrado", "fr": "Aucun appareil trouvé", "ru": "Устройство не найдено"},
    "error_token": {"pt": "Token inválido", "en": "Invalid token", "es": "Token no válido", "fr": "Token invalide", "ru": "Неверный токен"},
    "error_unknown": {"pt": "Erro desconhecido", "en": "Unknown error", "es": "Error desconocido", "fr": "Erreur inconnue", "ru": "Неизвестная ошибка"},
    "error_code": {"pt": "Erro de código", "en": "Code error", "es": "Error de código", "fr": "Erreur de code", "ru": "Ошибка кода"},
    "list_bulletin_title": {
        "pt": "Aqui está sua lista:",
        "en": "Here is your list:",
        "es": "Aquí está tu lista:",
        "fr": "Voici votre liste:",
        "ru": "Вот ваш список:"
    },
    "copy_button": {
        "pt": "Copiar",
        "en": "Copy",
        "es": "Copiar",
        "fr": "Copier",
        "ru": "Копировать"
    },
    "copied_bulletin": {
        "pt": "Copiado!",
        "en": "Copied!",
        "es": "¡Copiado!",
        "fr": "Copié!",
        "ru": "Скопировано!"
    },
    "copied_to_clipboard": {
        "pt": "{label} copiado para a área de transferência",
        "en": "Copied {label} to clipboard",
        "es": "{label} copiado al portapapeles",
        "fr": "{label} copié dans le presse-papiers",
        "ru": "{label} скопировано в буфер обмена"
    },
    "list_bulletin_short": {
        "pt": "Sua lista foi atualizada!\nClique em copiar para conferir.",
        "en": "Your list is ready!\nTap copy to check it.",
        "es": "¡Tu lista está pronta!\nPulsa copiar para ver.",
        "fr": "Votre liste est prête!\nAppuyez sur copier pour voir.",
        "ru": "Ваш список готов!\nНажмите копировать, чтобы посмотреть."
    },
    "recently_played_title": {
        "pt": "Suas músicas mais ouvidas recentemente:\n",
        "en": "Your recently played tracks:\n",
        "es": "Tus canciones reproducidas recientemente:\n",
        "fr": "Vos morceaux écoutés récemment :\n",
        "ru": "Ваши недавно прослушанные треки:\n"
    },
    "bulletin_paused": {
        "pt": "Música pausada!",
        "en": "Music paused!",
        "es": "¡Música pausada!",
        "fr": "Musique en pause!",
        "ru": "Музыка на паузе!"
    },
    "bulletin_resumed": {
        "pt": "Música retomada!",
        "en": "Music resumed!",
        "es": "¡Música retomada!",
        "fr": "Musique reprise!",
        "ru": "Музыка возобновлена!"
    },
    "bulletin_skipped": {
        "pt": "Faixa pulada!",
        "en": "Track skipped!",
        "es": "¡Canción saltada!",
        "fr": "Morceau passé!",
        "ru": "Трек пропущен!"
    },
    "bulletin_previous": {
        "pt": "Faixa anterior!",
        "en": "Previous track!",
        "es": "¡Canción anterior!",
        "fr": "Morceau précédent!",
        "ru": "Предыдущий трек!"
    },
    "bulletin_volume_set": {
        "pt": "Volume ajustado para {value}%!",
        "en": "Volume set to {value}%!",
        "es": "¡Volumen ajustado a {value}%!",
        "fr": "Volume réglé à {value}% !",
        "ru": "Громкость установлена на {value}%!"
    },
    "error_invalid_volume": {
        "pt": "Volume deve ser um número entre 0 e 100.",
        "en": "Volume must be a number between 0 and 100.",
        "es": "El volumen debe ser un número entre 0 y 100.",
        "fr": "Le volume doit être un nombre entre 0 et 100.",
        "ru": "Громкость должна быть числом от 0 до 100."
    },
    "bulletin_repeat_off": {
        "pt": "Repeat desativado!",
        "en": "Repeat off!",
        "es": "Repetición desactivada!",
        "fr": "Répétition désactivée!",
        "ru": "Повтор выключен!"
    },
    "bulletin_repeat_context": {
        "pt": "Repeat de playlist ativado!",
        "en": "Context repeat enabled!",
        "es": "Repetir contexto activado!",
        "fr": "Répétition du contexte activée!",
        "ru": "Повтор контекста включён!"
    },
    "bulletin_repeat_track": {
        "pt": "Repeat de faixa ativado!",
        "en": "Track repeat enabled!",
        "es": "Repetir faixa activado!",
        "fr": "Répétition de la piste activée!",
        "ru": "Повтор трека включён!"
    },
    "error_invalid_repeat": {
        "pt": "Modo repeat inválido. Use: off, context ou track.",
        "en": "Invalid repeat mode. Use: off, context or track.",
        "es": "Modo de repetición inválido. Use: off, context o track.",
        "fr": "Mode de répétition invalide. Utilisez : off, context ou track.",
        "ru": "Недопустимый режим повтора. Используйте: off, context или track."
    },
    "error_missing_volume": {
        "pt": "Use .vol <0-100> para definir o volume.",
        "en": "Use .vol <0-100> to set the volume.",
        "es": "Usa .vol <0-100> para ajustar el volumen.",
        "fr": "Utilisez .vol <0-100> pour régler le volume.",
        "ru": "Используйте .vol <0-100> для установки громкости."
    },
    "error_missing_repeat": {
        "pt": "Use .repeat <off|context|track> para definir o modo repeat.",
        "en": "Use .repeat <off|context|track> to set repeat mode.",
        "es": "Usa .repeat <off|context|track> para definir el modo de repetición.",
        "fr": "Utilisez .repeat <off|context|track> pour définir le mode de répétition.",
        "ru": "Используйте .repeat <off|context|track> для установки режима повтора."
    },
    "error_missing_code": {
        "pt": "Use .code <código> para trocar o código de autorização.",
        "en": "Use .code <code> to exchange the authorization code.",
        "es": "Usa .code <código> para intercambiar el código de autorización.",
        "fr": "Utilisez .code <code> pour échanger le code d'autorisation.",
        "ru": "Используйте .code <код> для обмена кода авторизации."
    },
    "error_missing_setid": {
        "pt": "Use .setid <client_id> para definir o Client ID.",
        "en": "Use .setid <client_id> to set the Client ID.",
        "es": "Usa .setid <client_id> para definir el Client ID.",
        "fr": "Utilisez .setid <client_id> pour définir le Client ID.",
        "ru": "Используйте .setid <client_id> для установки Client ID."
    },
    "error_missing_setsecret": {
        "pt": "Use .setsecret <client_secret> para definir o Client Secret.",
        "en": "Use .setsecret <client_secret> to set the Client Secret.",
        "es": "Usa .setsecret <client_secret> para definir el Client Secret.",
        "fr": "Utilisez .setsecret <client_secret> pour définir le Client Secret.",
        "ru": "Используйте .setsecret <client_secret> для установки Client Secret."
    },
    "bulletin_liked": {
        "pt": "Música adicionada aos favoritos!",
        "en": "Track added to favorites!",
        "es": "¡Canción añadida a favoritos!",
        "fr": "Morceau ajouté aux favoris!",
        "ru": "Трек добавлен в избранное!"
    },
    "advanced_options_title": {"pt": "Opções Avançadas", "en": "Advanced Options", "es": "Opciones Avanzadas", "fr": "Options Avancées", "ru": "Дополнительные Параметры"}, 
    "bulletin_already_liked": {
        "pt": "Esta música já está nos seus favoritos!",
        "en": "This track is already in your favorites!",
        "es": "¡Esta canción ya está en tus favoritos!",
        "fr": "Ce morceau est déjà dans vos favoris!",
        "ru": "Этот трек уже в избранном!"
    },
    "error_no_track_playing": {
        "pt": "Nenhuma música tocando no momento.",
        "en": "No track playing right now.",
        "es": "No hay música reproduciéndose ahora.",
        "fr": "Aucun morceau en cours de lecture.",
        "ru": "Сейчас ничего не играет."
    },
    "error_missing_like": {
        "pt": "Use .like <track_id> para curtir uma música.",
        "en": "Use .like <track_id> to like a track.",
        "es": "Usa .like <track_id> para marcar una canción como favorita.",
        "fr": "Utilisez .like <track_id> pour ajouter un morceau aux favoris.",
        "ru": "Используйте .like <track_id> чтобы добавить трек в избранное."
    },
    "error_missing_search": {
        "pt": "Use .search <termo> para buscar músicas, álbuns ou artistas.",
        "en": "Use .search <term> to search for tracks, albums or artists.",
        "es": "Usa .search <término> para buscar canciones, álbumes o artistas.",
        "fr": "Utilisez .search <terme> pour rechercher des morceaux, albums ou artistes.",
        "ru": "Используйте .search <запрос> для поиска треков, альбомов или исполнителей."
    },
    "dotted_credit": {"pt": "Dotted Plugins", "en": "Dotted Plugins", "es": "Dotted Plugins", "fr": "Dotted Plugins", "ru": "Dotted Plugins"},
    "lastfm_username": {
        "pt": "Usuário do LastFM",
        "en": "LastFM Username",
        "es": "Usuario de LastFM",
        "fr": "Nom d'utilisateur LastFM",
        "ru": "Имя пользователя LastFM"
    },
    "lastfm_username_sub": {
        "pt": "Seu nome de usuário do LastFM",
        "en": "Your LastFM username",
        "es": "Tu usuario de LastFM",
        "fr": "Votre nom d'utilisateur LastFM",
        "ru": "Ваше имя пользователя LastFM"
    },
    "lastfm_api_key": {
        "pt": "API Key do LastFM",
        "en": "LastFM API Key",
        "es": "Clave API de LastFM",
        "fr": "Clé API LastFM",
        "ru": "API-ключ LastFM"
    },
    "lastfm_api_key_sub": {
        "pt": "Sua API Key do LastFM (crie em last.fm/api)",
        "en": "Your LastFM API Key (create at last.fm/api)",
        "es": "Tu clave API de LastFM (crea en last.fm/api)",
        "fr": "Votre clé API LastFM (créez sur last.fm/api)",
        "ru": "Ваш API-ключ LastFM (создайте на last.fm/api)"
    },
    "lastfm_youtube_api_key": {
        "pt": "YouTube API Key",
        "en": "YouTube API Key",
        "es": "Clave API de YouTube",
        "fr": "Clé API YouTube",
        "ru": "API-ключ YouTube"
    },
    "lastfm_youtube_api_key_sub": {
        "pt": "Opcional: para buscar vídeos no YouTube",
        "en": "Optional: to search videos on YouTube",
        "es": "Opcional: para buscar videos en YouTube",
        "fr": "Optionnel : pour rechercher des vidéos sur YouTube",
        "ru": "Необязательно: для поиска видео на YouTube"
    },
    "error_lastfm_credentials": {"pt": "Credenciais do LastFM inválidas.", "en": "Invalid LastFM credentials.", "es": "Credenciales del LastFM no válidas.", "fr": "Identifiants LastFM invalides.", "ru": "Неверные учетные данные LastFM."},
    "lastfm_credentials": {"pt": "Last.FM", "en": "Last.FM", "es": "Last.FM", "fr": "Last.FM", "ru": "Last.FM"},
    "lastfm_user_subtext": {"pt": "Seu nome de usuário do Last.FM", "en": "Your Last.FM username", "es": "Tu usuario de Last.FM", "fr": "Votre nom d'utilisateur Last.FM", "ru": "Ваше имя пользователя Last.FM"},
    "lastfm_api_key_subtext": {"pt": "Chave da API do Last.FM (crie em last.fm/api)", "en": "Last.FM API Key (create at last.fm/api)", "es": "Clave API de Last.FM (crea en last.fm/api)", "fr": "Clé API Last.FM (créez sur last.fm/api)", "ru": "API-ключ Last.FM (создайте на last.fm/api)"},
    "lastfm_key_visibility": {"pt": "Exibir LastFM API Key", "en": "Show LastFM API Key", "es": "Mostrar clave API de Last.FM", "fr": "Afficher la clé API LastFM", "ru": "Показать API-ключ LastFM"},
    "lastfm_key_visibility_sub": {"pt": "Oculta/exibe o campo da API Key para proteger dados sensíveis.", "en": "Hide/show the API Key field to protect sensitive data.", "es": "Oculta/muestra el campo de la clave API para proteger datos sensibles.", "fr": "Masquer/afficher le champ de clé API pour protéger les données sensibles.", "ru": "Скрывать/показывать поле API-ключа для защиты конфиденциальных данных."},
    "youtube_api_key_subtext": {"pt": "Chave da API do YouTube (opcional)", "en": "YouTube API Key (optional)", "es": "Clave API de YouTube (opcional)", "fr": "Clé API YouTube (optionnel)", "ru": "API-ключ YouTube (необязательно)"},
    "show_lastfm_profile_subtext": {"pt": "Exibe o link do seu perfil Last.FM na legenda", "en": "Show your Last.FM profile link in the caption", "es": "Muestra el enlace de tu perfil Last.FM en la leyenda", "fr": "Affiche le lien de votre profil Last.FM dans la légende", "ru": "Показывать ссылку на профиль Last.FM в подписи"},
    "spotify_link_subtext": {"pt": "Usa o link oficial do Spotify na legenda", "en": "Use the official Spotify link in the caption", "es": "Usa el enlace oficial de Spotify en la leyenda", "fr": "Utilise le lien officiel Spotify dans la légende", "ru": "Использовать официальную ссылку Spotify в подписи"},
    "youtube_api_title": {"pt": "Configuração da API do YouTube", "en": "YouTube API Setup", "es": "Configuración de la API de YouTube", "fr": "Configuration de l'API YouTube", "ru": "Настройка API YouTube"},
    "youtube_api_guide": {"pt": "A API do YouTube é um complemento opcional que melhora a obtenção de dados mais eficientes das capas das músicas e vídeos. Para configurar, obtenha sua chave API seguindo o guia oficial.", "en": "YouTube API is an optional complement that improves obtaining more efficient data from music and video covers. To set up, get your API key by following the official guide.", "es": "La API de YouTube es un complemento opcional que mejora la obtención de datos más eficientes de las portadas de música y videos. Para configurar, obtén tu clave API siguiendo la guía oficial.", "fr": "L'API YouTube est un complément optionnel qui améliore l'obtention de données plus efficaces des pochettes de musique et vidéos. Pour configurer, obtenez votre clé API en suivant le guide officiel.", "ru": "API YouTube - это дополнительное дополнение, которое улучшает получение более эффективных данных обложек музыки и видео. Для настройки получите ключ API, следуя официальному руководству."},
    "current_player": {"pt": "Fonte da Mídia", "en": "Media Source", "es": "Fuente de Medios", "fr": "Source Média", "ru": "Источник медиа"},
    "show_lastfm_profile_link": {"pt": "Meu Last.FM", "en": "Show Last.FM Profile", "es": "Perfil Last.FM", "fr": "Profil Last.FM", "ru": "Профиль Last.FM"},
    "fm_link_selector": {"pt": "FM Link", "en": "FM Link", "es": "Enlace FM", "fr": "Lien FM", "ru": "Ссылка FM"},
    "fm_custom_link_url": {"pt": "Custom Link (URL)", "en": "Custom Link (URL)", "es": "Enlace personalizado (URL)", "fr": "Lien personnalisé (URL)", "ru": "Пользовательская ссылка (URL)"},
    "fm_custom_link_url_sub": {"pt": "Cole aqui o link personalizado do Player FM em 'Player Ativo'", "en": "Paste here the custom link for the FM Player in 'Active Player'", "es": "Pega aquí el enlace personalizado del reproductor FM en 'Reproductor Activo'", "fr": "Collez ici le lien personnalisé pour le lecteur FM dans 'Lecteur Actif'", "ru": "Вставьте здесь пользовательскую ссылку для FM-плеера в 'Активный плеер'"},
    "youtube_api_key": {"pt": "Chave da API do YouTube", "en": "YouTube API Key", "es": "Clave de API de YouTube", "fr": "Clé API YouTube", "ru": "Ключ API YouTube"},
    "lastfm_title": {"pt": "API do Last.FM", "en": "Last.FM API", "es": "API de Last.FM", "fr": "API Last.FM", "ru": "API Last.FM"},
    "customfm_use_background": {"pt": "Capa de Fundo", "en": "Cover BG", "es": "Fondo Álbum", "fr": "Fond Album", "ru": "Фон Обложки"},
    "customfm_background_color": {"pt": "Cor do Fundo (hex)", "en": "Background Color (hex)", "es": "Color de Fondo (hex)", "fr": "Couleur de fond (hex)", "ru": "Цвет фона (hex)"},
    "customfm_text_color": {"pt": "Cor do Texto (hex)", "en": "Text Color (hex)", "es": "Color del Texto (hex)", "fr": "Couleur du texte (hex)", "ru": "Цвет текста (hex)"},
    "customfm_use_background_sub": {"pt": "Usa a capa do álbum como fundo do card.", "en": "Use the album cover as the card background.", "es": "Usa la portada del álbum como fondo.", "fr": "Utilise la pochette comme fond.", "ru": "Использовать обложку как фон карточки."},
    "customfm_background_color_sub": {"pt": "Cor de fundo personalizada para o tema CustomFM.", "en": "Custom background color for CustomFM theme.", "es": "Color de fondo personalizado para CustomFM.", "fr": "Couleur de fond personnalisée pour CustomFM.", "ru": "Пользовательский цвет фона для CustomFM."},
    "customfm_text_color_sub": {"pt": "Cor do texto personalizada para o tema CustomFM.", "en": "Custom text color for CustomFM theme.", "es": "Color de texto personalizado para CustomFM.", "fr": "Couleur de texte personnalisée pour CustomFM.", "ru": "Пользовательский цвет текста для CustomFM."},
    "customfm_radius": {"pt": "Radius da Capa", "en": "Cover Radius", "es": "Radio de Portada", "fr": "Rayon de Couverture", "ru": "Радиус Обложки"},
    "customfm_radius_standard": {"pt": "Padrão", "en": "Standard", "es": "Estándar", "fr": "Standard", "ru": "Стандарт"},
    "customfm_radius_small": {"pt": "Pequeno", "en": "Small", "es": "Pequeño", "fr": "Petit", "ru": "Маленький"},
    "customfm_radius_medium": {"pt": "Médio", "en": "Medium", "es": "Medio", "fr": "Moyen", "ru": "Средний"},
    "customfm_radius_large": {"pt": "Grande", "en": "Large", "es": "Grande", "fr": "Grand", "ru": "Большой"},
    "customfm_radius_circle": {"pt": "Círculo", "en": "Circle", "es": "Círculo", "fr": "Cercle", "ru": "Круг"},


    "apple_antialiasing_quality": {"pt": "Qualidade de Suavização", "en": "Smoothing Quality", "es": "Calidad de Suavizado", "fr": "Qualité de Lissage", "ru": "Качество Сглаживания"},
    "apple_antialiasing_standard": {"pt": "Básica", "en": "Basic", "es": "Básica", "fr": "Basique", "ru": "Базовое"},
    "apple_antialiasing_smooth": {"pt": "Suave", "en": "Smooth", "es": "Suave", "fr": "Doux", "ru": "Плавное"},
    "apple_antialiasing_ultra_smooth": {"pt": "Extra Suave", "en": "Extra Smooth", "es": "Extra Suave", "fr": "Extra Doux", "ru": "Сверхплавное"},
    "apple_antialiasing_high_quality": {"pt": "Refinada", "en": "Refined", "es": "Refinada", "fr": "Raffiné", "ru": "Утонченное"},
    "apple_resize_algorithm": {"pt": "Algoritmo de Redimensionamento", "en": "Resize Algorithm", "es": "Algoritmo de Redimensionamiento", "fr": "Algorithme de Redimensionnement", "ru": "Алгоритм Изменения Размера"},
    "apple_cover_quality": {"pt": "Qualidade da Mini Capa", "en": "Mini Cover Quality", "es": "Calidad de Mini Portada", "fr": "Qualité de Mini Couverture", "ru": "Качество Мини Обложки"},
    "apple_ui_warning": {"pt": "Opções Avançadas do Apple UI", "en": "Apple UI Advanced Options", "es": "Opciones Avanzadas de Apple UI", "fr": "Options Avancées d'Apple UI", "ru": "Расширенные Опции Apple UI"},

    "apple_quality_antialiasing_section": {"pt": "Qualidade e Anti-aliasing", "en": "Quality & Anti-aliasing", "es": "Calidad y Anti-aliasing", "fr": "Qualité et Anti-aliasing", "ru": "Качество и Сглаживание"},
    "apple_visual_optimizations_section": {"pt": "Otimizações Visuais", "en": "Visual Optimizations", "es": "Optimizaciones Visuales", "fr": "Optimisations Visuelles", "ru": "Визуальные Оптимизации"},
    "apple_performance_section": {"pt": "Performance", "en": "Performance", "es": "Rendimiento", "fr": "Performance", "ru": "Производительность"},
    "customfm_overlay_url": {"pt": "URL do Overlay", "en": "Overlay URL", "es": "URL de Overlay", "fr": "URL de Superposition", "ru": "URL Наложения"},
    "customfm_overlay_url_sub": {"pt": "Link da imagem overlay personalizada. Dimensões recomendadas: 400x400px", "en": "Custom overlay image link. Recommended dimensions: 400x400px", "es": "Enlace de imagen overlay personalizada. Dimensiones recomendadas: 400x400px", "fr": "Lien d'image de superposition personnalisée. Dimensions recommandées: 400x400px", "ru": "Ссылка на пользовательское изображение наложения. Рекомендуемые размеры: 400x400px"},
    "customfm_overlay_url_enhanced_sub": {"pt": "URL direto para a imagem PNG/JPG do overlay.", "en": "Direct URL to the PNG/JPG overlay image.", "es": "URL directo a la imagen PNG/JPG del overlay.", "fr": "URL directe vers l'image PNG/JPG de superposition.", "ru": "Прямая ссылка на изображение PNG/JPG для наложения."},
    "customfm_background_section": {"pt": "Configurações de Fundo", "en": "Background Settings", "es": "Configuraciones de Fondo", "fr": "Paramètres d'Arrière-plan", "ru": "Настройки Фона"},
    "customfm_text_section": {"pt": "Configurações de Texto", "en": "Text Settings", "es": "Configuraciones de Texto", "fr": "Paramètres de Texte", "ru": "Настройки Текста"},
    "customfm_style_section": {"pt": "Estilo e Aparência", "en": "Style & Appearance", "es": "Estilo y Apariencia", "fr": "Style et Apparence", "ru": "Стиль и Внешний Вид"},
    "customfm_overlay_section": {"pt": "Overlay Personalizado", "en": "Custom Overlay", "es": "Overlay Personalizado", "fr": "Superposition Personnalisée", "ru": "Пользовательское Наложение"},
    "customfm_use_overlay": {"pt": "Usar Overlay Personalizado", "en": "Use Custom Overlay", "es": "Usar Overlay Personalizado", "fr": "Utiliser Superposition Personnalisée", "ru": "Использовать Пользовательское Наложение"},
    "customfm_use_overlay_sub": {
        "pt": "Usa uma imagem de overlay como plano de fundo em vez da capa ou cor personalizada definida pelo usuário",
        "en": "Uses an overlay image as the background instead of the track cover or a user-defined custom color",
        "es": "Usa una imagen de overlay como fondo en lugar de la portada o un color personalizado definido por el usuario",
        "fr": "Utilise une image de superposition comme arrière-plan au lieu de la pochette ou d'une couleur personnalisée définie par l'utilisateur",
        "ru": "Использует изображение наложения в качестве фона вместо обложки или пользовательского цвета, заданного пользователем"
    },
    "customfm_blur": {"pt": "Blur", "en": "Blur", "es": "Blur", "fr": "Blur", "ru": "Размытие"},
    "customfm_blur_sub": {"pt": "Aplica desfoque ao fundo. Funciona tanto no overlay quanto no fundo da capa.", "en": "Applies blur to the background. Works for both overlay and cover backgrounds.", "es": "Aplica desenfoque al fondo. Funciona tanto en el overlay como en el fondo de la portada.", "fr": "Applique un flou à l'arrière-plan. Fonctionne sur la superposition et l'arrière-plan de la couverture.", "ru": "Применяет размытие к фону. Работает как на наложении, так и на фоне обложки."},
    "customfm_darken_background": {"pt": "Escurecer fundo", "en": "Darken background", "es": "Oscurecer fondo", "fr": "Assombrir l'arrière-plan", "ru": "Затемнить фон"},
    "customfm_darken_background_sub": {"pt": "Adiciona uma camada transparente escura. Funciona no overlay e no fundo da capa.", "en": "Adds a dark transparent layer. Works on both overlay and cover backgrounds.", "es": "Añade una capa transparente oscura. Funciona en el overlay y el fondo de la portada.", "fr": "Ajoute une couche transparente sombre. Fonctionne sur la superposition et l'arrière-plan de la couverture.", "ru": "Добавляет темный прозрачный слой. Работает на наложении и фоне обложки."},
    "customfm_bold_text": {"pt": "Realce de texto", "en": "Text Emphasis", "es": "Énfasis de texto", "fr": "Emphase du texte", "ru": "Выделение текста"},
    "customfm_bold_text_sub": {"pt": "Ativa o negrito no título da música e nome do artista", "en": "Enables bold formatting for song title and artist name.", "es": "Activa el formato en negrita para el título de la canción y nombre del artista", "fr": "Active le formatage en gras pour le titre de la chanson et nom de l'artiste", "ru": "Включает жирное форматирование для названия песни и имени исполнителя"},
    "customfm_cover_position": {"pt": "Posição da mini capa", "en": "Mini cover position", "es": "Posición de la mini portada", "fr": "Position de la mini couverture", "ru": "Позиция мини обложки"},
    "customfm_cover_position_sub": {"pt": "Escolha o lado em que a mini capa será exibida", "en": "Choose the side where the mini cover will be displayed", "es": "Elige el lado donde se mostrará la mini portada", "fr": "Choisissez le côté où la mini couverture sera affichée", "ru": "Выберите сторону, где будет отображаться мини обложка"},
    "customfm_position_left": {"pt": "Esquerda", "en": "Left", "es": "Izquierda", "fr": "Gauche", "ru": "Слева"},
    "customfm_position_right": {"pt": "Direita", "en": "Right", "es": "Derecha", "fr": "Droite", "ru": "Справа"},
    "customfm_icon_colors": {"pt": "Cores dos Ícones", "en": "Icon Colors", "es": "Colores de Iconos", "fr": "Couleurs des Icônes", "ru": "Цвета Иконок"},
    "customfm_custom_icon_url": {"pt": "Ícone Personalizado (URL)", "en": "Custom Icon (URL)", "es": "Icono Personalizado (URL)", "fr": "Icône Personnalisée (URL)", "ru": "Пользовательская Иконка (URL)"},
    "customfm_custom_icon_url_sub": {"pt": "Cole aqui o link do ícone personalizado para o player FM", "en": "Paste here the custom icon link for FM player", "es": "Pega aquí el enlace del icono personalizado para el reproductor FM", "fr": "Collez ici le lien de l'icône personnalisée pour le lecteur FM", "ru": "Вставьте здесь ссылку на пользовательскую иконку для FM плеера"},
    "customfm_custom_link_url": {"pt": "Link Personalizado (URL)", "en": "Custom Link (URL)", "es": "Enlace Personalizado (URL)", "fr": "Lien Personnalisé (URL)", "ru": "Пользовательская Ссылка (URL)"},
    "customfm_custom_link_url_sub": {"pt": "Cole aqui o link personalizado para o serviço FM (ex: link do Spotify, Apple Music, etc.)", "en": "Paste here the custom link for FM service (e.g. Spotify link, Apple Music, etc.)", "es": "Pega aquí el enlace personalizado para el servicio FM (ej. enlace de Spotify, Apple Music, etc.)", "fr": "Collez ici le lien personnalisé pour le service FM (ex. lien Spotify, Apple Music, etc.)", "ru": "Вставьте здесь пользовательскую ссылку для FM сервиса (например, ссылка Spotify, Apple Music и т.д.)"},
    "customfm_custom_player_name": {
        "pt": "Player",
        "en": "Player",
        "es": "Reproductor",
        "fr": "Lecteur",
        "ru": "Плеер"
    },
    "customfm_custom_player_name_sub": {"pt": "Digite um nome personalizado para o player FM (ex: 'Meu Player', 'Custom FM')", "en": "Enter a custom name for the FM player (e.g. 'My Player', 'Custom FM')", "es": "Ingresa un nombre personalizado para el reproductor FM (ej. 'Mi Reproductor', 'Custom FM')", "fr": "Entrez un nom personnalisé pour le lecteur FM (ex. 'Mon Lecteur', 'Custom FM')", "ru": "Введите пользовательское имя для FM плеера (например, 'Мой Плеер', 'Custom FM')"},
    "customfm_high_resolution": {"pt": "Alta Resolução", "en": "High Resolution", "es": "Alta Resolución", "fr": "Haute Résolution", "ru": "Высокое Разрешение"},
    "customfm_high_resolution_sub": {"pt": "Gera imagens em 1920x1080 para melhor qualidade. A geração pode demorar alguns segundos adicionais devido ao processamento de alta resolução", "en": "Generates images in 1920x1080 for better quality. Generation may take a few additional seconds due to high resolution processing", "es": "Genera imágenes en 1920x1080 para mejor calidad. La generación puede tardar algunos segundos adicionales debido al procesamiento de alta resolución", "fr": "Génère des images en 1920x1080 pour une meilleure qualité. La génération peut prendre quelques secondes supplémentaires en raison du traitement haute résolution", "ru": "Генерирует изображения в 1920x1080 для лучшего качества. Генерация может занять несколько дополнительных секунд из-за обработки высокого разрешения"},
    "dynamic_skins_section": {"pt": "Overlay Skins", "en": "Overlay Skins", "es": "Overlay Skins", "fr": "Overlay Skins", "ru": "Overlay Skins"},
    
    "vinify_ui_section": {"pt": "Vinify UI", "en": "Vinify UI", "es": "Vinify UI", "fr": "Vinify UI", "ru": "Vinify UI"},
    "vinify_background_section": {"pt": "Configurações de Fundo", "en": "Background Settings", "es": "Configuraciones de Fondo", "fr": "Paramètres d'Arrière-plan", "ru": "Настройки фона"},
    "vinify_custom_bg": {"pt": "Custom BG", "en": "Custom BG", "es": "Fondo Personalizado", "fr": "Arrière-plan Personnalisé", "ru": "Пользовательский фон"},
    "vinify_custom_bg_sub": {"pt": "Usa uma imagem personalizada como fundo. Se vazio, usa a capa.", "en": "Use a custom image as background. If empty, uses cover.", "es": "Usa una imagen personalizada como fondo. Si está vacío, usa la portada.", "fr": "Utilise une image personnalisée comme arrière-plan. Si vide, utilise la pochette.", "ru": "Использовать пользовательское изображение как фон. Если пусто, использовать обложку."},
    "vinify_custom_bg_url": {"pt": "Custom BG (URL)", "en": "Custom BG (URL)", "es": "Fondo Personalizado (URL)", "fr": "Arrière-plan Personnalisé (URL)", "ru": "Пользовательский фон (URL)"},
    "vinify_custom_bg_url_sub": {"pt": "Cole o link da imagem 1012x512 (PNG/JPG).", "en": "Paste the 1012x512 image link (PNG/JPG).", "es": "Pega el enlace de imagen 1012x512 (PNG/JPG).", "fr": "Collez le lien d'image 1012x512 (PNG/JPG).", "ru": "Вставьте ссылку на изображение 1012x512 (PNG/JPG)."},
    "vinify_bg_styles": {"pt": "BG Styles", "en": "BG Styles", "es": "Estilos de Fondo", "fr": "Styles d'Arrière-plan", "ru": "Стили фона"},
    "vinify_bg_styles_sub": {"pt": "Substitui o fundo pela imagem escolhida.", "en": "Replaces the background with the chosen image.", "es": "Reemplaza el fondo por la imagen elegida.", "fr": "Remplace l'arrière-plan par l'image choisie.", "ru": "Заменяет фон выбранным изображением."},
    "vinify_bg_style_none": {"pt": "Nenhum", "en": "None", "es": "Ninguno", "fr": "Aucun", "ru": "Нет"},
    "vinify_bg_style_obsidian": {"pt": "Obsidian", "en": "Obsidian", "es": "Obsidian", "fr": "Obsidian", "ru": "Obsidian"},
    "vinify_bg_style_morph": {"pt": "Morph", "en": "Morph", "es": "Morph", "fr": "Morph", "ru": "Morph"},
    "vinify_bg_style_noir": {"pt": "Noir", "en": "Noir", "es": "Noir", "fr": "Noir", "ru": "Noir"},
    "vinify_bg_style_ethereal": {"pt": "Ethereal", "en": "Ethereal", "es": "Ethereal", "fr": "Ethereal", "ru": "Ethereal"},
    "vinify_bg_style_ethereal_mirage": {"pt": "Ethereal Mirage", "en": "Ethereal Mirage", "es": "Ethereal Mirage", "fr": "Ethereal Mirage", "ru": "Ethereal Mirage"},
    "vinify_bg_style_silken": {"pt": "Silken", "en": "Silken", "es": "Silken", "fr": "Silken", "ru": "Silken"},
    "vinify_bg_style_mock": {"pt": "Mock", "en": "Mock", "es": "Mock", "fr": "Mock", "ru": "Mock"},
    "vinify_bg_style_random": {"pt": "Aleatório", "en": "Random", "es": "Aleatorio", "fr": "Aléatoire", "ru": "Случайный"},
    "vinify_shadow": {"pt": "Shadow", "en": "Shadow", "es": "Sombra", "fr": "Ombre", "ru": "Тень"},
    "vinify_shadow_sub": {"pt": "Adiciona overlay transparente sobre o fundo.", "en": "Adds a transparent overlay over the background.", "es": "Añade un overlay transparente sobre el fondo.", "fr": "Ajoute une superposition transparente sur l'arrière-plan.", "ru": "Добавляет прозрачное наложение поверх фона."},
    "vinify_shadow_none": {"pt": "Nenhum", "en": "None", "es": "Ninguno", "fr": "Aucun", "ru": "Нет"},
    "vinify_shadow_black": {"pt": "Black", "en": "Black", "es": "Negro", "fr": "Noir", "ru": "Чёрный"},
    "vinify_shadow_white": {"pt": "White", "en": "White", "es": "Blanco", "fr": "Blanc", "ru": "Белый"},
    "vinify_shadow_gradient": {"pt": "Gradient", "en": "Gradient", "es": "Gradiente", "fr": "Dégradé", "ru": "Градиент"},
    "vinibar_section": {"pt": "Configurações da ViniBar", "en": "ViniBar Settings", "es": "Configuración de ViniBar", "fr": "Paramètres de ViniBar", "ru": "Настройки ViniBar"},
    "vinibar_color": {"pt": "Cor da ViniBar", "en": "ViniBar Color", "es": "Color de ViniBar", "fr": "Couleur de ViniBar", "ru": "Цвет ViniBar"},
    "vinibar_color_sub": {"pt": "Cor principal da barra de progresso", "en": "Main color of the progress bar", "es": "Color principal de la barra de progreso", "fr": "Couleur principale de la barre de progression", "ru": "Основной цвет индикатора выполнения"},
    "vinibar_bg_color": {"pt": "Cor de fundo da ViniBar", "en": "ViniBar Background Color", "es": "Color de fondo de ViniBar", "fr": "Couleur de fond de ViniBar", "ru": "Цвет фона ViniBar"},
    "vinibar_bg_color_sub": {"pt": "Cor de fundo da barra de progresso", "en": "Background color of the progress bar", "es": "Color de fondo de la barra de progreso", "fr": "Couleur de fond de la barre de progression", "ru": "Цвет фона индикатора выполнения"},
    "vinibar_gradient": {"pt": "Gradiente da ViniBar", "en": "ViniBar Gradient", "es": "Gradiente de ViniBar", "fr": "Dégradé de ViniBar", "ru": "Градиент ViniBar"},
    "vinibar_gradient_sub": {"pt": "Combina a cor selecionada com uma cor baseada na capa do álbum", "en": "Combines the selected color with a color based on the album cover", "es": "Combina el color seleccionado con un color basado en la portada del álbum", "fr": "Combine la couleur sélectionnée avec une couleur basée sur la pochette de l'album", "ru": "Сочетает выбранный цвет с цветом на основе обложки альбома"},
    "vinibar_blur": {"pt": "Efeito Vidro na ViniBar", "en": "ViniBar Glass Effect", "es": "Efecto Cristal en ViniBar", "fr": "Effet Verre ViniBar", "ru": "Стеклянный эффект ViniBar"},
    "vinibar_blur_sub": {"pt": "Aplica um efeito de vidro translúcido na barra de fundo, permitindo ver a imagem através dela", "en": "Applies a translucent glass effect to the background bar, allowing the image to show through", "es": "Aplica un efecto de vidrio translúcido en la barra de fondo, permitiendo ver la imagen a través de ella", "fr": "Applique un effet de verre translucide à la barre d'arrière-plan, permettant de voir l'image à travers", "ru": "Применяет полупрозрачный стеклянный эффект к фоновой полосе, позволяя видеть изображение сквозь неё"},
    
    # Seções do Vinify UI
    "vinibar_settings_section": {"pt": "Configurações da ViniBar", "en": "ViniBar Settings", "es": "Configuraciones de ViniBar", "fr": "Paramètres ViniBar", "ru": "Настройки ViniBar"},
    "card_info_section": {"pt": "Informações do Card", "en": "Card Information", "es": "Información de la Tarjeta", "fr": "Informations de la Carte", "ru": "Информация карточки"},
    "advanced_settings_section": {"pt": "Configurações Avançadas", "en": "Advanced Settings", "es": "Configuraciones Avanzadas", "fr": "Paramètres Avancés", "ru": "Расширенные настройки"},
    
    # Novas opções do Vinify UI
    "album_playlist_mode": {"pt": "Modo Álbum/Playlist", "en": "Album/Playlist Mode", "es": "Modo Álbum/Playlist", "fr": "Mode Album/Playlist", "ru": "Режим альбом/плейлист"},
    "album_playlist_disabled": {"pt": "Desabilitado", "en": "Disabled", "es": "Deshabilitado", "fr": "Désactivé", "ru": "Отключено"},
    "album_playlist_auto": {"pt": "Automático", "en": "Automatic", "es": "Automático", "fr": "Automatique", "ru": "Автоматический"},
    "album_playlist_album": {"pt": "Álbum", "en": "Album", "es": "Álbum", "fr": "Album", "ru": "Альбом"},
    "album_playlist_playlist": {"pt": "Playlist", "en": "Playlist", "es": "Playlist", "fr": "Playlist", "ru": "Плейлист"},
    "show_device": {"pt": "Mostrar Device", "en": "Show Device", "es": "Mostrar Dispositivo", "fr": "Afficher Appareil", "ru": "Показать устройство"},
    "show_device_sub": {"pt": "Exibe o nome do dispositivo acima da barra de progresso", "en": "Shows device name above the progress bar", "es": "Muestra el nombre del dispositivo encima de la barra de progreso", "fr": "Affiche le nom de l'appareil au-dessus de la barre de progression", "ru": "Показывает название устройства над индикатором выполнения"},
    
    # Novas opções para o seletor Device/Profile
    "device_profile_selector": {"pt": "Exibir Informações", "en": "Display Information", "es": "Mostrar Información", "fr": "Afficher les Informations", "ru": "Отображать информацию"},
    "my_profile": {"pt": "Meu Perfil", "en": "My Profile", "es": "Mi Perfil", "fr": "Mon Profil", "ru": "Мой профиль"},
    "custom_name": {"pt": "Nome Personalizado", "en": "Custom Name", "es": "Nombre Personalizado", "fr": "Nom Personnalisé", "ru": "Пользовательское имя"},
    "profile_and_device": {"pt": "Perfil & Device", "en": "Profile & Device", "es": "Perfil y Dispositivo", "fr": "Profil et Appareil", "ru": "Профиль и устройство"},
    "display_none": {"pt": "Nenhum", "en": "None", "es": "Ninguno", "fr": "Aucun", "ru": "Нет"},
    
    # Input para nome personalizado
    "custom_display_name": {"pt": "Nome Personalizado", "en": "Custom Display Name", "es": "Nombre de Visualización Personalizado", "fr": "Nom d'Affichage Personnalisé", "ru": "Пользовательское отображаемое имя"},
    "custom_display_name_sub": {"pt": "Digite o nome personalizado que será exibido acima da barra de progresso", "en": "Enter the custom name that will be displayed above the progress bar", "es": "Ingrese el nombre personalizado que se mostrará encima de la barra de progreso", "fr": "Entrez le nom personnalisé qui sera affiché au-dessus de la barre de progression", "ru": "Введите пользовательское имя, которое будет отображаться над индикатором выполнения"},
    
    # Switch para trocar lado da capa e textos
    "vinify_swap_layout": {"pt": "Trocar Layout", "en": "Swap Layout", "es": "Intercambiar Diseño", "fr": "Échanger la Mise en Page", "ru": "Поменять макет"},
    "vinify_swap_layout_sub": {"pt": "Troca o lado da capa e dos textos", "en": "Swaps the side of the cover and texts", "es": "Intercambia el lado de la portada y los textos", "fr": "Échange le côté de la couverture et des textes", "ru": "Меняет местами обложку и текст"},
    
    # Logo Position
    "logo_position": {"pt": "Logo Position", "en": "Logo Position", "es": "Posición del Logo", "fr": "Position du Logo", "ru": "Позиция логотипа"},
    "logo_position_superior": {"pt": "Superior", "en": "Top", "es": "Superior", "fr": "Supérieur", "ru": "Верх"},
    "logo_position_inferior": {"pt": "Inferior", "en": "Bottom", "es": "Inferior", "fr": "Inférieur", "ru": "Низ"},
    
    # Seletor de efeitos de fundo
    "vinify_background_effect": {"pt": "Efeito de Fundo", "en": "Background Effect", "es": "Efecto de Fondo", "fr": "Effet d'Arrière-plan", "ru": "Эффект фона"},
    "colors_effects_selector": {"pt": "Efeitos de Cores", "en": "Color Effects", "es": "Efectos de Color", "fr": "Effets de Couleur", "ru": "Цветовые эффекты"},
    "color_effect_random": {"pt": "Aleatório", "en": "Random", "es": "Aleatorio", "fr": "Aléatoire", "ru": "Случайный"},
    "color_effect_diagonal": {"pt": "Diagonal", "en": "Diagonal", "es": "Diagonal", "fr": "Diagonal", "ru": "Диагональный"},
    "color_effect_top_to_bottom": {"pt": "Top to Bottom", "en": "Top to Bottom", "es": "De arriba hacia abajo", "fr": "De haut en bas", "ru": "Сверху вниз"},
    "vinify_background_effect_sub": {"pt": "Escolha o efeito aplicado ao fundo da imagem", "en": "Choose the effect applied to the image background", "es": "Elige el efecto aplicado al fondo de la imagen", "fr": "Choisissez l'effet appliqué à l'arrière-plan de l'image", "ru": "Выберите эффект, применяемый к фону изображения"},
    
    # Opções do seletor de efeito de fundo
    "background_effect_none": {"pt": "Nenhum", "en": "None", "es": "Ninguno", "fr": "Aucun", "ru": "Нет"},
    "background_effect_album_colors": {"pt": "Cores do Álbum", "en": "Album Colors", "es": "Colores del Álbum", "fr": "Couleurs de l'Album", "ru": "Цвета альбома"},
    "background_effect_blur": {"pt": "Blur", "en": "Blur", "es": "Desenfoque", "fr": "Flou", "ru": "Размытие"},

    # Versão / Atualizações
    "version_status_section": {"pt": "Status da Versão", "en": "Version Status", "es": "Estado de Versión", "fr": "Statut de Version", "ru": "Статус версии"},
    "installed_version_label": {"pt": "Versão instalada", "en": "Installed version", "es": "Versión instalada", "fr": "Version installée", "ru": "Установленная версия"},
    "latest_version_label": {"pt": "Última versão", "en": "Latest version", "es": "Última versión", "fr": "Dernière version", "ru": "Последняя версия"},
    "version_status_up_to_date": {"pt": "Atualizado", "en": "Up to date", "es": "Actualizado", "fr": "À jour", "ru": "Актуально"},
    "version_status_outdated": {"pt": "Atualização disponível", "en": "Update available", "es": "Actualización disponible", "fr": "Mise à jour disponible", "ru": "Доступно обновление"},
    "version_status_unknown": {"pt": "Desconhecido", "en": "Unknown", "es": "Desconocido", "fr": "Inconnu", "ru": "Неизвестно"},
    "update_available_text": {"pt": "Nova versão {version} disponível", "en": "New version {version} available", "es": "Nueva versión {version} disponible", "fr": "Nouvelle version {version} disponible", "ru": "Доступна новая версия {version}"},
    "open_update_page": {"pt": "Abrir página de atualização", "en": "Open update page", "es": "Abrir página de actualización", "fr": "Ouvrir la page de mise à jour", "ru": "Открыть страницу обновления"},
    "check_version_now": {"pt": "Verificar versão agora", "en": "Check version now", "es": "Verificar versión ahora", "fr": "Vérifier la version maintenant", "ru": "Проверить версию сейчас"},
    "version_check_failed": {"pt": "Falha ao verificar versão", "en": "Version check failed", "es": "Fallo al verificar versión", "fr": "Échec de la vérification de version", "ru": "Сбой проверки версии"},
    "background_effect_darker": {"pt": "Escuro", "en": "Darker", "es": "Más Oscuro", "fr": "Plus Sombre", "ru": "Темнее"},
    "background_effect_both": {"pt": "Blur + Escuro", "en": "Blur + Dark", "es": "Desenfoque + Oscuro", "fr": "Flou + Sombre", "ru": "Размытие + Темный"},
    
    # Platform Logo Selector
    "vinify_platform_logo": {"pt": "Platform Logo", "en": "Platform Logo", "es": "Platform Logo", "fr": "Platform Logo", "ru": "Platform Logo"},
    "platform_logo_none": {"pt": "Nenhum", "en": "None", "es": "Ninguno", "fr": "Aucun", "ru": "Нет"},
    "platform_logo_default": {"pt": "Default", "en": "Default", "es": "Default", "fr": "Default", "ru": "Default"},
            "platform_logo_spotify_green_white": {"pt": "Green & White", "en": "Green & White", "es": "Green & White", "fr": "Green & White", "ru": "Green & White"},
    "platform_logo_spotify_white_green": {"pt": "White & Green", "en": "White & Green", "es": "White & Green", "fr": "White & Green", "ru": "White & Green"},
    "platform_logo_spotify_black_white": {"pt": "Black & White", "en": "Black & White", "es": "Black & White", "fr": "Black & White", "ru": "Black & White"},
    "platform_logo_spotify_white_black": {"pt": "White & Black", "en": "White & Black", "es": "White & Black", "fr": "White & Black", "ru": "White & Black"},
    "platform_logo_apple_red_white": {"pt": "Red & White", "en": "Red & White", "es": "Red & White", "fr": "Red & White", "ru": "Red & White"},
    "platform_logo_apple_white_red": {"pt": "White & Red", "en": "White & Red", "es": "White & Red", "fr": "White & Red", "ru": "White & Red"},
    "platform_logo_apple_black_white": {"pt": "Black & White", "en": "Black & White", "es": "Black & White", "fr": "Black & White", "ru": "Black & White"},
    "platform_logo_apple_white_black": {"pt": "White & Black", "en": "White & Black", "es": "White & Black", "fr": "White & Black", "ru": "White & Black"},
    
    # Inversão de imagem de fundo
    "vinify_flip_background": {"pt": "Inverter Imagem de Fundo", "en": "Flip Background Image", "es": "Voltear Imagen de Fondo", "fr": "Retourner l'Image de Fond", "ru": "Отразить фоновое изображение"},
    "vinify_flip_background_sub": {"pt": "Inverte horizontalmente a imagem de fundo da capa", "en": "Horizontally flips the cover background image", "es": "Voltea horizontalmente la imagen de fondo de la portada", "fr": "Retourne horizontalement l'image de fond de la couverture", "ru": "Горизонтально отражает фоновое изображение обложки"},
    
    # Platform Links
    "platform_links": {"pt": "Platform Links", "en": "Platform Links", "es": "Platform Links", "fr": "Platform Links", "ru": "Platform Links"},
    "platform_links_sub": {"pt": "Escolha quais links de plataforma incluir", "en": "Choose which platform links to include", "es": "Elige qué enlaces de plataforma incluir", "fr": "Choisissez quels liens de plateforme inclure", "ru": "Выберите, какие ссылки платформы включить"},
    "platform_links_spotify": {"pt": "Spotify", "en": "Spotify", "es": "Spotify", "fr": "Spotify", "ru": "Spotify"},
    "platform_links_universal": {"pt": "Universal", "en": "Universal", "es": "Universal", "fr": "Universal", "ru": "Universal"},
    "platform_links_both": {"pt": "Both", "en": "Both", "es": "Ambos", "fr": "Les deux", "ru": "Оба"},
    
    # FM Links section
    "fm_links_section": {"pt": "FM Links", "en": "FM Links", "es": "FM Links", "fr": "FM Links", "ru": "FM Links"},
    "fm_links_spotify_profile": {"pt": "Perfil Spotify", "en": "Spotify Profile", "es": "Perfil de Spotify", "fr": "Profil Spotify", "ru": "Профиль Spotify"},
    "fm_links_spotify_profile_sub": {"pt": "Inclui link para o perfil do usuário no Spotify", "en": "Include link to user's Spotify profile", "es": "Incluye enlace al perfil del usuario en Spotify", "fr": "Inclut un lien vers le profil utilisateur Spotify", "ru": "Включает ссылку на профиль пользователя в Spotify"},
    
    # Dialog explicativo
    "universal_link_dialog_title": {"pt": "O que é Universal Link?", "en": "What is Universal Link?", "es": "¿Qué es Universal Link?", "fr": "Qu'est-ce qu'un lien universel?", "ru": "Что такое универсальная ссылка?"},
    "universal_link_dialog_content": {"pt": "O Universal Link (song.link) é um serviço que cria links universais para músicas, permitindo que os usuários abram a música em sua plataforma de streaming preferida (Spotify, Apple Music, YouTube Music, etc.), independentemente da plataforma original.", "en": "Universal Link (song.link) is a service that creates universal links for songs, allowing users to open the song in their preferred streaming platform (Spotify, Apple Music, YouTube Music, etc.), regardless of the original platform.", "es": "Universal Link (song.link) es un servicio que crea enlaces universales para canciones, permitiendo a los usuarios abrir la canción en su plataforma de streaming preferida (Spotify, Apple Music, YouTube Music, etc.), independientemente de la plataforma original.", "fr": "Universal Link (song.link) est un service qui crée des liens universels pour les chansons, permettant aux utilisateurs d'ouvrir la chanson dans leur plateforme de streaming préférée (Spotify, Apple Music, YouTube Music, etc.), quelle que soit la plateforme d'origine.", "ru": "Universal Link (song.link) - это сервис, который создает универсальные ссылки на песни, позволяя пользователям открывать песню на их предпочитаемой стриминговой платформе (Spotify, Apple Music, YouTube Music и т.д.), независимо от исходной платформы."},
    
    # Dialog do Yandex Music
    "yandex_music_dialog_title": {"pt": "Yandex Music Selecionado", "en": "Yandex Music Selected", "es": "Yandex Music Seleccionado", "fr": "Yandex Music Sélectionné", "ru": "Yandex Music Выбран"},
    "yandex_music_dialog_content": {"pt": "Como não existe API oficial do Yandex Music, recomendamos usar o Last.FM para scrobble e track de suas músicas.\n\nE sim, essa mensagem sempre será exibida toda vez se por algum motivo você ficar trocando de player e voltando para o Yandex Music.", "en": "Since there is no official Yandex Music API, we recommend using Last.FM to scrobble and track your music.\n\nAnd yes, this message will always be displayed every time if for some reason you keep switching players and returning to Yandex Music.", "es": "Como no existe una API oficial de Yandex Music, recomendamos usar Last.FM para hacer scrobble y rastrear tu música.\n\nY sí, este mensaje siempre se mostrará cada vez si por alguna razón sigues cambiando de reproductor y volviendo a Yandex Music.", "fr": "Comme il n'existe pas d'API officielle Yandex Music, nous recommandons d'utiliser Last.FM pour scrobbler et suivre votre musique.\n\nEt oui, ce message sera toujours affiché à chaque fois si pour une raison quelconque vous continuez à changer de lecteur et à revenir à Yandex Music.", "ru": "Поскольку официального API Yandex Music не существует, мы рекомендуем использовать Last.FM для скробблинга и отслеживания вашей музыки.\n\nИ да, это сообщение всегда будет отображаться каждый раз, если по какой-то причине вы продолжаете переключать плееры и возвращаться к Yandex Music."},
    
    # Traduções do tema Nowv
    "nowv_theme_style": {"pt": "Estilo do Tema", "en": "Theme Style", "es": "Estilo del Tema", "fr": "Style du Thème", "ru": "Стиль темы"},
    "nowv_visual_appearance": {"pt": "Aparência Visual", "en": "Visual Appearance", "es": "Apariencia Visual", "fr": "Apparence Visuelle", "ru": "Внешний вид"},
    "nowv_progress_bar": {"pt": "Barra de Progresso", "en": "Progress Bar", "es": "Barra de Progreso", "fr": "Barre de Progression", "ru": "Полоса прогресса"},
    
    # Seletor de dispositivo para Stats.fm
    "statsfm_device_selector": {"pt": "Ícone do Dispositivo (Stats.fm)", "en": "Device Icon (Stats.fm)", "es": "Ícono del Dispositivo (Stats.fm)", "fr": "Icône de l'Appareil (Stats.fm)", "ru": "Значок устройства (Stats.fm)"},
    "device_auto": {"pt": "Automático", "en": "Automatic", "es": "Automático", "fr": "Automatique", "ru": "Автоматический"},
    "device_smartphone": {"pt": "Smartphone", "en": "Smartphone", "es": "Smartphone", "fr": "Smartphone", "ru": "Смартфон"},
    "device_computer": {"pt": "PC", "en": "PC", "es": "PC", "fr": "PC", "ru": "PC"},
    "device_speaker": {"pt": "Alto-falante", "en": "Speaker", "es": "Altavoz", "fr": "Haut-parleur", "ru": "Динамик"},
    "device_tv": {"pt": "TV", "en": "TV", "es": "TV", "fr": "TV", "ru": "ТВ"},
    "device_web": {"pt": "Navegador Web", "en": "Web Browser", "es": "Navegador Web", "fr": "Navigateur Web", "ru": "Веб-браузер"},
    "device_name": {"pt": "Nome do Dispositivo", "en": "Device Name", "es": "Nombre del Dispositivo", "fr": "Nom de l'Appareil", "ru": "Имя устройства"},
    "device_name_sub": {"pt": "Nome personalizado que aparecerá no card em vez do nome detectado automaticamente", "en": "Custom name that will appear on the card instead of the automatically detected name", "es": "Nombre personalizado que aparecerá en la tarjeta en lugar del nombre detectado automáticamente", "fr": "Nom personnalisé qui apparaîtra sur la carte au lieu du nom détecté automatiquement", "ru": "Пользовательское имя, которое будет отображаться на карточке вместо автоматически определенного имени"},
    
    # Traduções de cores
    "color_default": {"pt": "Padrão", "en": "Default", "es": "Predeterminado", "fr": "Par défaut", "de": "Standard", "it": "Predefinito", "ru": "По умолчанию", "zh": "默认", "ja": "デフォルト", "ko": "기본값"},
    "color_white": {"pt": "Branco", "en": "White", "es": "Blanco", "fr": "Blanc", "de": "Weiß", "it": "Bianco", "ru": "Белый", "zh": "白色", "ja": "白", "ko": "흰색"},
    "color_red": {"pt": "Vermelho", "en": "Red", "es": "Rojo", "fr": "Rouge", "de": "Rot", "it": "Rosso", "ru": "Красный", "zh": "红色", "ja": "赤", "ko": "빨간색"},
    "color_orange": {"pt": "Laranja", "en": "Orange", "es": "Naranja", "fr": "Orange", "de": "Orange", "it": "Arancione", "ru": "Оранжевый", "zh": "橙色", "ja": "オレンジ", "ko": "주황색"},
    "color_yellow": {"pt": "Amarelo", "en": "Yellow", "es": "Amarillo", "fr": "Jaune", "de": "Gelb", "it": "Giallo", "ru": "Желтый", "zh": "黄色", "ja": "黄色", "ko": "노란색"},
    "color_green": {"pt": "Verde", "en": "Green", "es": "Verde", "fr": "Vert", "de": "Grün", "it": "Verde", "ru": "Зеленый", "zh": "绿色", "ja": "緑", "ko": "초록색"},
    "color_blue": {"pt": "Azul", "en": "Blue", "es": "Azul", "fr": "Bleu", "de": "Blau", "it": "Blu", "ru": "Синий", "zh": "蓝色", "ja": "青", "ko": "파란색"},
    "color_indigo": {"pt": "Índigo", "en": "Indigo", "es": "Índigo", "fr": "Indigo", "de": "Indigo", "it": "Indaco", "ru": "Индиго", "zh": "靛蓝", "ja": "インディゴ", "ko": "남색"},
    "color_violet": {"pt": "Violeta", "en": "Violet", "es": "Violeta", "fr": "Violet", "de": "Violett", "it": "Viola", "ru": "Фиолетовый", "zh": "紫色", "ja": "紫", "ko": "보라색"},
    "dynamic_skins_selector": {"pt": "Overlay Skins", "en": "Overlay Skins", "es": "Overlay Skins", "fr": "Overlay Skins", "ru": "Overlay Skins"},
    "dynamic_skins_sub": {"pt": "Selecione um pré-overlay com temas prontos para o CustomFM", "en": "Select a pre-overlay with ready themes for CustomFM", "es": "Selecciona un pre-overlay con temas listos para CustomFM", "fr": "Sélectionnez un pré-overlay avec des thèmes prêts pour CustomFM", "ru": "Выберите пре-оверлей с готовыми темами для CustomFM"},
    "dynamic_skins_none": {"pt": "Nenhum", "en": "None", "es": "Ninguno", "fr": "Aucun", "ru": "Нет"},
    "dynamic_skins_random": {"pt": "Aleatório", "en": "Random", "es": "Aleatorio", "fr": "Aléatoire", "ru": "Случайный"},
    "dynamic_skins_spcy": {"pt": "Spcy", "en": "Spcy", "es": "Spcy", "fr": "Spcy", "ru": "Spcy"},
    "dynamic_skins_purpl": {"pt": "Purpl", "en": "Purpl", "es": "Purpl", "fr": "Purpl", "ru": "Purpl"},
    "dynamic_skins_ardente": {"pt": "Ardente", "en": "Ardente", "es": "Ardente", "fr": "Ardente", "ru": "Ardente"},
    "dynamic_skins_manifest": {"pt": "Manifest", "en": "Manifest", "es": "Manifest", "fr": "Manifest", "ru": "Manifest"},
    "dynamic_skins_moment": {"pt": "Moment", "en": "Moment", "es": "Moment", "fr": "Moment", "ru": "Moment"},
    "dynamic_skins_moment_redd": {"pt": "Moment Redd", "en": "Moment Redd", "es": "Moment Redd", "fr": "Moment Redd", "ru": "Moment Redd"},
    "dynamic_skins_moment_variant": {"pt": "Moment Variant", "en": "Moment Variant", "es": "Moment Variant", "fr": "Moment Variant", "ru": "Moment Variant"},
    # Visual Avançado - Traduções
    "visual_avancado_section": {"pt": "Visual Avançado", "en": "Advanced Visual", "es": "Visual Avanzado", "fr": "Visuel Avancé", "ru": "Продвинутый визуал"},
    "gradientes_dinamicos_section": {"pt": "Gradientes Dinâmicos", "en": "Dynamic Gradients", "es": "Gradientes Dinámicos", "fr": "Dégradés Dynamiques", "ru": "Динамические градиенты"},
    "gradiente_enable": {"pt": "Ativar Gradientes", "en": "Enable Gradients", "es": "Activar Gradientes", "fr": "Activer les Dégradés", "ru": "Включить градиенты"},
    "gradiente_enable_sub": {"pt": "Aplica gradientes dinâmicos baseados nas cores da capa do álbum", "en": "Applies dynamic gradients based on album cover colors", "es": "Aplica gradientes dinámicos basados en los colores de la portada del álbum", "fr": "Applique des dégradés dynamiques basés sur les couleurs de la pochette", "ru": "Применяет динамические градиенты на основе цветов обложки альбома"},
    "gradiente_style": {"pt": "Estilo do Gradiente", "en": "Gradient Style", "es": "Estilo del Gradiente", "fr": "Style de Dégradé", "ru": "Стиль градиента"},
    "gradiente_linear": {"pt": "Linear", "en": "Linear", "es": "Lineal", "fr": "Linéaire", "ru": "Линейный"},
    "gradiente_radial": {"pt": "Radial", "en": "Radial", "es": "Radial", "fr": "Radial", "ru": "Радиальный"},
    "gradiente_diagonal": {"pt": "Diagonal", "en": "Diagonal", "es": "Diagonal", "fr": "Diagonal", "ru": "Диагональный"},
    "gradiente_direction": {"pt": "Direção do Gradiente", "en": "Gradient Direction", "es": "Dirección del Gradiente", "fr": "Direction du Dégradé", "ru": "Направление градиента"},
    "gradiente_top_bottom": {"pt": "Cima para Baixo", "en": "Top to Bottom", "es": "Arriba a Abajo", "fr": "Haut vers Bas", "ru": "Сверху вниз"},
    "gradiente_left_right": {"pt": "Esquerda para Direita", "en": "Left to Right", "es": "Izquierda a Derecha", "fr": "Gauche vers Droite", "ru": "Слева направо"},
    "gradiente_diagonal_tl_br": {"pt": "Diagonal (↘)", "en": "Diagonal (↘)", "es": "Diagonal (↘)", "fr": "Diagonal (↘)", "ru": "Диагональ (↘)"},
    "gradiente_diagonal_tr_bl": {"pt": "Diagonal (↙)", "en": "Diagonal (↙)", "es": "Diagonal (↙)", "fr": "Diagonal (↙)", "ru": "Диагональ (↙)"},
    "gradiente_intensity": {"pt": "Intensidade do Gradiente", "en": "Gradient Intensity", "es": "Intensidad del Gradiente", "fr": "Intensité du Dégradé", "ru": "Интенсивность градиента"},
    "gradiente_suave": {"pt": "Suave", "en": "Soft", "es": "Suave", "fr": "Doux", "ru": "Мягкий"},
    "gradiente_medio": {"pt": "Médio", "en": "Medium", "es": "Medio", "fr": "Moyen", "ru": "Средний"},
    "gradiente_intenso": {"pt": "Intenso", "en": "Intense", "es": "Intenso", "fr": "Intense", "ru": "Интенсивный"},
    "gradiente_color_extraction": {"pt": "Extração de Cores", "en": "Color Extraction", "es": "Extracción de Colores", "fr": "Extraction de Couleurs", "ru": "Извлечение цветов"},
    "gradiente_dominante": {"pt": "Cor Dominante", "en": "Dominant Color", "es": "Color Dominante", "fr": "Couleur Dominante", "ru": "Доминирующий цвет"},
    "gradiente_complementar": {"pt": "Cores Complementares", "en": "Complementary Colors", "es": "Colores Complementarios", "fr": "Couleurs Complémentaires", "ru": "Дополнительные цвета"},
    "gradiente_analogas": {"pt": "Cores Análogas", "en": "Analogous Colors", "es": "Colores Análogos", "fr": "Couleurs Analogues", "ru": "Аналогичные цвета"},
    "cores_personalizadas_section": {"pt": "Cores Personalizadas", "en": "Custom Colors", "es": "Colores Personalizados", "fr": "Couleurs Personnalisées", "ru": "Пользовательские цвета"},
    "gradiente_cor1": {"pt": "Cor Primária", "en": "Primary Color", "es": "Color Primario", "fr": "Couleur Primaire", "ru": "Основной цвет"},
    "gradiente_cor2": {"pt": "Cor Secundária", "en": "Secondary Color", "es": "Color Secundario", "fr": "Couleur Secondaire", "ru": "Вторичный цвет"},
    "gradiente_modo": {"pt": "Modo do Gradiente", "en": "Gradient Mode", "es": "Modo del Gradiente", "fr": "Mode Dégradé", "ru": "Режим градиента"},
    "gradiente_modo_auto": {"pt": "Automático", "en": "Automatic", "es": "Automático", "fr": "Automatique", "ru": "Автоматический"},
    "gradiente_modo_custom": {"pt": "Personalizado", "en": "Custom", "es": "Personalizado", "fr": "Personnalisé", "ru": "Пользовательский"},
    "read_docs_theme": { 
        "en": "Use these default values unless you want to customize:\n- Background: #d2d2d2\n- Text: #000000\n\n• coolors.co/generate",
        "pt": "Use estes valores padrão a menos que queira personalizar:\n- Fundo: #d2d2d2\n- Texto: #000000\n\n• coolors.co/generate",
        "es": "Usa estos valores predeterminados, a menos que desees personalizar:\n- Fondo: #d2d2d2\n- Texto: #000000\n\n• coolors.co/generate",
        "ru": "Используйте эти значения по умолчанию, если не хотите настраивать:\n- Фон: #d2d2d2\n- Текст: #000000\n\n• coolors.co/generate",
        "fr": "Utilisez ces valeurs par défaut sauf si vous souhaitez personnaliser:\n- Fond : #d2d2d2\n- Texte : #000000\n\n• coolors.co/generate"
    },
    "read_docs_warning": {
        "pt": "É importante que leia toda a documentação, guia, FAQ para não restar dúvidas.\n\nSe precisar, releia, está tudo muito bem explicado.\nO uso do Last.FM no nowFy é simples e para tudo funcionar corretamente, basta seguir as instruções.\n\nTambém criamos uma FAQ no canal: @nowfyDOCS\n\nSe tiver realmente dúvidas, algo que não esteja nas docs, guias, aí sim, pode entrar em contato, vamos tentar ajudar.",
        "en": "It's important to read all the documentation, guides, and FAQ to clear any doubts.\n\nIf needed, read them again; everything is well explained.\nUsing Last.FM on nowFy is simple and to make it work correctly, just follow the instructions.\n\nWe also created a FAQ channel: @nowfyDOCS\n\nIf you still have real doubts not covered in the docs or guides, then feel free to contact us; we'll try to help.",
        "es": "Es importante leer toda la documentación, guías y FAQ para no tener dudas.\n\nSi es necesario, léelas de nuevo; todo está bien explicado.\nUsar Last.FM en nowFy es sencillo y para que funcione correctamente, solo sigue las instrucciones.\n\nTambién creamos un canal FAQ: @nowfyDOCS\n\nSi realmente tienes dudas que no estén en las docs o guías, entonces contáctanos; intentaremos ayudarte.",
        "fr": "Il est important de lire toute la documentation, les guides et la FAQ pour ne pas avoir de doutes.\n\nSi besoin, relisez-les ; tout est bien expliqué.\nL'utilisation de Last.FM sur nowFy est simple, il suffit de suivre les instructions pour que cela fonctionne correctement.\n\nNous avons aussi créé un canal FAQ : @nowfyDOCS\n\nSi vous avez encore de réels doutes qui ne sont pas couverts par les docs ou guides, alors contactez-nous ; nous essaierons de vous aider.",
        "ru": "Важно прочитать всю документацию, руководства и FAQ, чтобы не оставалось вопросов.\n\nЕсли нужно, перечитайте их снова; всё хорошо объяснено.\nИспользование Last.FM в nowFy простое, чтобы всё работало правильно, просто следуйте инструкциям.\nМы также создали канал FAQ: @nowfyDOCS\n\nЕсли у вас всё ещё есть вопросы, не описанные в документации или руководствах, свяжитесь с нами; мы постараемся помочь."
    },
    "nowcast_info_warning_title": {
        "pt": "Sobre o NowCast",
        "en": "About NowCast",
        "es": "Sobre NowCast",
        "fr": "À propos de NowCast",
        "ru": "О NowCast"
    },
    "nowcast_info_warning": {
        "pt": "INFORMAÇÕES IMPORTANTES SOBRE O NOWCAST\n\nNowCast é exclusivo para Spotify com API configurada. Não funciona com Last.fm ou Stats.fm.\n\nRATE LIMITING DO BOT:\n• Os bots do Telegram têm limites de requisições por segundo\n• Limite padrão: 30 mensagens por segundo\n• Para grupos: 20 mensagens por minuto\n• Estes limites são impostos pelo Telegram, não controlamos\n\nCOMO OBTER O TOKEN DO BOT:\n1. Acesse @BotFather no Telegram\n2. Digite /newbot e siga as instruções\n3. Escolha um nome e username para seu bot\n4. Copie o token fornecido\n5. Cole o token no campo 'Bot Token' acima\n\nIMPORTANTE: Mantenha seu token seguro e não compartilhe com terceiros.",
        "en": "IMPORTANT INFORMATION ABOUT NOWCAST\n\nNowCast is exclusive for Spotify with configured API. It doesn't work with Last.fm or Stats.fm.\n\nBOT RATE LIMITING:\n• Telegram bots have request limits per second\n• Default limit: 30 messages per second\n• For groups: 20 messages per minute\n• These limits are imposed by Telegram, we don't control them\n\nHOW TO GET BOT TOKEN:\n1. Go to @BotFather on Telegram\n2. Type /newbot and follow instructions\n3. Choose a name and username for your bot\n4. Copy the provided token\n5. Paste the token in the 'Bot Token' field above\n\nIMPORTANT: Keep your token secure and don't share with third parties.",
        "es": "INFORMACIÓN IMPORTANTE SOBRE NOWCAST\n\nNowCast es exclusivo para Spotify con API configurada. No funciona con Last.fm o Stats.fm.\n\nLIMITACIÓN DE VELOCIDAD DEL BOT:\n• Los bots de Telegram tienen límites de solicitudes por segundo\n• Límite predeterminado: 30 mensajes por segundo\n• Para grupos: 20 mensajes por minuto\n• Estos límites son impuestos por Telegram, no los controlamos\n\nCÓMO OBTENER EL TOKEN DEL BOT:\n1. Ve a @BotFather en Telegram\n2. Escribe /newbot y sigue las instrucciones\n3. Elige un nombre y nombre de usuario para tu bot\n4. Copia el token proporcionado\n5. Pega el token en el campo 'Bot Token' arriba\n\nIMPORTANTE: Mantén tu token seguro y no lo compartas con terceros.",
        "fr": "INFORMATIONS IMPORTANTES SUR NOWCAST\n\nNowCast est exclusif pour Spotify avec API configurée. Il ne fonctionne pas avec Last.fm ou Stats.fm.\n\nLIMITATION DE DÉBIT DU BOT:\n• Les bots Telegram ont des limites de requêtes par seconde\n• Limite par défaut: 30 messages par seconde\n• Pour les groupes: 20 messages par minute\n• Ces limites sont imposées par Telegram, nous ne les contrôlons pas\n\nCOMMENT OBTENIR LE TOKEN DU BOT:\n1. Allez sur @BotFather sur Telegram\n2. Tapez /newbot et suivez les instructions\n3. Choisissez un nom et nom d'utilisateur pour votre bot\n4. Copiez le token fourni\n5. Collez le token dans le champ 'Bot Token' ci-dessus\n\nIMPORTANT: Gardez votre token sécurisé et ne le partagez pas avec des tiers.",
        "ru": "ВАЖНАЯ ИНФОРМАЦИЯ О NOWCAST\n\nNowCast работает только со Spotify с настроенным API. Не работает с Last.fm или Stats.fm.\n\nОГРАНИЧЕНИЯ СКОРОСТИ БОТА:\n• У ботов Telegram есть лимиты запросов в секунду\n• Стандартный лимит: 30 сообщений в секунду\n• Для групп: 20 сообщений в минуту\n• Эти лимиты устанавливает Telegram, мы их не контролируем\n\nКАК ПОЛУЧИТЬ ТОКЕН БОТА:\n1. Перейдите к @BotFather в Telegram\n2. Введите /newbot и следуйте инструкциям\n3. Выберите имя и имя пользователя для вашего бота\n4. Скопируйте предоставленный токен\n5. Вставьте токен в поле 'Bot Token' выше\n\nВАЖНО: Держите ваш токен в безопасности и не делитесь им с третьими лицами."
    },
    "artwork_priority": {
        "pt": "Prioridade de Capa",
        "en": "Artwork Priority",
        "es": "Prioridad de Portada",
        "ru": "Приоритет обложки",
        "fr": "Priorité de la pochette"
    },
    "get_api_key": {
        "en": "Get your API key",
        "pt": "Obtenha sua chave de API",
        "es": "Obtén tu clave de API",
        "ru": "Получите ваш ключ API",
        "fr": "Obtenez votre clé API"
    },
    "youtube_api_guide": {
        "en": "You need a YouTube API key to use this feature. Tap the button below to open a step-by-step guide on how to generate your key.",
        "pt": "Você precisa de uma chave de API do YouTube para usar este recurso. Toque no botão abaixo para abrir um guia passo a passo sobre como gerar sua chave.",
        "es": "Necesitas una clave de API de YouTube para usar esta función. Pulsa el botón de abajo para abrir una guía paso a paso sobre cómo generar tu clave.",
        "ru": "Для использования этой функции необходим ключ API YouTube. Нажмите кнопку ниже, чтобы открыть пошаговое руководство по созданию ключа.",
        "fr": "Vous avez besoin d'une clé API YouTube pour utiliser cette fonctionnalité. Appuyez sur le bouton ci-dessous pour ouvrir un guide étape par étape sur la génération de votre clé."
    },
    "lastfm_content": {
        "en": "You can use Last.fm to scrobble from services like YouTube, YouTube Music, SoundCloud, exteraGram, and AyuGram (make sure you're using a tracking app). If you only want to use Spotify, just enter your Stats.fm username — but note that it only supports players available on Stats.fm.",
        "pt": "Você pode usar o Last.fm para scrobble em serviços como YouTube, YouTube Music, SoundCloud, exteraGram e AyuGram (certifique-se de usar algum app de tracking). Se quiser usar apenas o Spotify, basta inserir seu nome de usuário do Stats.fm — mas saiba que ele só oferece suporte aos players compatíveis com o Stats.fm.",
        "es": "Puedes usar Last.fm para hacer scrobble desde servicios como YouTube, YouTube Music, SoundCloud, exteraGram y AyuGram (asegúrate de usar una app de tracking). Si solo quieres usar Spotify, solo ingresa tu nombre de usuario de Stats.fm, pero ten en cuenta que solo admite los reproductores compatibles con Stats.fm.",
        "ru": "Вы можете использовать Last.fm для скробблинга с YouTube, YouTube Music, SoundCloud, exteraGram и AyuGram (убедитесь, что используете приложение для трекинга). Если хотите использовать только Spotify, введите имя пользователя Stats.fm — но учтите, что он поддерживает только плееры, совместимые со Stats.fm.",
        "fr": "Vous pouvez utiliser Last.fm pour scrobbler depuis des services comme YouTube, YouTube Music, SoundCloud, exteraGram et AyuGram (assurez-vous d'utiliser une application de suivi). Si vous souhaitez uniquement utiliser Spotify, entrez simplement votre nom d'utilisateur Stats.fm — mais sachez qu'il ne prend en charge que les lecteurs pris en charge par Stats.fm."
    },
    "lastfm_get_api_key": {
        "en": "Get key",
        "pt": "Obter chave",
        "es": "Obtener clave",
        "ru": "Получить ключ",
        "fr": "Obtenir clé"
    },
    "artwork_priority_title": {"pt": "Prioridade de Capa", "en": "Artwork Priority", "es": "Prioridad de Portada", "ru": "Приоритет обложки", "fr": "Priorité de la pochette"},
    "error_generic": {"pt": "Erro: {error}", "en": "Error: {error}", "es": "Error: {error}", "fr": "Erreur: {error}", "ru": "Ошибка: {error}"},
    "error_lastfm": {"pt": "Erro do LastFM: {error}", "en": "LastFM error: {error}", "es": "Error de LastFM: {error}", "fr": "Erreur LastFM: {error}", "ru": "Ошибка LastFM: {error}"},
    "artwork_priority_subtext": {"pt": "Escolha a prioridade de capa preferida", "en": "Choose your preferred artwork priority", "es": "Elige tu prioridad de portada preferida", "ru": "Выберите предпочтительный приоритет обложки", "fr": "Choisissez votre priorité de pochette préférée"},
    "lastfm_credentials_header": {
        "pt": "Credenciais e APIs",
        "en": "Credentials & APIs",
        "ru": "Данные и API",
        "es": "Credenciales y APIs",
        "fr": "Identifiants et APIs"
    },
    "lastfm_personalization_header": {
        "pt": "Personalização do Last.FM",
        "en": "Last.FM Personalization",
        "ru": "Персонализация Last.FM",
        "es": "Personalización de Last.FM",
        "fr": "Personnalisation Last.FM"
    },
    "lastfm_integration_header": {
        "pt": "Integração e Fonte de Mídia",
        "en": "Integration & Media Source",
        "ru": "Интеграция и источник медиа",
        "es": "Integración y Fuente de Medios",
        "fr": "Intégration et Source Média"
    },
    "exteragram_username_subtext": {
        "pt": "Insira o username de um perfil, canal ou grupo para linkar no card. Exemplo: exteradevplugins (irá abrir t.me/exteradevplugins)",
        "en": "Enter the username of a profile, channel or group to link in the card. Example: exteradevplugins (will open t.me/exteradevplugins)",
        "ru": "Введите username профиля, канала или группы для ссылки на карточке. Пример: exteradevplugins (откроет t.me/exteradevplugins)",
        "es": "Ingrese el nombre de usuario de un perfil, canal o grupo para enlazar en la tarjeta. Ejemplo: exteradevplugins (abrirá t.me/exteradevplugins)",
        "fr": "Entrez le nom d'utilisateur d'un profil, canal ou groupe à lier sur la carte. Exemple : exteradevplugins (ouvrira t.me/exteradevplugins)"
    },

    "test_lastfm_account": {
        "pt": "Verificar Conta LastFM",
        "en": "Verify LastFM Account",
        "es": "Verificar Cuenta LastFM",
        "fr": "Vérifier Compte LastFM",
        "ru": "Проверить аккаунт LastFM"
    },
    "integration_media_source_info": {
        "pt": "Media Source",
        "en": "Media Source",
        "es": "Fuente de Medios",
        "fr": "Source Média",
        "ru": "Источник медиа"
    },
    "integration_media_source_dialog": {
        "pt": "Integration & Media Source\n\nEsta seção permite configurar como o nowFy detecta e processa música de diferentes fontes:\n\n• Active Player: Define qual aplicativo de música será monitorado para detectar a música atual (Spotify, YouTube Music, Apple Music, etc.). O plugin irá capturar informações da música que está tocando no player selecionado. O player 'FM' é um player personalizado que permite usar dados do Last.fm independente do player ativo.\n\n• Data Mode: Determina de onde vêm os dados da música:\n  - Via Spotify: Usa a API do Spotify para obter informações detalhadas\n  - Via Last.FM: Usa o Last.FM para obter dados de scrobbling e histórico\n\n• Artwork API: Prioridade das APIs para buscar capas de álbuns\n\nEssas configurações determinam como o plugin funciona com diferentes serviços de música.",
        "en": "Integration & Media Source\n\nThis section allows you to configure how nowFy detects and processes music from different sources:\n\n• Active Player: Defines which music app will be monitored to detect the current music (Spotify, YouTube Music, Apple Music, etc.). The plugin will capture information from the music playing on the selected player. The 'FM' player is a custom player that allows using Last.fm data regardless of the active player.\n\n• Data Mode: Determines where the music data comes from:\n  - Via Spotify: Uses Spotify API to get detailed information\n  - Via Last.FM: Uses Last.FM to get scrobbling data and history\n\n• Artwork API: Priority of APIs to search for album covers\n\nThese settings determine how the plugin works with different music services.",
        "es": "Integración y Fuente de Medios\n\nEsta sección te permite configurar cómo nowFy detecta y procesa música de diferentes fuentes:\n\n• Reproductor Activo: Define qué aplicación de música será monitoreada para detectar la música actual (Spotify, YouTube Music, Apple Music, etc.). El plugin capturará información de la música que se reproduce en el reproductor seleccionado. El reproductor 'FM' es un reproductor personalizado que permite usar datos de Last.fm independientemente del reproductor activo.\n\n• Modo de Datos: Determina de dónde provienen los datos de la música:\n  - Vía Spotify: Usa la API de Spotify para obtener información detallada\n  - Vía Last.FM: Usa Last.FM para obtener datos de scrobbling e historial\n\n• API de Portada: Prioridad de las APIs para buscar portadas de álbumes\n\nEstos ajustes determinan cómo funciona el plugin con diferentes servicios de música.",
        "fr": "Intégration et Source Média\n\nCette section vous permet de configurer comment nowFy détecte et traite la musique de différentes sources :\n\n• Lecteur Actif : Définit quelle application musicale sera surveillée pour détecter la musique actuelle (Spotify, YouTube Music, Apple Music, etc.). Le plugin capturera les informations de la musique en cours de lecture sur le lecteur sélectionné. Le lecteur 'FM' est un lecteur personnalisé qui permet d'utiliser les données Last.fm indépendamment du lecteur actif.\n\n• Mode de Données : Détermine d'où proviennent les données musicales :\n  - Via Spotify : Utilise l'API Spotify pour obtenir des informations détaillées\n  - Via Last.FM : Utilise Last.FM pour obtenir des données de scrobbling et l'historique\n\n• API de Pochette : Priorité des APIs pour rechercher les pochettes d'albums\n\nCes paramètres déterminent comment le plugin fonctionne avec différents services de musique.",
        "ru": "Интеграция и источник медиа\n\nЭтот раздел позволяет настроить, как nowFy обнаруживает и обрабатывает музыку из разных источников:\n\n• Активный плеер: Определяет, какое музыкальное приложение будет отслеживаться для обнаружения текущей музыки (Spotify, YouTube Music, Apple Music и т.д.). Плагин будет захватывать информацию о музыке, воспроизводимой в выбранном плеере. Плеер 'FM' - это пользовательский плеер, который позволяет использовать данные Last.fm независимо от активного плеера.\n\n• Режим данных: Определяет, откуда берутся данные о музыке:\n  - Через Spotify: Использует API Spotify для получения подробной информации\n  - Через Last.FM: Использует Last.FM для получения данных скробблинга и истории\n\n• API обложки: Приоритет API для поиска обложек альбомов\n\nЭти настройки определяют, как плагин работает с различными музыкальными сервисами."
    },
    "credentials_info": {
        "pt": "Sobre as Credenciais",
        "en": "Credentials Info",
        "es": "Info de Credenciales",
        "fr": "Info Identifiants",
        "ru": "Информация об учетных данных"
    },
    "credentials_info_dialog": {
        "en": (
            "Spotify Credentials Setup\n\n"
            "To use nowFy with Spotify, follow the steps below:\n\n"
            "1. Go to https://developer.spotify.com/dashboard/create and create an app\n"
            "2. Add this Redirect URI (mandatory):\n"
            "   https://example.com/callback\n"
            "3. After creating the app, copy your:\n"
            "   • Client ID\n"
            "   • Client Secret\n"
            "4. In the plugin chat, send:\n"
            "   • .setid YOUR_CLIENT_ID\n"
            "   • .setsecret YOUR_CLIENT_SECRET\n"
            "5. Then use:\n"
            "   • .connect\n"
            "   This will generate your personal authorization link\n"
            "6. Open the link, log in to Spotify, and authorize the app\n"
            "7. You will be redirected to a URL like:\n"
            "   https://example.com/callback?code=abc123xyz\n"
            "8. Copy the full URL or just the code and send:\n"
            "   • .code FULL_URL or .code CODE_ONLY\n\n"
            "All credentials are required for the plugin to work."
        ),
        "pt": (
            "Configuração do Spotify\n\n"
            "Para usar o nowFy com o Spotify, siga os passos abaixo:\n\n"
            "1. Acesse https://developer.spotify.com/dashboard/create e crie um app\n"
            "2. Adicione este Redirect URI (obrigatório):\n"
            "   https://example.com/callback\n"
            "3. Após criar o app, copie:\n"
            "   • Client ID\n"
            "   • Client Secret\n"
            "4. No chat com o plugin, envie:\n"
            "   • .setid SEU_CLIENT_ID\n"
            "   • .setsecret SEU_CLIENT_SECRET\n"
            "5. Em seguida, use:\n"
            "   • .connect\n"
            "   Isso vai gerar seu link de autorização\n"
            "6. Abra o link, entre na sua conta do Spotify e autorize o app\n"
            "7. Você será redirecionado para uma URL como:\n"
            "   https://example.com/callback?code=abc123xyz\n"
            "8. Copie a URL completa ou só o código e envie:\n"
            "   • .code URL_COMPLETA ou .code CODIGO_APENAS\n\n"
            "Todas as credenciais são obrigatórias para o funcionamento do plugin."
        ),
        "es": (
            "Configuración de Spotify\n\n"
            "Para usar nowFy con Spotify, sigue estos pasos:\n\n"
            "1. Ve a https://developer.spotify.com/dashboard/create y crea una app\n"
            "2. Agrega este Redirect URI (obligatorio):\n"
            "   https://example.com/callback\n"
            "3. Después de crear la app, copia:\n"
            "   • Client ID\n"
            "   • Client Secret\n"
            "4. En el chat del plugin, envía:\n"
            "   • .setid TU_CLIENT_ID\n"
            "   • .setsecret TU_CLIENT_SECRET\n"
            "5. Luego usa:\n"
            "   • .connect\n"
            "   Esto generará tu enlace de autorización personal\n"
            "6. Abre el enlace, inicia sesión en Spotify y autoriza la app\n"
            "7. Serás redirigido a una URL como:\n"
            "   https://example.com/callback?code=abc123xyz\n"
            "8. Copia la URL completa o solo el código y envía:\n"
            "   • .code URL_COMPLETA o .code SOLO_CODIGO\n\n"
            "Todas las credenciales son necesarias para que el plugin funcione."
        ),
        "fr": (
            "Configuration de Spotify\n\n"
            "Pour utiliser nowFy avec Spotify, suivez ces étapes :\n\n"
            "1. Allez sur https://developer.spotify.com/dashboard/create et créez une application\n"
            "2. Ajoutez cet URI de redirection (obligatoire) :\n"
            "   https://example.com/callback\n"
            "3. Après avoir créé l'application, copiez :\n"
            "   • Client ID\n"
            "   • Client Secret\n"
            "4. Dans le chat du plugin, envoyez :\n"
            "   • .setid VOTRE_CLIENT_ID\n"
            "   • .setsecret VOTRE_CLIENT_SECRET\n"
            "5. Ensuite, utilisez :\n"
            "   • .connect\n"
            "   Cela générera votre lien d'autorisation personnel\n"
            "6. Ouvrez le lien, connectez-vous à Spotify et autorisez l'application\n"
            "7. Vous serez redirigé vers une URL comme :\n"
            "   https://example.com/callback?code=abc123xyz\n"
            "8. Copiez l'URL complète ou seulement le code et envoyez :\n"
            "   • .code URL_COMPLÈTE ou .code CODE_SEUL\n\n"
            "Toutes les informations sont nécessaires pour que le plugin fonctionne."
        ),
        "ru": (
            "Настройка Spotify\n\n"
            "Чтобы использовать nowFy с Spotify, выполните следующие шаги:\n\n"
            "1. Перейдите на https://developer.spotify.com/dashboard/create и создайте приложение\n"
            "2. Добавьте этот Redirect URI (обязательно):\n"
            "   https://example.com/callback\n"
            "3. После создания приложения скопируйте:\n"
            "   • Client ID\n"
            "   • Client Secret\n"
            "4. В чате с плагином выполните:\n"
            "   • .setid ВАШ_CLIENT_ID\n"
            "   • .setsecret ВАШ_CLIENT_SECRET\n"
            "5. Затем используйте:\n"
            "   • .connect\n"
            "   Это сгенерирует вашу персональную ссылку авторизации\n"
            "6. Откройте ссылку, войдите в Spotify и подтвердите доступ\n"
            "7. Вы будете перенаправлены на адрес вроде:\n"
            "   https://example.com/callback?code=abc123xyz\n"
            "8. Скопируйте полную ссылку или только код и отправьте:\n"
            "   • .code ПОЛНАЯ_ССЫЛКА или .code ТОЛЬКО_КОД\n\n"
            "Все учетные данные необходимы для работы плагина."
        )
    },
    "card_appearance_header": {"pt": "Aparência do Card", "en": "Card Appearance", "es": "Apariencia de la Tarjeta", "fr": "Apparence de la carte", "ru": "Внешний вид карточки"},
    "cache_header": {"pt": "Cache", "en": "Cache", "es": "Caché", "fr": "Cache", "ru": "Кэш"},
    "smart_bio_header": {
        "en": "Bio Features",
        "pt": "Recursos da Bio",
        "es": "Funciones de la Bio",
        "fr": "Fonctionnalités Bio",
        "ru": "Функции био"
    },
    "lastfm_test_title": {
        "pt": "Teste LastFM",
        "en": "LastFM Test",
        "es": "Prueba LastFM",
        "fr": "Test LastFM",
        "ru": "Тест LastFM"
    },
    "lastfm_username_not_configured": {
        "pt": "Username não configurado!\n\nConfigure o username do LastFM primeiro.",
        "en": "Username not configured!\n\nConfigure the LastFM username first.",
        "es": "¡Username no configurado!\n\nConfigure el username de LastFM primero.",
        "fr": "Nom d'utilisateur non configuré!\n\nConfigurez le nom d'utilisateur LastFM d'abord.",
        "ru": "Имя пользователя не настроено!\n\nСначала настройте имя пользователя LastFM."
    },
    "lastfm_testing": {
        "pt": "Testando LastFM",
        "en": "Testing LastFM",
        "es": "Probando LastFM",
        "fr": "Test de LastFM",
        "ru": "Тестирование LastFM"
    },
    "lastfm_checking_account": {
        "pt": "Verificando conta: @{username}\n\nAguarde...",
        "en": "Checking account: @{username}\n\nPlease wait...",
        "es": "Verificando cuenta: @{username}\n\nEspere...",
        "fr": "Vérification du compte: @{username}\n\nVeuillez patienter...",
        "ru": "Проверка аккаунта: @{username}\n\nПодождите..."
    },
    "cancel": {
        "pt": "Cancelar",
        "en": "Cancel",
        "es": "Cancelar",
        "fr": "Annuler",
        "ru": "Отмена"
    },
    "lastfm_api_connection_error": {
        "pt": "Não foi possível conectar à API do LastFM",
        "en": "Could not connect to LastFM API",
        "es": "No se pudo conectar a la API de LastFM",
        "fr": "Impossible de se connecter à l'API LastFM",
        "ru": "Не удалось подключиться к API LastFM"
    },
    "lastfm_recent_tracks_error": {
        "pt": "Não foi possível buscar músicas recentes",
        "en": "Could not fetch recent tracks",
        "es": "No se pudieron obtener las canciones recientes",
        "fr": "Impossible de récupérer les morceaux récents",
        "ru": "Не удалось получить недавние треки"
    },
    "lastfm_test_result": {
        "pt": "Resultado do Teste LastFM",
        "en": "LastFM Test Result",
        "es": "Resultado de la Prueba LastFM",
        "fr": "Résultat du Test LastFM",
        "ru": "Результат теста LastFM"
    },
    "lastfm_account_working": {
        "pt": "Conta verificada com sucesso!\n\nUsuário: @{username}\nTotal de músicas ouvidas: {playcount}",
        "en": "Account successfully verified!\n\nUsername: @{username}\nTotal tracks played: {playcount}",
        "es": "¡Cuenta verificada con éxito!\n\nUsuario: @{username}\nTotal de canciones escuchadas: {playcount}",
        "fr": "Compte vérifié avec succès !\n\nNom d'utilisateur : @{username}\nTotal de morceaux écoutés : {playcount}",
        "ru": "Аккаунт успешно проверен!\n\nПользователь: @{username}\nВсего прослушанных треков: {playcount}"
    },
    "lastfm_now_playing": {
        "pt": "Tocando agora:\n{track} by {artist}",
        "en": "Now playing:\n{track} by {artist}",
        "es": "Reproduciendo ahora:\n{track} by {artist}",
        "fr": "En cours de lecture:\n{track} by {artist}",
        "ru": "Сейчас играет:\n{track} by {artist}"
    },
    "lastfm_last_played": {
        "pt": "Última música ouvida:\n{track} by {artist}",
        "en": "Last played:\n{track} by {artist}",
        "es": "Última canción escuchada:\n{track} by {artist}",
        "fr": "Dernier morceau écouté:\n{track} by {artist}",
        "ru": "Последний прослушанный трек:\n{track} by {artist}"
    },
    "lastfm_test_failed": {
        "pt": "Falha no teste!\n\nUsuário: @{username}{error}\n\nVerifique:\n• API Key configurada\n• Username correto\n• Conexão com internet",
        "en": "Test failed!\n\nUsername: @{username}{error}\n\nCheck:\n• API Key configured\n• Correct username\n• Internet connection",
        "es": "¡Prueba fallida!\n\nUsuario: @{username}{error}\n\nVerifique:\n• API Key configurada\n• Username correcto\n• Conexión a internet",
        "fr": "Test échoué!\n\nNom d'utilisateur: @{username}{error}\n\nVérifiez:\n• Clé API configurée\n• Nom d'utilisateur correct\n• Connexion internet",
        "ru": "Тест не удался!\n\nПользователь: @{username}{error}\n\nПроверьте:\n• API ключ настроен\n• Правильное имя пользователя\n• Интернет соединение"
    },
    "extras_header": {"pt": "Extras", "en": "Extras", "es": "Extras", "fr": "Extras", "ru": "Дополнительно"},
    "smart_bio_enabled": {"pt": "Smart Bio", "en": "Smart Bio", "es": "Bio Inteligente", "fr": "Bio intelligente", "ru": "Умная био"},
    "smart_bio_auto_refresh": {"pt": "Auto-refresh bio", "en": "Auto-refresh bio", "es": "Auto-actualizar bio", "fr": "Actualisation auto de la bio", "ru": "Автообновление био"},
    "bio_text": {"pt": "Bio", "en": "Bio", "es": "Bio", "fr": "Bio", "ru": "Био"},
    "smart_bio_panel_sub": {
        "pt": "Gerencie a bio automática baseada na música tocando",
        "en": "Manage automatic bio based on the current track",
        "es": "Gestiona la bio automática según la música actual",
        "fr": "Gérez la bio automatique selon la musique en cours",
        "ru": "Управляйте авто-био на основе текущего трека"
    },
    "error_youtube_api_key": {
        "pt": "YouTube API Key não configurada. Configure em Configurações > nowFy > YouTube API Key",
        "en": "YouTube API Key not configured. Configure in Settings > nowFy > YouTube API Key",
        "es": "Clave de API de YouTube no configurada. Configure en Ajustes > nowFy > YouTube API Key",
        "fr": "Clé API YouTube non configurée. Configurez dans Paramètres > nowFy > YouTube API Key",
        "ru": "Ключ API YouTube не настроен. Настройте в Настройки > nowFy > YouTube API Key"
    },
    "guide_title": {
        "pt": "Guia de Login e Uso",
        "en": "Login & Usage Guide",
        "es": "Guía de inicio de sesión y uso",
        "fr": "Guide de connexion et d'utilisation",
        "ru": "Руководство по входу и использованию"
    },
    "guide_message": {
        "pt": "Veja o guia completo para criar um app no Spotify for Developers e obter seu Client ID e Secret. Siga o passo a passo para configurar o nowFy corretamente.",
        "en": "View the full guide to create an app on Spotify for Developers and get your Client ID and Secret. Follow the step-by-step instructions to set up nowFy correctly.",
        "es": "Consulta la guía completa para crear una aplicación en Spotify for Developers y obtener tu Client ID y Secret. Sigue las instrucciones paso a paso para configurar nowFy correctamente.",
        "fr": "Consultez le guide complet pour créer une application sur Spotify for Developers et obtenir votre Client ID et Secret. Suivez les instructions étape par étape pour configurer nowFy correctement.",
        "ru": "Ознакомьтесь с полным руководством по созданию приложения в Spotify for Developers и получению Client ID и Secret. Следуйте пошаговым инструкциям для правильной настройки nowFy."
    },
    "guide_open_link": {
        "pt": "Abrir Guia",
        "en": "Open Guide",
        "es": "Abrir Guía",
        "fr": "Ouvrir le guide",
        "ru": "Открыть руководство"
    },
    "no_track_playing_soundcloud": {
        "pt": "Nenhuma música tocando no SoundCloud.",
        "en": "No track playing on SoundCloud.",
        "es": "No hay música reproduciéndose en SoundCloud.",
        "fr": "Aucune musique en cours sur SoundCloud.",
        "ru": "Нет воспроизводимой музыки в SoundCloud."
    },
    "lastfm_key_saved": {
        "pt": "Chave da API do LastFM salva!",
        "en": "LastFM API key saved!",
        "es": "¡Clave API de LastFM guardada!",
        "fr": "Clé API LastFM enregistrée!",
        "ru": "Ключ API LastFM сохранён!"
    },
    "lastfm_user_saved": {
        "pt": "Usuário do LastFM salvo!",
        "en": "LastFM username saved!",
        "es": "¡Usuario de LastFM guardado!",
        "fr": "Nom d'utilisateur LastFM enregistré!",
        "ru": "Имя пользователя LastFM сохранено!"
    },
    "client_id": {"pt": "Client ID", "en": "Client ID", "es": "Client ID", "fr": "Client ID", "ru": "Client ID"},
    "client_id_subtext": {
        "pt": "Seu Client ID do app Spotify Developers.",
        "en": "Your Client ID from Spotify Developers app.",
        "es": "Tu Client ID de la app Spotify Developers.",
        "fr": "Votre Client ID de l'application Spotify Developers.",
        "ru": "Ваш Client ID из приложения Spotify Developers."
    },
    "client_secret": {"pt": "Client Secret", "en": "Client Secret", "es": "Client Secret", "fr": "Client Secret", "ru": "Client Secret"},
    "client_secret_subtext": {
        "pt": "Seu Client Secret do app Spotify Developers.",
        "en": "Your Client Secret from Spotify Developers app.",
        "es": "Tu Client Secret de la app Spotify Developers.",
        "fr": "Votre Client Secret de l'application Spotify Developers.",
        "ru": "Ваш Client Secret из приложения Spotify Developers."
    },
    "refresh_token": {"pt": "Refresh Token", "en": "Refresh Token", "es": "Refresh Token", "fr": "Refresh Token", "ru": "Refresh Token"},
    "refresh_token_subtext": {
        "pt": "Cole aqui seu refresh token ou use o comando .code para gerar.",
        "en": "Paste your refresh token here or use the .code command to generate.",
        "es": "Pega aquí tu refresh token o usa el comando .code para generar uno.",
        "fr": "Collez ici votre refresh token ou utilisez la commande .code pour en générer un.",
        "ru": "Вставьте сюда ваш refresh token или используйте команду .code для его получения."
    },
    "artwork_source_youtube": {"pt": "Usar YouTube como fonte de capa", "en": "Use YouTube as artwork source", "es": "Usar YouTube como fuente de portada", "fr": "Utiliser YouTube comme source de pochette", "ru": "Использовать YouTube как источник обложки"},
    "artwork_source_lastfm": {"pt": "Usar LastFM como fonte de capa", "en": "Use LastFM as artwork source", "es": "Usar LastFM como fuente de portada", "fr": "Utiliser LastFM comme source de pochette", "ru": "Использовать LastFM как источник обложки"},
    "artwork_priority_selector": {"pt": "Fonte de capa preferida", "en": "Preferred artwork source", "es": "Fuente de portada preferida", "fr": "Source de pochette préférée", "ru": "Предпочтительный источник обложки"},
    "artwork_spotify": {"pt": "Spotify", "en": "Spotify", "es": "Spotify", "fr": "Spotify", "ru": "Spotify"},
    "artwork_deezer": {"pt": "Deezer", "en": "Deezer", "es": "Deezer", "fr": "Deezer", "ru": "Deezer"},
    "artwork_itunes": {"pt": "iTunes", "en": "iTunes", "es": "iTunes", "fr": "iTunes", "ru": "iTunes"},
    "artwork_youtube": {"pt": "YouTube", "en": "YouTube", "es": "YouTube", "fr": "YouTube", "ru": "YouTube"},
    "artwork_lastfm": {"pt": "LastFM", "en": "LastFM", "es": "LastFM", "fr": "LastFM", "ru": "LastFM"},
    "artwork_coverart": {"pt": "Cover Art Archive", "en": "Cover Art Archive", "es": "Cover Art Archive", "fr": "Cover Art Archive", "ru": "Cover Art Archive"},
    "diversos_header": {
        "pt": "Diversos",
        "en": "Miscellaneous",
        "es": "Varios",
        "fr": "Divers",
        "ru": "Разное"
    },
    "diversos_custom_command": {
        "pt": "Comando Personalizado",
        "en": "Custom Command",
        "es": "Comando Personalizado",
        "fr": "Commande personnalisée",
        "ru": "Пользовательская команда"
    },
    "diversos_show_chat_menu": {
        "pt": "Mostrar no Menu do Chat",
        "en": "Show in Chat Menu",
        "es": "Mostrar en el menú del chat",
        "fr": "Afficher dans le menu du chat",
        "ru": "Показать в меню чата"
    },
    "music_detection_section": {
        "pt": "Detecção de Música",
        "en": "Music Detection",
        "es": "Detección de Música",
        "fr": "Détection Musicale",
        "ru": "Обнаружение музыки"
    },
    "active_player": {
        "pt": "Player Ativo",
        "en": "Active Player",
        "es": "Reproductor Activo",
        "fr": "Lecteur Actif",
        "ru": "Активный плеер"
    },
    "active_player_subtext": {
        "pt": "Qual aplicativo está tocando música",
        "en": "Which app is playing music",
        "es": "Qué aplicación está reproduciendo música",
        "fr": "Quelle application joue de la musique",
        "ru": "Какое приложение воспроизводит музыку"
    },
    "data_mode": {
        "pt": "Modo de Dados",
        "en": "Data Mode",
        "es": "Modo de Datos",
        "fr": "Mode de Données",
        "ru": "Режим данных"
    },
    "data_mode_subtext": {
        "pt": "Como obter informações da música",
        "en": "How to get music information",
        "es": "Cómo obtener información de la música",
        "fr": "Comment obtenir les informations musicales",
        "ru": "Как получить информацию о музыке"
    },
    "apis_integration_section": {
        "pt": "APIs e Integração",
        "en": "APIs & Integration",
        "es": "APIs e Integración",
        "fr": "APIs et Intégration",
        "ru": "API и интеграция"
    },
    "diversos_media_source": {
        "pt": "Fonte da Mídia",
        "en": "Media Source",
        "es": "Fuente de Medios",
        "fr": "Source Média",
        "ru": "Источник медиа"
    },
    "diversos_artwork_api": {
        "pt": "API de Capa",
        "en": "Artwork API",
        "es": "API de Portada",
        "fr": "API de pochette",
        "ru": "API обложки"
    },
    "diversos_media_source_info": {
        "pt": "Configurações de mídia",
        "en": "Media Settings",
        "es": "Configuración de medios",
        "fr": "Paramètres des médias",
        "ru": "Настройки медиа"
    },
    "link_options_header": {
        "pt": "Opções de Links",
        "en": "Link Options",
        "es": "Opciones de Enlaces",
        "fr": "Options de Liens",
        "ru": "Опции ссылок"
    },
    "no_services_configured": {
        "pt": "Nenhum serviço configurado. Configure pelo menos um: Stats.fm username, Last.fm API key ou credenciais do Spotify.",
        "en": "No services configured. Please configure at least one: Stats.fm username, Last.fm API key, or Spotify credentials.",
        "es": "Ningún servicio configurado. Configure al menos uno: nombre de usuario de Stats.fm, clave API de Last.fm o credenciales de Spotify.",
        "fr": "Aucun service configuré. Veuillez configurer au moins un : nom d'utilisateur Stats.fm, clé API Last.fm ou identifiants Spotify.",
        "ru": "Сервисы не настроены. Настройте хотя бы один: имя пользователя Stats.fm, ключ API Last.fm или учетные данные Spotify."
    },
    
    # NowCast Messages
    "nowcast_activated_card_sent": {
        "pt": "NowCast ativado e card enviado!",
        "en": "NowCast activated and card sent!",
        "es": "NowCast activado y tarjeta enviada!",
        "fr": "NowCast activé et carte envoyée!",
        "ru": "NowCast активирован и карточка отправлена!"
    },
    "nowcast_activated_card_error": {
        "pt": "NowCast ativado, mas erro ao enviar card",
        "en": "NowCast activated, but error sending card",
        "es": "NowCast activado, pero error al enviar tarjeta",
        "fr": "NowCast activé, mais erreur lors de l'envoi de la carte",
        "ru": "NowCast активирован, но ошибка отправки карточки"
    },
    "nowcast_activated_duplicate": {
        "pt": "NowCast ativado! Música já foi postada recentemente.",
        "en": "NowCast activated! Song was already posted recently.",
        "es": "NowCast activado! La canción ya fue publicada recientemente.",
        "fr": "NowCast activé! La chanson a déjà été postée récemment.",
        "ru": "NowCast активирован! Песня уже была опубликована недавно."
    },
    "nowcast_activated_waiting": {
        "pt": "NowCast ativado! Aguardando música...",
        "en": "NowCast activated! Waiting for music...",
        "es": "NowCast activado! Esperando música...",
        "fr": "NowCast activé! En attente de musique...",
        "ru": "NowCast активирован! Ожидание музыки..."
    },
    "nowcast_bot_command_error": {
        "pt": "Erro ao executar comando .bot",
        "en": "Error executing .bot command",
        "es": "Error al ejecutar comando .bot",
        "fr": "Erreur lors de l'exécution de la commande .bot",
        "ru": "Ошибка выполнения команды .bot"
    },
    "nowcast_not_configured": {
        "pt": "NowCast não está configurado corretamente. Verifique as credenciais e configurações do bot.",
        "en": "NowCast is not configured correctly. Check bot credentials and settings.",
        "es": "NowCast no está configurado correctamente. Verifique las credenciales y configuraciones del bot.",
        "fr": "NowCast n'est pas configuré correctement. Vérifiez les identifiants et paramètres du bot.",
        "ru": "NowCast настроен неправильно. Проверьте учетные данные и настройки бота."
    },
    "nowcast_auto_disabled": {
        "pt": "NowCast foi desligado automaticamente após 10 minutos de inatividade musical.",
        "en": "NowCast was automatically disabled after 10 minutes of musical inactivity.",
        "es": "NowCast se desactivó automáticamente después de 10 minutos de inactividad musical.",
        "fr": "NowCast a été automatiquement désactivé après 10 minutes d'inactivité musicale.",
        "ru": "NowCast был автоматически отключен после 10 минут музыкальной неактивности."
    },
    "nowcast_link_spotify": {
        "pt": "Ouvir no Spotify",
        "en": "Listen on Spotify",
        "es": "Escuchar en Spotify",
        "fr": "Écouter sur Spotify",
        "ru": "Слушать в Spotify"
    },
    "nowcast_link_platforms": {
        "pt": "song.link",
        "en": "song.link",
        "es": "song.link",
        "fr": "song.link",
        "ru": "song.link"
    }
}

TRANSLATIONS.update({
    "diversos_sub": {
        "pt": "Expandir para visualizar configurações diversas. Ativar expande o painel, desativar o recolhe.",
        "en": "Expand to view miscellaneous settings. Turning on expands the panel, turning off collapses it.",
        "es": "Expandir para ver configuraciones diversas. Al activar se expande el panel, al desactivar se contrae.",
        "fr": "Développer pour voir les paramètres divers. Activer déploie le panneau, désactiver le replie.",
        "ru": "Развернуть для просмотра различных настроек. Включение раскрывает панель, выключение сворачивает её."
    },
    "command_settings_section": {
        "pt": "Configurações de Comando",
        "en": "Command Settings",
        "es": "Configuraciones de Comando",
        "fr": "Paramètres de Commande",
        "ru": "Настройки команд"
    },
    "interface_settings_section": {
        "pt": "Configurações de Interface",
        "en": "Interface Settings",
        "es": "Configuraciones de Interfaz",
        "fr": "Paramètres d'Interface",
        "ru": "Настройки интерфейса"
    },
    "media_settings_section": {
        "pt": "Configurações de Mídia",
        "en": "Media Settings",
        "es": "Configuraciones de Medios",
        "fr": "Paramètres Média",
        "ru": "Настройки медиа"
    },
    "help_info_section": {
        "pt": "Ajuda e Informações",
        "en": "Help and Information",
        "es": "Ayuda e Información",
        "fr": "Aide et Informations",
        "ru": "Справка и информация"
    },
    "spotify_auth_section": {
        "pt": "Autenticação do Spotify",
        "en": "Spotify Authentication",
        "es": "Autenticación de Spotify",
        "fr": "Authentification Spotify",
        "ru": "Аутентификация Spotify"
    },
    "spotify_help_section": {
        "pt": "Ajuda e Informações",
        "en": "Help and Information",
        "es": "Ayuda e Información",
        "fr": "Aide et Informations",
        "ru": "Справка и информация"
    },
    "lastfm_auth_section": {
        "pt": "Autenticação do Last.FM",
        "en": "Last.FM Authentication",
        "es": "Autenticación de Last.FM",
        "fr": "Authentification Last.FM",
        "ru": "Аутентификация Last.FM"
    },
    "youtube_api_section": {
        "pt": "API do YouTube",
        "en": "YouTube API",
        "es": "API de YouTube",
        "fr": "API YouTube",
        "ru": "API YouTube"
    },
    "lastfm_help_section": {
        "pt": "Testes e Ajuda",
        "en": "Tests and Help",
        "es": "Pruebas y Ayuda",
        "fr": "Tests et Aide",
        "ru": "Тесты и справка"
    },
    # Apple UI Options
    "apple_ui_section": {
        "pt": "Apple UI (Experimental)",
        "en": "Apple UI (Experimental)",
        "es": "Apple UI (Experimental)",
        "fr": "Apple UI (Expérimental)",
        "ru": "Apple UI (Экспериментальный)"
    },
    "apple_ui_warning": {
        "pt": "Configurações experimentais para temas Apple. Algumas features podem precisar de melhorias.",
        "en": "Experimental settings for Apple themes. Some features may need improvements.",
        "es": "Configuraciones experimentales para temas Apple. Algunas características pueden necesitar mejoras.",
        "fr": "Paramètres expérimentaux pour les thèmes Apple. Certaines fonctionnalités peuvent nécessiter des améliorations.",
        "ru": "Экспериментальные настройки для тем Apple. Некоторые функции могут нуждаться в улучшениях."
    },

    "apple_radius_original": {
        "pt": "Original",
        "en": "Original",
        "es": "Original",
        "fr": "Original",
        "ru": "Оригинал"
    },
    "apple_radius_standard": {
        "pt": "Padrão",
        "en": "Standard",
        "es": "Estándar",
        "fr": "Standard",
        "ru": "Стандарт"
    },
    "apple_radius_small": {
        "pt": "Pequeno",
        "en": "Small",
        "es": "Pequeño",
        "fr": "Petit",
        "ru": "Маленький"
    },
    "apple_radius_medium": {
        "pt": "Médio",
        "en": "Medium",
        "es": "Medio",
        "fr": "Moyen",
        "ru": "Средний"
    },
    "apple_radius_large": {
        "pt": "Grande",
        "en": "Large",
        "es": "Grande",
        "fr": "Grand",
        "ru": "Большой"
    },
    "apple_antialiasing_quality": {
        "pt": "Qualidade do Anti-aliasing",
        "en": "Anti-aliasing Quality",
        "es": "Calidad del Anti-aliasing",
        "fr": "Qualité de l'Anti-aliasing",
        "ru": "Качество сглаживания"
    },
    "apple_resize_algorithm": {
        "pt": "Algoritmo de Redimensionamento",
        "en": "Resize Algorithm",
        "es": "Algoritmo de Redimensionamiento",
        "fr": "Algorithme de Redimensionnement",
        "ru": "Алгоритм изменения размера"
    },
    "apple_cover_quality": {
        "pt": "Qualidade da Mini Capa",
        "en": "Mini Cover Quality",
        "es": "Calidad de Mini Portada",
        "fr": "Qualité de Mini Couverture",
        "ru": "Качество мини обложки"
    },
    "apple_enhanced_smoothing": {
        "pt": "Suavização Aprimorada",
        "en": "Enhanced Smoothing",
        "es": "Suavizado Mejorado",
        "fr": "Lissage Amélioré",
        "ru": "Улучшенное сглаживание"
    },
    "apple_edge_enhancement": {
        "pt": "Realce de Bordas",
        "en": "Edge Enhancement",
        "es": "Realce de Bordes",
        "fr": "Amélioration des Bords",
        "ru": "Улучшение краев"
    },
    "apple_color_enhancement": {
        "pt": "Realce de Cores",
        "en": "Color Enhancement",
        "es": "Realce de Colores",
        "fr": "Amélioration des Couleurs",
        "ru": "Улучшение цветов"
    },
    "apple_cache_processed_covers": {
        "pt": "Cache de Mini Capas Processadas",
        "en": "Processed Mini Covers Cache",
        "es": "Caché de Mini Portadas Procesadas",
        "fr": "Cache de Mini Couvertures Traitées",
        "ru": "Кэш обработанных мини обложек"
    },
    "apple_async_processing": {
        "pt": "Processamento Assíncrono",
        "en": "Asynchronous Processing",
        "es": "Procesamiento Asíncrono",
        "fr": "Traitement Asynchrone",
        "ru": "Асинхронная обработка"
    }
})

# Send visual effect toggle and style selector translations
TRANSLATIONS.update({
    "send_visual_effect_sub": {
        "pt": "Cria um efeito de pulso na tela ao gerar o card Now Playing",
        "en": "Creates a pulse effect on the screen when generating the Now Playing card",
        "es": "Crea un efecto de pulso en la pantalla al generar la tarjeta Now Playing",
        "fr": "Crée un effet de pulsation à l'écran lors de la génération de la carte Now Playing",
        "ru": "Создаёт эффект пульсации на экране при создании карточки Now Playing"
    },
    "now_playing_label": {
        "pt": "Now Playing",
        "en": "Now Playing",
        "es": "Now Playing",
        "fr": "Now Playing",
        "ru": "Now Playing"
    },
    "now_playing_sub": {
        "pt": "Mostra Now Playing no menu do chat e envia o card",
        "en": "Shows Now Playing in chat menu and sends the card",
        "es": "Muestra Now Playing en el menú del chat y envía la tarjeta",
        "fr": "Affiche Now Playing dans le menu du chat et envoie la carte",
        "ru": "Показывает Now Playing в меню чата и отправляет карточку"
    },
    "now_card_source_label": {
        "pt": "Serviço do Now Card",
        "en": "Now Card Service",
        "es": "Servicio de la Tarjeta Now",
        "fr": "Service de la Carte Now",
        "ru": "Сервис карточки Now"
    },
    "now_playing_menu_item": {
        "pt": "Now Playing",
        "en": "Now Playing",
        "es": "Now Playing",
        "fr": "Now Playing",
        "ru": "Now Playing"
    },
    "experimental_header": {
        "pt": "Experimental",
        "en": "Experimental",
        "es": "Experimental",
        "fr": "Expérimental",
        "ru": "Экспериментальные"
    },
    "experimental_sub": {
        "pt": "Recursos experimentais; podem ser alterados ou descontinuados.",
        "en": "Experimental features; subject to change or removal.",
        "es": "Funciones experimentales; pueden modificarse o descontinuarse.",
        "fr": "Fonctionnalités expérimentales; susceptibles d’être modifiées ou supprimées.",
        "ru": "Экспериментальные функции; могут быть изменены или удалены."
    },
    "experimental_section": {
        "pt": "Recursos experimentais",
        "en": "Experimental Features",
        "es": "Funciones experimentales",
        "fr": "Fonctionnalités expérimentales",
        "ru": "Экспериментальные функции"
    },
    "chat_list_section": {
        "pt": "Chat List",
        "en": "Chat List",
        "es": "Lista de Chats",
        "fr": "Liste des chats",
        "ru": "Список чатов"
    },
    "experimental_notice": {
        "pt": "Aviso: recursos experimentais podem ser instáveis.",
        "en": "Note: experimental features may be unstable.",
        "es": "Aviso: las funciones experimentales pueden ser inestables.",
        "fr": "Note: les fonctionnalités expérimentales peuvent être instables.",
        "ru": "Примечание: экспериментальные функции могут быть нестабильны."
    },
    "chat_list_label": {
        "pt": "Chat List (Beta)",
        "en": "Chat List (Beta)",
        "es": "Lista de Chats (Beta)",
        "fr": "Liste des chats (Beta)",
        "ru": "Список чатов (Beta)"
    },
    "chat_list_sub": {
        "pt": "Mostra a música atual e o artista no título da lista de chats (via Last.fm, Stats.fm ou Spotify)",
        "en": "Shows current song and artist in chat list title (via Last.fm, Stats.fm or Spotify)",
        "es": "Muestra la canción actual y el artista en el título de la lista de chats (vía Last.fm, Stats.fm o Spotify)",
        "fr": "Affiche la chanson actuelle et l'artiste dans le titre de la liste des chats (via Last.fm, Stats.fm ou Spotify)",
        "ru": "Показывает текущую песню и исполнителя в заголовке списка чатов (через Last.fm, Stats.fm или Spotify)"
    },
    "chat_list_show_cover_label": {
        "pt": "Mostrar Capa",
        "en": "Show Cover",
        "es": "Mostrar Portada",
        "fr": "Afficher la pochette",
        "ru": "Показать обложку"
    },
    "chat_list_show_cover_sub": {
        "pt": "Exibe a capa da música ou do álbum como banner no topo",
        "en": "Displays the song or album cover as a top banner",
        "es": "Muestra la portada de la canción o del álbum como un banner superior",
        "fr": "Affiche la pochette de la chanson ou de l’album en bannière supérieure",
        "ru": "Отображает обложку песни или альбома как верхний баннер"
    },
    "chat_list_settings_section": {
        "pt": "Chat List",
        "en": "Chat List",
        "es": "Lista de Chats",
        "fr": "Liste des chats",
        "ru": "Список чатов"
    },
    "cover_animation_section": {
        "pt": "Animação de Capa",
        "en": "Cover Animation",
        "es": "Animación de Portada",
        "fr": "Animation de couverture",
        "ru": "Анимация обложки"
    },
    "cover_animation_label": {
        "pt": "Animação da capa",
        "en": "Cover animation",
        "es": "Animación de portada",
        "fr": "Animation de couverture",
        "ru": "Анимация обложки"
    },
    "cover_animation_default": {
        "pt": "Padrão",
        "en": "Default",
        "es": "Predeterminado",
        "fr": "Par défaut",
        "ru": "По умолчанию"
    },
    "cover_animation_moving": {
        "pt": "Movendo",
        "en": "Moving",
        "es": "Moviendo",
        "fr": "Mouvant",
        "ru": "Движение"
    },
    "disable_logs_label": {
        "pt": "Desativar logs",
        "en": "Disable logs",
        "es": "Desactivar registros",
        "fr": "Désactiver les logs",
        "ru": "Отключить логи"
    },
    "disable_logs_sub": {
        "pt": "Silencia os logs no console (apenas este plugin)",
        "en": "Mute console logs (this plugin only)",
        "es": "Silencia los registros de consola (solo este plugin)",
        "fr": "Couper les logs de console (ce plugin uniquement)",
        "ru": "Отключить логи в консоли (только этот плагин)"
    },
    "chat_list_default_title": {
        "pt": "Conversas",
        "en": "Chats",
        "es": "Chats",
        "fr": "Discussions",
        "ru": "Чаты"
    },
    "chat_list_now_playing_prefix": {
        "pt": "♪ ıllıllı Tocando agora:",
        "en": "♪ ıllıllı Now Playing:",
        "es": "♪ ıllıllı Reproduciendo ahora:",
        "fr": "♪ ıllıllı Lecture en cours:",
        "ru": "♪ ıllıllı Сейчас играет:"
    },

    "chat_list_status_checking": {
        "pt": "Checando...",
        "en": "Checking...",
        "es": "Comprobando...",
        "fr": "Vérification...",
        "ru": "Проверка..."
    },
    "chat_list_status_updating": {
        "pt": "Atualizando seu Now Playing...",
        "en": "Updating your Now Playing...",
        "es": "Actualizando tu Now Playing...",
        "fr": "Mise à jour de votre Now Playing...",
        "ru": "Обновление вашего Now Playing..."
    }
})

def tr(key):
    lang = Locale.getDefault().getLanguage()
    # Normaliza para os idiomas suportados
    if lang not in ["pt", "en", "es", "fr", "ru"]:
        lang = "en"
    entry = TRANSLATIONS.get(key, {})
    return entry.get(lang) or entry.get("en") or key

# Sistema de menu de contexto implementado diretamente
class _MessageMenuRegistry:
    def __init__(self):
        self.items = []
        self._unhook_fill = None
        self._unhook_process = None

    def ensure_hooks(self, plugin):
        try:
            if not self._unhook_fill:
                ChatActivity = find_class("org.telegram.ui.ChatActivity")
                MessageObject = find_class("org.telegram.messenger.MessageObject")
                fill_method = ChatActivity.getClass().getDeclaredMethod(
                    "fillMessageMenu",
                    MessageObject,
                    ArrayList,
                    ArrayList,
                    ArrayList
                )
                self._unhook_fill = plugin.hook_method(fill_method, _FillMenuHook(self))
        except Exception as e:
            log(f"[Nowfy] fillMessageMenu hook error: {str(e)}")
        try:
            if not self._unhook_process:
                ChatActivity = find_class("org.telegram.ui.ChatActivity")
                process_method = ChatActivity.getClass().getDeclaredMethod(
                    "processSelectedOption",
                    Integer.TYPE
                )
                self._unhook_process = plugin.hook_method(process_method, _ProcessOptionHook(self))
        except Exception as e:
            log(f"[Nowfy] processSelectedOption hook error: {str(e)}")

    def register_item(self, *, text: str, option_id: int, icon_res: int, condition_predicate, on_click, insert_at_top: bool):
        handle = {
            'text': text,
            'option_id': int(option_id),
            'icon_res': int(icon_res),
            'condition': condition_predicate,
            'on_click': on_click,
            'insert_top': bool(insert_at_top),
        }
        self.items.append(handle)
        return handle

    def unregister_item(self, handle):
        if handle in self.items:
            self.items.remove(handle)

    def cleanup_hooks(self, plugin):
        try:
            if self._unhook_fill:
                plugin.unhook_method(self._unhook_fill)
                self._unhook_fill = None
            if self._unhook_process:
                plugin.unhook_method(self._unhook_process)
                self._unhook_process = None
        except Exception:
            pass

class _FillMenuHook:
    def __init__(self, registry: _MessageMenuRegistry):
        self.registry = registry

    def before_hooked_method(self, param):
        pass

    def after_hooked_method(self, param):
        try:
            primary = param.args[0]
            if primary is None:
                return
            try:
                self.registry.last_message = primary
            except Exception:
                pass
            icons = param.args[1]
            items = param.args[2]
            options = param.args[3]

            for entry in list(self.registry.items):
                try:
                    if entry.get('condition') and callable(entry['condition']):
                        if not entry['condition'](primary):
                            continue
                    if entry.get('insert_top'):
                        icons.add(0, Integer(entry['icon_res']))
                        options.add(0, Integer(entry['option_id']))
                        items.add(0, entry['text'])
                    else:
                        icons.add(Integer(entry['icon_res']))
                        options.add(Integer(entry['option_id']))
                        items.add(entry['text'])
                except Exception:
                    continue
        except Exception:
            pass

class _ProcessOptionHook:
    def __init__(self, registry: _MessageMenuRegistry):
        self.registry = registry

    def before_hooked_method(self, param):
        try:
            option = param.args[0]
            try:
                opt_val = int(option)
            except Exception:
                try:
                    opt_val = option.intValue()
                except Exception:
                    return

            for entry in list(self.registry.items):
                if opt_val == entry.get('option_id'):
                    try:
                        chat_activity = param.thisObject
                        message = getattr(chat_activity, 'selectedObject', None)
                        if message is None:
                            message = getattr(self.registry, 'last_message', None)
                        try:
                            chat_activity.closeMenu()
                        except Exception:
                            pass
                        if callable(entry.get('on_click')):
                            entry['on_click'](chat_activity, message)
                        param.setResult(None)
                    except Exception:
                        pass
                    finally:
                        return
        except Exception:
            pass

    def after_hooked_method(self, param):
        pass

# Registry global
_message_menu_registry = _MessageMenuRegistry()

def _ensure_message_menu_hooks(plugin):
    _message_menu_registry.ensure_hooks(plugin)

def cleanup_message_menu_hooks(plugin):
    _message_menu_registry.cleanup_hooks(plugin)

class MessageMenuUtilities:
    def register_message_menu_item(self, *, text: str, option_id: int, icon_res: int = R.drawable.files_music, condition_predicate=None, on_click=None, insert_at_top: bool = False):
        try:
            return _message_menu_registry.register_item(
                text=text,
                option_id=option_id,
                icon_res=icon_res,
                condition_predicate=condition_predicate,
                on_click=on_click,
                insert_at_top=insert_at_top,
            )
        except Exception as e:
            log(f"[Nowfy] register_message_menu_item error: {str(e)}")
            return None

    def unregister_message_menu_item(self, handle):
        try:
            if handle:
                _message_menu_registry.unregister_item(handle)
        except Exception as e:
            log(f"[Nowfy] unregister_message_menu_item error: {str(e)}")

# Instância global
message_menu_utilities = MessageMenuUtilities()

class exteraFyPlugin(BasePlugin):
    def __init__(self):
        super().__init__()
        self._message_lock = threading.Lock()
        self._cache_lock = threading.Lock()
        self._image_cache = {}
        self._cache_timestamps = {}
        self._cache_enabled = False
        self._cache_thread = None
        self._cache_running = False
        self._cache_ttl = 300
        self._cache_max_size = 10
        self._disk_cache_dir = File(ApplicationLoader.getFilesDirFixed(), "exteraFyCache")
        if not self._disk_cache_dir.exists():
            self._disk_cache_dir.mkdirs()
        
        # --- PERFORMANCE OPTIMIZATION: Enhanced Cache System ---
        self._enhanced_image_cache = {}  # Cache otimizado para imagens processadas (298x298)
        self._base_theme_cache = {}  # Cache para imagens base dos temas
        self._performance_mode = "balanced"  # turbo, balanced, quality
        self._preload_enabled = False
        self._compression_enabled = True
        self._standard_cover_size = (298, 298)  # Tamanho padrão das capas (FIXO)
        self._last_track_id = None
        self._bio_update_thread = None
        self._stop_bio_update = False
        # Inicializar variáveis do NowCast
        self._nowcast_worker_running = False
        
        # Sistema anti-duplicatas do NowCast
        self._nowcast_last_track_hash = None
        self._nowcast_post_history = []  # Histórico dos últimos 10 posts
        self._nowcast_cooldown_time = 0  # Timestamp do último post
        self._nowcast_min_interval = 30  # Intervalo mínimo entre posts (30 segundos)
        # Aplicar estado silencioso de logs no início (comentários em português)
        try:
            val = bool(self.get_setting("disable_logs", False))
            _set_log_muted(val)
            _apply_log_wrapper(True)
        except Exception:
            pass

        # Dynamic Island overlay state
        self._di_is_active = False
        self._di_window_manager = None
        self._di_layout = None
        self._di_layout_params = None
        self._di_text_view = None
        self._di_dragging = False
        self._di_drag_start_raw_x = 0
        self._di_drag_start_raw_y = 0
        self._di_drag_start_x = 0
        self._di_drag_start_y = 0
        self._di_refresh_stop_event = None
        self._di_refresh_thread = None

        # Iniciar thread de auto-update da bio apenas se logs não estiverem desativados
        try:
            if not bool(self.get_setting("disable_logs", False)):
                self._bio_update_thread = threading.Thread(target=self._bio_update_worker, daemon=True)
                self._bio_update_thread.start()
            else:
                self._bio_update_thread = None
        except Exception:
            # fallback para não quebrar inicialização
            self._bio_update_thread = None
        self._load_external_commands()
        self._search_cache = {}

    def _load_external_commands(self):
        """Experimental: Tenta carregar o JSON de comandos externos da web, com fallback local."""
        try:
            resp = requests.get(self._external_commands_url, timeout=5)
            if resp.status_code == 200:
                self._external_commands = resp.json()
                return
        except Exception:
            pass
        # Fallback local
        try:
            with open(self._external_commands_local, "r", encoding="utf-8") as f:
                self._external_commands = json.load(f)
        except Exception:
            self._external_commands = None

    def _get_external_command(self, cmd):
        if not self._external_commands:
            self._load_external_commands()
        if self._external_commands and "commands" in self._external_commands:
            return self._external_commands["commands"].get(cmd)
        return None

    def _get_caption_template(self, style, track_data):
        """Retorna o template de caption baseado no estilo selecionado"""
        templates = {
            "Apple Based": "[🎙](5909015791088439934) *{track}*\nby *{artist}* from *{album}*\n[🔗](5256057883082107781)",
            "Pepe": "[🤘](5942984300885446067) *{track}*\nby *{artist}* from *{album}*\n[🎸](5938034540055366532)",
            "Minim": "[🎵](5258289810082111221) *Now Playing*: {track}\n*by* {artist} | {album}",
            "Spoty": "[🎵](5294137402430858861) *{track}*\nfrom *{album}* by *{artist}*"
        }
        
        if style not in templates:
            return ""
            
        template = templates[style]
        
        # Substituir placeholders pelos dados da música
        if track_data:
            template = template.replace("{track}", track_data.get("name", "Unknown Track"))
            template = template.replace("{artist}", track_data.get("artist", "Unknown Artist"))
            template = template.replace("{album}", track_data.get("album", "Unknown Album"))
        
        return template

    def _add_menu_items(self):
        try:
            # Sempre adicionar item "Nowfy" se configurado
            if self.get_setting("show_chat_menu", True):
                self.add_menu_item(MenuItemData(
                    menu_type=MenuItemType.CHAT_ACTION_MENU,
                    text=tr("Nowfy"),
                    icon="files_music",
                    priority=5,
                    on_click=lambda ctx: run_on_ui_thread(lambda: self._open_plugin_settings())
                ))
            
            # Adicionar item "Now Playing" se estiver ativado
            self._update_now_playing_chat_menu_item()
            
            # Inicializar sistema de menu de contexto
            _ensure_message_menu_hooks(self)
            self._update_now_playing_context_menu_item()

        except Exception as e:
            log(f"[exteraFy] Failed to add menu items: {e}")

    def remove_menu_items(self):
        try:
            # Remover item do menu de contexto
            self._remove_now_playing_context_menu_item()
            # Remover item do menu de chat
            if hasattr(self, 'now_playing_chat_menu_id'):
                self.remove_menu_item(self.now_playing_chat_menu_id)
                self.now_playing_chat_menu_id = None
            cleanup_message_menu_hooks(self)
        except Exception as e:
            log(f"[exteraFy] Failed to remove menu items: {e}")

    def _add_now_playing_context_menu_item(self):
        """Adiciona item Now Playing ao menu de contexto"""
        try:
            # Evita duplicatas
            if hasattr(self, 'now_playing_context_menu_id') and self.now_playing_context_menu_id:
                try:
                    self.remove_menu_item(self.now_playing_context_menu_id)
                except Exception:
                    pass
                self.now_playing_context_menu_id = None

            item_id = self.add_menu_item(MenuItemData(
                menu_type=MenuItemType.MESSAGE_CONTEXT_MENU,
                text=tr("now_playing_menu_item"),
                icon="msg_round_play_m",
                on_click=lambda ctx: run_on_ui_thread(lambda: self._send_now_playing_card())
            ))
            try:
                self.now_playing_context_menu_id = item_id
            except Exception:
                pass
        except Exception as e:
            log(f"[Nowfy] Failed to add Now Playing context menu item: {e}")

    def _remove_now_playing_context_menu_item(self):
        """Remove item Now Playing do menu de contexto"""
        try:
            if hasattr(self, 'now_playing_context_menu_id') and self.now_playing_context_menu_id:
                try:
                    self.remove_menu_item(self.now_playing_context_menu_id)
                except Exception:
                    pass
                self.now_playing_context_menu_id = None
        except Exception as e:
            log(f"[Nowfy] Failed to remove Now Playing context menu item: {e}")

    def _update_now_playing_context_menu_item(self):
        """Atualiza item Now Playing no menu de contexto baseado na configuração"""
        try:
            if self.get_setting("enable_now_playing", False):
                self._add_now_playing_context_menu_item()
            else:
                self._remove_now_playing_context_menu_item()
        except Exception as e:
            log(f"[Nowfy] Error updating Now Playing context menu item: {e}")
    
    def _update_now_playing_chat_menu_item(self):
        """Atualiza item Now Playing no menu de chat baseado na configuração"""
        try:
            # Remover item existente se houver
            if hasattr(self, 'now_playing_chat_menu_id'):
                self.remove_menu_item(self.now_playing_chat_menu_id)
                self.now_playing_chat_menu_id = None
            
            # Adicionar item se estiver ativado
            if self.get_setting("enable_now_playing", False):
                self.now_playing_chat_menu_id = self.add_menu_item(MenuItemData(
                    menu_type=MenuItemType.CHAT_ACTION_MENU,
                    text=tr("now_playing_menu_item"),
                    icon="msg_round_play_m",
                    priority=0,  # Prioridade muito baixa para aparecer no topo do menu
                    on_click=lambda ctx: run_on_ui_thread(lambda: self._send_now_playing_card())
                ))
        except Exception as e:
            log(f"[Nowfy] Error updating Now Playing chat menu item: {e}")

    def _is_service_message(self, message):
        """Verifica se é mensagem de serviço"""
        try:
            from org.telegram.tgnet import TLRPC
            return message and hasattr(message, 'messageOwner') and isinstance(message.messageOwner, TLRPC.TL_messageService)
        except Exception:
            return False
    
    def _is_failed_message(self, message):
        """Verifica se é mensagem falhada"""
        try:
            if not message or not hasattr(message, 'messageOwner') or not message.messageOwner:
                return False
            
            message_owner = message.messageOwner
            return (hasattr(message_owner, 'send_state') and message_owner.send_state == 2) or \
                   (hasattr(message_owner, 'id') and message_owner.id < 0)
        except Exception:
            return False

    def _on_now_playing_context_click(self, chat_activity, message):
        """Callback para clique no item Now Playing do menu de contexto"""
        try:
            log(f"[Nowfy] Now Playing clicked in context menu")
            self._send_now_playing_card()
        except Exception as e:
            log(f"[Nowfy] Error in Now Playing context click: {e}")
            BulletinHelper.show_info(f"Error: {e}")

    def _open_plugin_settings(self):
        try:
            log("[exteraFy] Attempting to open plugin settings...")
            controller = PluginsController.getInstance()
            log(f"[exteraFy] Controller instance: {controller}")
            plugin = controller.plugins.get(self.id)
            log(f"[exteraFy] Plugin instance: {plugin}")
            fragment = get_last_fragment()
            log(f"[exteraFy] Fragment instance: {fragment}")
            if plugin and fragment:
                try:
                    # Trigger a background version check so About shows latest status
                    self._check_version_async(False)
                except Exception:
                    pass
                fragment.presentFragment(PluginSettingsActivity(plugin))
                log("[exteraFy] Settings opened successfully")
            else:
                log(f"[exteraFy] Failed to open settings - Plugin: {plugin}, Fragment: {fragment}")
        except Exception as e:
            log(f"[exteraFy] Error opening plugin settings: {str(e)}\nType: {type(e)}")
            import traceback
            log(traceback.format_exc())

    # --- Dynamic Island overlay methods ---
    def _toggle_dynamic_island_overlay(self, enabled):
        try:
            self.set_setting("dynamic_island_overlay", bool(enabled))
            # Atualizar item do menu lateral 'Pop Island'
            try:
                if bool(enabled):
                    self._ensure_pop_island_drawer_item()
                else:
                    self._remove_pop_island_drawer_item()
            except Exception:
                pass
            if bool(enabled):
                try:
                    # Se preferir, mostrar bulletin com botão ao ativar
                    if bool(self.get_setting("overlay_activation_bulletin_enabled", False)):
                        try:
                            from org.telegram.messenger import R as R_tg
                            fragment = get_last_fragment()
                        except Exception:
                            R_tg = None
                            fragment = get_last_fragment()
                        def _activate_island():
                            try:
                                self._safe_start_dynamic_island_overlay()
                            except Exception:
                                self._start_dynamic_island_overlay()
                        try:
                            BulletinHelper.show_with_button(
                                tr("pop_island_title") if "pop_island_title" in TRANSLATIONS else "Floatify",
                                R_tg.raw.chats_infotip if R_tg else 0,
                                tr("overlay_enable_bulletin_action") if "overlay_enable_bulletin_action" in TRANSLATIONS else "Show now",
                                _activate_island,
                                fragment
                            )
                        except Exception:
                            # Fallback: iniciar imediatamente se bulletin falhar
                            self._safe_start_dynamic_island_overlay()
                    else:
                        self._safe_start_dynamic_island_overlay()
                except Exception:
                    self._safe_start_dynamic_island_overlay()
                # Mostrar Mini Controls conforme preferência do usuário, sem mudar o switch
                try:
                    enabled_mc = bool(self.get_setting('mini_control_enabled', False))
                    self._toggle_mini_control(enabled_mc, persist=False)
                except Exception:
                    pass
            else:
                # Ocultar Mini Controls na interface quando a Pop Island está desligada
                try:
                    self._toggle_mini_control(False, persist=False)
                except Exception:
                    pass
                self._stop_dynamic_island_overlay()
        except Exception as e:
            log(f"[Nowfy] Dynamic Island toggle error: {e}")

    def _toggle_mini_control(self, enabled, persist=True):
        try:
            # Persistir a preferência só quando acionado pelo switch nas configurações
            if bool(persist):
                self.set_setting("mini_control_enabled", bool(enabled))
            # Atualiza visibilidade do container de Mini Controls se já existir
            try:
                mc = getattr(self, "_di_mini_controls", None)
                if mc is not None:
                    mc.setVisibility(0 if bool(enabled) else 8)
                    # Sincronizar visibilidade do botão Send com o estado do Mini Controls
                    try:
                        btn_send = getattr(self, "_di_btn_send", None)
                        if btn_send is not None:
                            if bool(enabled):
                                send_enabled = bool(self.get_setting("send_button_enabled", False))
                                btn_send.setVisibility(0 if send_enabled else 8)
                            else:
                                btn_send.setVisibility(8)
                    except Exception:
                        pass
                    
                    # Atualizar bordas do frame baseado no novo estado do Mini Control
                    try:
                        self._update_frame_corners()
                    except Exception:
                        pass
            except Exception:
                pass
        except Exception as e:
            log(f"[Nowfy] Mini Control toggle error: {e}")

    def _update_frame_corners(self):
        """Atualiza as bordas do frame baseado no estado do Mini Control"""
        try:
            frame = getattr(self, "_di_frame", None)
            if not frame:
                return
            
            from hook_utils import find_class
            GradientDrawable = find_class("android.graphics.drawable.GradientDrawable")
            AndroidUtilities = find_class("org.telegram.messenger.AndroidUtilities")
            
            if not GradientDrawable:
                return
            
            # Obter o background atual ou criar novo
            bg = frame.getBackground()
            if not bg or not isinstance(bg, GradientDrawable):
                bg = GradientDrawable()
                bg.setShape(GradientDrawable.RECTANGLE)
                bg.setColor(0xEE151515)
                try:
                    bg.setStroke(0, 0)
                except Exception:
                    pass
            
            # Calcular raio
            try:
                radius = AndroidUtilities.dp(22) if AndroidUtilities else 66
            except Exception:
                radius = 66
            
            # Aplicar bordas baseadas no Mini Control
            try:
                mini_control_enabled = bool(self.get_setting("mini_control_enabled", False))
                
                if mini_control_enabled:
                    # Borda inferior reta, superiores arredondadas
                    radii = [
                        float(radius), float(radius),  # top-left
                        float(radius), float(radius),  # top-right
                        0.0, 0.0,                      # bottom-right (reto)
                        0.0, 0.0                       # bottom-left (reto)
                    ]
                    bg.setCornerRadii(radii)
                    log("[Nowfy] Updated corners: straight bottom (Mini Control active)")
                else:
                    # Todas as bordas arredondadas
                    radii = [float(radius)] * 8
                    bg.setCornerRadii(radii)
                    log("[Nowfy] Updated corners: all rounded (Mini Control inactive)")
                
                # Aplicar o background atualizado
                frame.setBackground(bg)
                
            except Exception as e:
                log(f"[Nowfy] Error updating frame corners: {e}")
                # Fallback
                bg.setCornerRadius(float(radius))
                frame.setBackground(bg)
                
        except Exception as e:
            log(f"[Nowfy] Error in _update_frame_corners: {e}")

    def _toggle_send_button(self, enabled, persist=True):
        try:
            if bool(persist):
                self.set_setting("send_button_enabled", bool(enabled))
            try:
                btn = getattr(self, "_di_btn_send", None)
                if btn is not None:
                    btn.setVisibility(0 if bool(enabled) else 8)
            except Exception:
                pass
        except Exception as e:
            log(f"[Nowfy] Send button toggle error: {e}")

    def _toggle_search_button(self, enabled, persist=True):
        try:
            if bool(persist):
                self.set_setting("search_button_enabled", bool(enabled))
            try:
                btn = getattr(self, "_di_btn_search", None)
                if btn is not None:
                    btn.setVisibility(0 if bool(enabled) else 8)
            except Exception:
                pass
        except Exception as e:
            log(f"[Nowfy] Search button toggle error: {e}")

    def _create_dynamic_island_view(self, ctx):
        try:
            root = LinearLayout(ctx)
            root.setOrientation(LinearLayout.VERTICAL)
            try:
                root.setGravity(Gravity.CENTER_HORIZONTAL)
            except Exception:
                pass
            
            # Garantir que root não tenha background que possa criar áreas cinzas
            try:
                root.setBackground(None)
            except Exception:
                pass

            # Import seguro do GradientDrawable e ViewOutlineProvider
            GradientDrawable = None
            try:
                from android.graphics.drawable import GradientDrawable as _GD
                GradientDrawable = _GD
            except Exception:
                try:
                    from hook_utils import find_class
                    GradientDrawable = find_class("android.graphics.drawable.GradientDrawable")
                except Exception:
                    GradientDrawable = None
            try:
                from android.view import ViewOutlineProvider as _VOP
                VOP = _VOP
            except Exception:
                try:
                    from hook_utils import find_class
                    VOP = find_class("android.view.ViewOutlineProvider")
                except Exception:
                    VOP = None
            # Import seguro de Color (para fallback de cor sólida)
            Color = None
            try:
                from android.graphics import Color as _Color
                Color = _Color
            except Exception:
                try:
                    from hook_utils import find_class
                    Color = find_class("android.graphics.Color")
                except Exception:
                    Color = None

            # O root não terá fundo próprio; aplicaremos o fundo pill diretamente no frame
            # para garantir visibilidade e evitar conflitos.
            


            frame = FrameLayout(ctx)
            self._di_frame = frame
            try:
                padding = AndroidUtilities.dp(12)
            except Exception:
                dm_pad = ctx.getResources().getDisplayMetrics()
                padding = int(dm_pad.density * 12)
            # Ajustar padding baseado no Island Style para evitar áreas cinzas
            try:
                island_style = int(self.get_setting("island_styles_selector", 0))
                if island_style == 1 or island_style == 3:  # BG Cover ou No Blur
                    # Padding adaptável para BG Cover e No Blur - menor para textos curtos
                    base_side_padding = AndroidUtilities.dp(8) if AndroidUtilities else int(ctx.getResources().getDisplayMetrics().density * 8)
                    
                    # Tentar obter largura do texto para ajustar padding
                    try:
                        title_view = getattr(self, "_di_title_view", None)
                        if title_view:
                            title_view.measure(0, 0)
                            text_width = title_view.getMeasuredWidth()
                            
                            # Ajustar padding baseado na largura do texto
                            if text_width < AndroidUtilities.dp(100):  # Texto muito curto
                                side_padding = AndroidUtilities.dp(12) if AndroidUtilities else int(ctx.getResources().getDisplayMetrics().density * 12)
                            elif text_width < AndroidUtilities.dp(150):  # Texto curto
                                side_padding = AndroidUtilities.dp(10) if AndroidUtilities else int(ctx.getResources().getDisplayMetrics().density * 10)
                            else:  # Texto normal/longo
                                side_padding = base_side_padding
                        else:
                            side_padding = base_side_padding
                    except Exception:
                        side_padding = base_side_padding
                    
                    frame.setPadding(side_padding, padding, side_padding, padding)
                    log(f"[Nowfy] BG Cover/No Blur: Applied adaptive padding {side_padding}dp")
                elif island_style == 2:  # Pure
                    # Padding mínimo para Pure
                    pure_padding = AndroidUtilities.dp(4) if AndroidUtilities else int(ctx.getResources().getDisplayMetrics().density * 4)
                    frame.setPadding(pure_padding, pure_padding, pure_padding, pure_padding)
                else:
                    # Padding normal para Default
                    frame.setPadding(padding, padding, padding, padding)
            except Exception:
                frame.setPadding(padding, padding, padding, padding)
            # Garantir que filhos não ultrapassem o contêiner visual (pill)
            try:
                frame.setClipChildren(True)
                frame.setClipToPadding(True)
            except Exception:
                pass
            try:
                root.addView(frame)
            except Exception:
                root.addView(frame)

            # Fundo estilo "ilha" com cantos arredondados aplicado no FRAME
            try:
                bg = GradientDrawable() if GradientDrawable else None
                if bg:
                    bg.setShape(GradientDrawable.RECTANGLE)
                    try:
                        # Raio base para cantos arredondados
                        radius = AndroidUtilities.dp(22)
                    except Exception:
                        radius = int(ctx.getResources().getDisplayMetrics().density * 22)
                    
                    try:
                        # Bordas inteligentes baseadas no Mini Control
                        mini_control_enabled = bool(self.get_setting("mini_control_enabled", False))
                        
                        if mini_control_enabled:
                            # Mini Control ativo: borda inferior reta, superiores arredondadas
                            radii = [
                                float(radius), float(radius),  # top-left
                                float(radius), float(radius),  # top-right
                                0.0, 0.0,                      # bottom-right (reto)
                                0.0, 0.0                       # bottom-left (reto)
                            ]
                            bg.setCornerRadii(radii)
                            log("[Nowfy] Applied smart corners: rounded top, straight bottom (Mini Control active)")
                        else:
                            # Mini Control desativo: todas as bordas arredondadas
                            radii = [float(radius)] * 8
                            bg.setCornerRadii(radii)
                            log("[Nowfy] Applied smart corners: all rounded (Mini Control inactive)")
                            
                    except Exception:
                        # Fallback: todas arredondadas
                        bg.setCornerRadius(float(radius))
                    bg.setColor(0xEE151515)
                    try:
                        bg.setStroke(0, 0)
                    except Exception:
                        pass
                    frame.setBackground(bg)
                    self._di_frame_bg = bg
                    try:
                        if VOP: frame.setOutlineProvider(VOP.BACKGROUND)
                    except Exception:
                        pass
                    try:
                        frame.setClipToOutline(True)
                    except Exception:
                        pass
                    # Ajustar raio para metade da altura do frame
                    try:
                        from hook_utils import find_class
                        OGL = find_class("android.view.ViewTreeObserver$OnGlobalLayoutListener")
                    except Exception:
                        OGL = None
                    try:
                        if OGL is not None:
                            class _Layout(dynamic_proxy(OGL)):
                                def onGlobalLayout(self2):
                                    try:
                                        h = int(frame.getHeight())
                                        if h > 0 and getattr(self, '_di_frame_bg', None):
                                            try:
                                                r = float(int(h / 2))
                                                self._di_frame_bg.setCornerRadius(r)
                                                frame.setBackground(self._di_frame_bg)
                                            except Exception:
                                                pass
                                        try:
                                            frame.getViewTreeObserver().removeOnGlobalLayoutListener(self2)
                                        except Exception:
                                            pass
                                    except Exception:
                                        pass
                            frame.getViewTreeObserver().addOnGlobalLayoutListener(_Layout())
                    except Exception:
                        pass
                else:
                    # Fallback: cor sólida quando GradientDrawable não está disponível
                    try:
                        if Color:
                            frame.setBackgroundColor(Color.argb(235, 20, 20, 20))
                        else:
                            frame.setBackgroundColor(0xEE151515)
                    except Exception:
                        frame.setBackgroundColor(0xEE151515)
            except Exception:
                try:
                    if Color:
                        frame.setBackgroundColor(Color.argb(235, 20, 20, 20))
                    else:
                        frame.setBackgroundColor(0xEE151515)
                except Exception:
                    frame.setBackgroundColor(0xEE151515)

            # Conteúdo: capa à esquerda, textos à direita
            content = LinearLayout(ctx)
            self._di_content = content
            content.setOrientation(LinearLayout.HORIZONTAL)
            content.setGravity(Gravity.CENTER_VERTICAL)
            # A ilha deve ter um único fundo arredondado (pill) aplicado no frame.
            # Removemos o fundo do content para evitar borda interna quadrada.
            try:
                content.setBackground(None)
            except Exception:
                pass

            # Adicionar conteúdo ao frame (sem fundo/banner)
            frame.addView(content)



            # Capa da música (esquerda) com import seguro
            ImageViewCls = None
            try:
                from android.widget import ImageView as _ImageView
                ImageViewCls = _ImageView
            except Exception:
                try:
                    from hook_utils import find_class
                    ImageViewCls = find_class("android.widget.ImageView")
                except Exception:
                    ImageViewCls = None
            self._di_cover = ImageViewCls(ctx) if ImageViewCls else None
            try:
                # Aplicar Pop Size à capa
                size_idx = self.get_setting("pop_size_selector", 2)  # Padrão Medium
                size_multipliers = {
                    0: 0.7,   # Tiny
                    1: 0.85,  # Small  
                    2: 1.0,   # Medium (padrão)
                    3: 1.2    # Large
                }
                size_factor = size_multipliers.get(size_idx, 1.0)
                base_size = int(52 * size_factor)
                
                cover_size = AndroidUtilities.dp(base_size)
                margin_right = AndroidUtilities.dp(12)
            except Exception:
                dm = ctx.getResources().getDisplayMetrics()
                cover_size = int(dm.density * 52)
                margin_right = int(dm.density * 12)
            cover_lp = LinearLayout.LayoutParams(cover_size, cover_size)
            cover_lp.rightMargin = margin_right
            try:
                if self._di_cover:
                    try:
                        cover_bg = GradientDrawable() if GradientDrawable else None
                        if cover_bg:
                            cover_bg.setShape(GradientDrawable.RECTANGLE)
                            try:
                                cover_bg.setColor(Color.parseColor("#000000"))
                            except Exception:
                                try:
                                    from hook_utils import find_class
                                    ColorCls = find_class("android.graphics.Color")
                                    if ColorCls:
                                        cover_bg.setColor(ColorCls.parseColor("#000000"))
                                except Exception:
                                    pass
                            try:
                                style_idx = 0
                                try:
                                    style_idx = int(self.get_setting("pop_style_selector", 0))
                                except Exception:
                                    style_idx = 0
                                if style_idx == 1:
                                    try:
                                        radius = float(int(cover_size / 2))
                                    except Exception:
                                        try:
                                            radius = float(AndroidUtilities.dp(26))
                                        except Exception:
                                            dm3 = ctx.getResources().getDisplayMetrics()
                                            radius = float(int(dm3.density * 26))
                                else:
                                    try:
                                        radius = float(AndroidUtilities.dp(10))
                                    except Exception:
                                        dm3 = ctx.getResources().getDisplayMetrics()
                                        radius = float(int(dm3.density * 10))
                                cover_bg.setCornerRadius(radius)
                            except Exception:
                                try:
                                    dm3 = ctx.getResources().getDisplayMetrics()
                                    cover_bg.setCornerRadius(float(int(dm3.density * 10)))
                                except Exception:
                                    pass
                            try:
                                self._di_cover.setBackground(cover_bg)
                            except Exception:
                                pass
                            try:
                                if VOP and hasattr(self._di_cover, "setOutlineProvider"):
                                    self._di_cover.setOutlineProvider(VOP.BACKGROUND)
                            except Exception:
                                pass
                            try:
                                self._di_cover.setClipToOutline(True)
                            except Exception:
                                pass
                            try:
                                # Ajustar raio para círculo perfeito após medir, se estilo circular
                                style_idx = int(self.get_setting("pop_style_selector", 0))
                                if style_idx == 1:
                                    from hook_utils import find_class
                                    OGL = find_class("android.view.ViewTreeObserver$OnGlobalLayoutListener")
                                    if OGL is not None:
                                        class _CoverLayout(dynamic_proxy(OGL)):
                                            def onGlobalLayout(self2):
                                                try:
                                                    h = int(self._di_cover.getHeight())
                                                    w = int(self._di_cover.getWidth())
                                                    if h > 0 and w > 0:
                                                        r = float(int(min(h, w) / 2))
                                                        cover_bg.setCornerRadius(r)
                                                        try:
                                                            self._di_cover.setBackground(cover_bg)
                                                        except Exception:
                                                            pass
                                                    try:
                                                        self._di_cover.getViewTreeObserver().removeOnGlobalLayoutListener(self2)
                                                    except Exception:
                                                        pass
                                                except Exception:
                                                    pass
                                        self._di_cover.getViewTreeObserver().addOnGlobalLayoutListener(_CoverLayout())
                            except Exception:
                                pass
                    except Exception:
                        pass
            except Exception:
                pass
            if self._di_cover:
                content.addView(self._di_cover, cover_lp)
            else:
                # Placeholder quando ImageView não está disponível
                try:
                    placeholder = TextView(ctx)
                    placeholder.setText("♪")
                    placeholder.setTextColor(Color.WHITE if Color else 0xFFFFFFFF)
                    placeholder.setTextSize(1, 16.0)
                    placeholder_lp = LinearLayout.LayoutParams(cover_size, cover_size)
                    placeholder_lp.rightMargin = margin_right
                    content.addView(placeholder, placeholder_lp)
                except Exception:
                    pass

            # Container da pílula minimizada com visual real de pílula
            try:
                self._di_pill_container = LinearLayout(ctx)
                self._di_pill_container.setOrientation(LinearLayout.HORIZONTAL)
                self._di_pill_container.setGravity(Gravity.CENTER_VERTICAL)
                self._di_pill_container.setVisibility(8)  # Inicialmente oculta
                
                # Criar fundo de pílula bem visível
                try:
                    from android.graphics.drawable import GradientDrawable
                    pill_bg = GradientDrawable()
                    pill_bg.setShape(GradientDrawable.RECTANGLE)
                    pill_bg.setColor(0xFF000000)  # Preto sólido para ser bem visível
                    
                    # Raio bem arredondado para parecer pílula (metade da altura)
                    pill_radius = AndroidUtilities.dp(18) if AndroidUtilities else int(ctx.getResources().getDisplayMetrics().density * 18)
                    pill_bg.setCornerRadius(float(pill_radius))
                    
                    # Adicionar borda branca para definir melhor
                    try:
                        pill_bg.setStroke(
                            AndroidUtilities.dp(1) if AndroidUtilities else int(ctx.getResources().getDisplayMetrics().density * 1),
                            0x66FFFFFF  # Branco semi-transparente
                        )
                    except Exception:
                        pass
                    
                    self._di_pill_container.setBackground(pill_bg)
                except Exception:
                    pass
                
                # Padding interno da pílula
                try:
                    pill_padding = AndroidUtilities.dp(8) if AndroidUtilities else int(ctx.getResources().getDisplayMetrics().density * 8)
                    self._di_pill_container.setPadding(pill_padding, pill_padding//2, pill_padding, pill_padding//2)
                except Exception:
                    pass
                
                # Adicionar ao content normal
                content.addView(self._di_pill_container)
            except Exception:
                self._di_pill_container = None
            
            # Adicionar elementos à pílula: Capa + Espaço + Ondas
            self._di_wave_bars = []
            self._di_wave_animators = []
            self._di_pill_cover = None
            
            if self._di_pill_container:
                try:
                    # 1. Capa da música (lado esquerdo)
                    try:
                        from android.widget import ImageView
                        self._di_pill_cover = ImageView(ctx)
                        
                        # Tamanho da capa na pílula
                        cover_size = AndroidUtilities.dp(24) if AndroidUtilities else int(ctx.getResources().getDisplayMetrics().density * 24)
                        cover_lp = LinearLayout.LayoutParams(cover_size, cover_size)
                        
                        # Fazer a capa redonda
                        try:
                            from android.graphics.drawable import GradientDrawable
                            cover_bg = GradientDrawable()
                            cover_bg.setShape(GradientDrawable.RECTANGLE)
                            cover_bg.setColor(0x00000000)  # Transparente
                            cover_bg.setCornerRadius(float(cover_size // 2))  # Circular
                            self._di_pill_cover.setBackground(cover_bg)
                            self._di_pill_cover.setClipToOutline(True)
                        except Exception:
                            pass
                        
                        self._di_pill_container.addView(self._di_pill_cover, cover_lp)
                    except Exception:
                        pass
                    
                    # 2. Espaço para o notch (meio)
                    try:
                        spacer = View(ctx)
                        spacer_width = AndroidUtilities.dp(16) if AndroidUtilities else int(ctx.getResources().getDisplayMetrics().density * 16)
                        spacer_lp = LinearLayout.LayoutParams(spacer_width, AndroidUtilities.dp(4) if AndroidUtilities else int(ctx.getResources().getDisplayMetrics().density * 4))
                        spacer_lp.leftMargin = AndroidUtilities.dp(8) if AndroidUtilities else int(ctx.getResources().getDisplayMetrics().density * 8)
                        spacer_lp.rightMargin = AndroidUtilities.dp(8) if AndroidUtilities else int(ctx.getResources().getDisplayMetrics().density * 8)
                        self._di_pill_container.addView(spacer, spacer_lp)
                    except Exception:
                        pass
                    
                    # 3. Container das ondas (lado direito)
                    try:
                        wave_container = LinearLayout(ctx)
                        wave_container.setOrientation(LinearLayout.HORIZONTAL)
                        wave_container.setGravity(Gravity.CENTER_VERTICAL)
                        
                        bar_w = AndroidUtilities.dp(2) if AndroidUtilities else int(ctx.getResources().getDisplayMetrics().density * 2)
                        bar_h = AndroidUtilities.dp(12) if AndroidUtilities else int(ctx.getResources().getDisplayMetrics().density * 12)
                        bar_gap = AndroidUtilities.dp(2) if AndroidUtilities else int(ctx.getResources().getDisplayMetrics().density * 2)
                        
                        # 5 barras para as ondas
                        for i in range(5):
                            try:
                                bar = View(ctx)
                                bar.setBackgroundColor(0xFFFFFFFF)
                                blp = LinearLayout.LayoutParams(bar_w, bar_h)
                                if i > 0:
                                    blp.leftMargin = bar_gap
                                wave_container.addView(bar, blp)
                                self._di_wave_bars.append(bar)
                            except Exception:
                                pass
                        
                        # Adicionar container de ondas à pílula
                        wave_lp = LinearLayout.LayoutParams(
                            LinearLayout.LayoutParams.WRAP_CONTENT,
                            LinearLayout.LayoutParams.WRAP_CONTENT
                        )
                        self._di_pill_container.addView(wave_container, wave_lp)
                        
                    except Exception:
                        pass
                        
                except Exception:
                    pass
            # Funções para animar/pausar barras da pílula (versão simplificada)
            def _start_wave_animation():
                try:
                    from hook_utils import find_class
                    ObjectAnimator = find_class("android.animation.ObjectAnimator")
                    ValueAnimator = find_class("android.animation.ValueAnimator")
                except Exception:
                    ObjectAnimator = None
                    ValueAnimator = None
                
                self._di_wave_animators = []
                try:
                    bars = list(self._di_wave_bars or [])
                except Exception:
                    bars = []
                
                for idx, bar in enumerate(bars):
                    try:
                        def _set_pivot(b=bar):
                            try:
                                b.setPivotY(float(b.getHeight()))
                            except Exception:
                                pass
                        
                        try:
                            bar.post(_set_pivot)
                        except Exception:
                            _set_pivot()
                        
                        if ObjectAnimator:
                            try:
                                # Animação mais simples
                                anim = ObjectAnimator.ofFloat(bar, "scaleY", 0.6, 1.3)
                                anim.setDuration(650 + (idx * 90))
                                
                                if ValueAnimator:
                                    try:
                                        anim.setRepeatMode(getattr(ValueAnimator, "REVERSE", 2))
                                        anim.setRepeatCount(getattr(ValueAnimator, "INFINITE", -1))
                                    except Exception:
                                        pass
                                
                                anim.start()
                                self._di_wave_animators.append(anim)
                            except Exception:
                                pass
                    except Exception:
                        pass
            def _stop_wave_animation():
                try:
                    for a in list(getattr(self, "_di_wave_animators", [])):
                        try:
                            a.cancel()
                        except Exception:
                            pass
                except Exception:
                    pass
                self._di_wave_animators = []
                
                # Resetar escala das barras para estado normal
                try:
                    bars = list(getattr(self, '_di_wave_bars', []))
                    for bar in bars:
                        try:
                            bar.setScaleY(1.0)
                        except Exception:
                            pass
                except Exception:
                    pass
            self._di_start_wave_anim = _start_wave_animation
            self._di_stop_wave_anim = _stop_wave_animation

            # Informações (direita)
            info = LinearLayout(ctx)
            info.setOrientation(LinearLayout.VERTICAL)
            # info deve ocupar o espaço disponível; controles vão à direita
            lp_info = LinearLayout.LayoutParams(0, -2)
            try:
                lp_info.weight = 1.0
            except Exception:
                pass
            content.addView(info, lp_info)

            self._di_title_view = TextView(ctx)
            self._di_title_view.setTextColor(Color.WHITE if Color else 0xFFFFFFFF)
            self._di_title_view.setTextSize(1, 16.0)
            try:
                self._di_title_view.setSingleLine(True)
                self._di_title_view.setMaxLines(1)
                # Limite de largura para não alargar a ilha
                try:
                    from hook_utils import find_class
                    AndroidUtilities = find_class("org.telegram.messenger.AndroidUtilities")
                    if AndroidUtilities:
                        self._di_title_view.setMaxWidth(AndroidUtilities.dp(240))
                except Exception:
                    pass
                # Ellipsize END por padrão; ativa marquee apenas quando realmente cortar
                try:
                    from android.text import TextUtils as _TextUtils
                    self._di_title_view.setEllipsize(_TextUtils.TruncateAt.END)
                except Exception:
                    try:
                        from hook_utils import find_class
                        _TU = find_class("android.text.TextUtils")
                        if _TU and getattr(_TU, 'TruncateAt', None):
                            self._di_title_view.setEllipsize(_TU.TruncateAt.END)
                    except Exception:
                        pass
                try:
                    self._di_title_view.setMarqueeRepeatLimit(-1)
                except Exception:
                    pass
                try:
                    # Desativa rolagem horizontal por padrão; ativa sob demanda
                    self._di_title_view.setHorizontallyScrolling(False)
                except Exception:
                    pass
                try:
                    # Não precisa estar 'selected' até ativar marquee
                    self._di_title_view.setSelected(False)
                except Exception:
                    pass
                try:
                    self._di_title_view.setFocusable(True)
                    self._di_title_view.setFocusableInTouchMode(True)
                except Exception:
                    pass
            except Exception:
                pass
            try:
                from android.graphics import Typeface as _TF
                if _TF and hasattr(self._di_title_view, "setTypeface"):
                    self._di_title_view.setTypeface(_TF.DEFAULT_BOLD)
            except Exception:
                try:
                    from hook_utils import find_class
                    TFCls = find_class("android.graphics.Typeface")
                    if TFCls and hasattr(self._di_title_view, "setTypeface"):
                        self._di_title_view.setTypeface(TFCls.DEFAULT_BOLD)
                except Exception:
                    pass
            info.addView(self._di_title_view)

            self._di_artist_view = TextView(ctx)
            try:
                self._di_artist_view.setTextColor(Color.parseColor("#CCFFFFFF"))
            except Exception:
                try:
                    from hook_utils import find_class
                    ColorCls = find_class("android.graphics.Color")
                    if ColorCls:
                        self._di_artist_view.setTextColor(ColorCls.parseColor("#CCFFFFFF"))
                except Exception:
                    self._di_artist_view.setTextColor(Color.argb(204, 255, 255, 255))
            self._di_artist_view.setTextSize(1, 13.0)
            try:
                self._di_artist_view.setSingleLine(True)
                self._di_artist_view.setMaxLines(1)
            except Exception:
                pass
            info.addView(self._di_artist_view)

            # Limites de largura para evitar que a ilha toque a borda da tela
            try:
                dm = ctx.getResources().getDisplayMetrics()
                screen_w = int(dm.widthPixels)
            except Exception:
                screen_w = 1080

            # Margem de segurança nas laterais (a ilha nunca encosta na borda)
            try:
                safe_margin = AndroidUtilities.dp(16)
            except Exception:
                safe_margin = int(ctx.getResources().getDisplayMetrics().density * 16)

            # Paddings reais do frame (pill)
            try:
                fp_l = int(getattr(frame, "getPaddingLeft", lambda: 12)())
                fp_r = int(getattr(frame, "getPaddingRight", lambda: 12)())
            except Exception:
                try:
                    fp_l = AndroidUtilities.dp(12)
                    fp_r = AndroidUtilities.dp(12)
                except Exception:
                    dmf = ctx.getResources().getDisplayMetrics()
                    fp_l = int(dmf.density * 12)
                    fp_r = int(dmf.density * 12)

            # Dimensões dos demais elementos (estimadas/constantes do layout)
            try:
                cover_px = int(cover_size)
            except Exception:
                try:
                    cover_px = AndroidUtilities.dp(52)
                except Exception:
                    cover_px = int(ctx.getResources().getDisplayMetrics().density * 52)
            try:
                mr_px = int(margin_right)
            except Exception:
                try:
                    mr_px = AndroidUtilities.dp(12)
                except Exception:
                    mr_px = int(ctx.getResources().getDisplayMetrics().density * 12)
            try:
                base_pad_px = AndroidUtilities.dp(12)
            except Exception:
                base_pad_px = int(ctx.getResources().getDisplayMetrics().density * 12)
            try:
                col_w_px = AndroidUtilities.dp(40)
                col_margin_px = AndroidUtilities.dp(6)
            except Exception:
                dm3 = ctx.getResources().getDisplayMetrics()
                col_w_px = int(dm3.density * 40)
                col_margin_px = int(dm3.density * 6)

            # Reserva horizontal: frame + conteúdo + capa + coluna de controles
            reserved = fp_l + fp_r + (base_pad_px * 2) + col_w_px + col_margin_px + cover_px + mr_px

            # Largura máxima do texto para que a ilha jamais ultrapasse o limite
            max_text_width = screen_w - (safe_margin * 2) - reserved
            # Clampe mínimo para evitar valores negativos
            try:
                min_text = AndroidUtilities.dp(96)
            except Exception:
                min_text = int(ctx.getResources().getDisplayMetrics().density * 96)
            if max_text_width < min_text:
                max_text_width = min_text

            try:
                self._di_title_view.setMaxWidth(max_text_width)
            except Exception:
                pass
            try:
                self._di_artist_view.setMaxWidth(max_text_width)
            except Exception:
                pass

            # Mini Controls (abaixo da ilha)
            try:
                mini_controls = LinearLayout(ctx)
                mini_controls.setOrientation(LinearLayout.HORIZONTAL)
                try:
                    mini_controls.setGravity(Gravity.CENTER_HORIZONTAL)
                except Exception:
                    pass
                
                # Aplicar backdrop blur ao mini control para ocultar texto atrás
                try:
                    self._apply_mini_control_backdrop_blur(mini_controls, ctx)
                except Exception as e:
                    log(f"[Nowfy] Mini Control: Error applying backdrop blur: {e}")
                    # Fallback: background opaco
                    try:
                        from hook_utils import find_class
                        GradientDrawable = find_class("android.graphics.drawable.GradientDrawable")
                        if GradientDrawable:
                            bg = GradientDrawable()
                            bg.setShape(GradientDrawable.RECTANGLE)
                            bg.setColor(0xF0151515)  # Fundo opaco para ocultar texto
                            radius = AndroidUtilities.dp(18) if AndroidUtilities else 18
                            bg.setCornerRadius(float(radius))
                            mini_controls.setBackground(bg)
                        else:
                            mini_controls.setBackgroundColor(0xF0151515)
                    except Exception:
                        mini_controls.setBackground(None)
                try:
                    pad_mc = AndroidUtilities.dp(8)
                    gap_mc = AndroidUtilities.dp(10)
                    size = AndroidUtilities.dp(36)
                except Exception:
                    dm_mc = ctx.getResources().getDisplayMetrics()
                    d_mc = dm_mc.density
                    pad_mc = int(d_mc * 8)
                    gap_mc = int(d_mc * 10)
                    size = int(d_mc * 36)
                mini_controls.setPadding(0, pad_mc, 0, pad_mc)  # Remover padding lateral para eliminar áreas cinzas

                icons = self._di_icon_sources()
                BACK_URL = icons.get("back", {}).get("primary")
                PLAY_URL = icons.get("play", {}).get("primary")
                PAUSE_URL = icons.get("pause", {}).get("primary")
                NEXT_URL = icons.get("next", {}).get("primary")
                SEND_URL = icons.get("send", {}).get("primary")
                SEARCH_URL = icons.get("search", {}).get("primary")
                try:
                    self._di_icon_fallbacks = {
                        BACK_URL: icons.get("back", {}).get("fallback"),
                        PLAY_URL: icons.get("play", {}).get("fallback"),
                        PAUSE_URL: icons.get("pause", {}).get("fallback"),
                        NEXT_URL: icons.get("next", {}).get("fallback"),
                        SEND_URL: icons.get("send", {}).get("fallback"),
                    }
                except Exception:
                    pass

                # Utilitários de cache e prefetch de ícones
                def _di_cache_dir():
                    return self._di_cache_dir()

                def _di_guess_name(u):
                    try:
                        from urllib.parse import urlparse, parse_qs
                        qs = parse_qs(urlparse(u).query)
                        name = (qs.get("filename") or qs.get("file") or [None])[0]
                        if name:
                            return name
                        import os
                        base = os.path.basename(urlparse(u).path) or "icon"
                        if "." not in base:
                            base += ".png"
                        return base
                    except Exception:
                        return "icon.png"

                def _di_prefetch_icon(u):
                    try:
                        import os, requests
                        cache_dir = self._di_cache_dir()
                        if not cache_dir:
                            return
                        fname = _di_guess_name(u)
                        dest = os.path.join(cache_dir, fname)
                        # Pular se já existe
                        try:
                            if os.path.exists(dest) and os.path.getsize(dest) > 64:
                                return
                        except Exception:
                            pass
                        s = requests.Session()
                        try:
                            s.headers.update({
                                "User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) Nowfy/DI",
                                "Accept": "image/avif,image/webp,image/apng,image/*,*/*;q=0.8",
                                "Connection": "keep-alive",
                                "Referer": "https://disk.yandex.com",
                            })
                        except Exception:
                            pass
                        fb_map = getattr(self, "_di_icon_fallbacks", None)
                        alt_u = fb_map.get(u) if isinstance(fb_map, dict) and u in fb_map else u
                        for try_u in (u, alt_u):
                            try:
                                resp = s.get(try_u, timeout=(5, 10))
                                ct = str(resp.headers.get("Content-Type", ""))
                                if resp.status_code == 200 and resp.content and (("image" in ct) or len(resp.content) > 64):
                                    with open(dest, "wb") as f:
                                        f.write(resp.content)
                                    return
                            except Exception:
                                continue
                    except Exception:
                        pass

                # Pré-baixar ícones principais em background
                try:
                    import threading
                    for u in (BACK_URL, PLAY_URL, PAUSE_URL, NEXT_URL, SEND_URL, SEARCH_URL):
                        threading.Thread(target=lambda url=u: _di_prefetch_icon(url), daemon=True).start()
                except Exception:
                    pass

                def _set_image(iv, url, alt=None):
                    try:
                        import threading
                        def _load():
                            try:
                                import requests, time
                                s = requests.Session()
                                try:
                                    s.headers.update({
                                        "User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) Nowfy/DI",
                                        "Accept": "image/avif,image/webp,image/apng,image/*,*/*;q=0.8",
                                        "Connection": "keep-alive",
                                        "Referer": "https://disk.yandex.com",
                                    })
                                except Exception:
                                    pass
                                attempts = 3
                                data = None
                                bmp = None
                                local_path = None
                                try:
                                    import os
                                    def _guess_name(u):
                                        try:
                                            from urllib.parse import urlparse, parse_qs
                                            qs = parse_qs(urlparse(u).query)
                                            name = (qs.get("filename") or qs.get("file") or [None])[0]
                                            if name: return name
                                            base = os.path.basename(urlparse(u).path) or "icon"
                                            if "." not in base: base += ".png"
                                            return base
                                        except Exception:
                                            return "icon.png"
                                    cache_dir = self._di_cache_dir()
                                    fname = _guess_name(url)
                                    local_path = os.path.join(cache_dir, fname)
                                except Exception:
                                    local_path = None
                                try:
                                    from hook_utils import find_class
                                    BitmapFactory = find_class("android.graphics.BitmapFactory")
                                except Exception:
                                    BitmapFactory = None
                                # Try local cache first
                                if BitmapFactory is not None and local_path:
                                    try:
                                        bmp = BitmapFactory.decodeFile(local_path)
                                    except Exception:
                                        bmp = None
                                if bmp is None:
                                    alt_url = url
                                    # Prefer explicit alt when provided, else use known fallbacks
                                    if alt:
                                        alt_url = alt
                                    else:
                                        try:
                                            fb_map = getattr(self, "_di_icon_fallbacks", None)
                                            if isinstance(fb_map, dict) and url in fb_map:
                                                alt_url = fb_map[url]
                                            elif "/refs/heads/" in url:
                                                alt_url = url.replace("/refs/heads/", "/")
                                        except Exception:
                                            try:
                                                if "/refs/heads/" in url:
                                                    alt_url = url.replace("/refs/heads/", "/")
                                            except Exception:
                                                alt_url = url
                                    last_exc = None
                                    for i in range(attempts):
                                        try:
                                            use_url = url if i < 2 else alt_url
                                            resp = s.get(use_url, timeout=(5, 10))
                                            ct = str(resp.headers.get("Content-Type", ""))
                                            if resp.status_code == 200 and resp.content and (("image" in ct) or len(resp.content) > 64):
                                                data = resp.content
                                                break
                                        except Exception as ie:
                                            last_exc = ie
                                        time.sleep(0.4 * (i + 1))
                                    if data and BitmapFactory is not None:
                                        try:
                                            bmp = BitmapFactory.decodeByteArray(data, 0, len(data))
                                        except Exception:
                                            bmp = None
                                        # Persist cache
                                        try:
                                            if local_path and data:
                                                with open(local_path, "wb") as f:
                                                    f.write(data)
                                        except Exception:
                                            pass
                                def _apply():
                                    try:
                                        if bmp and hasattr(iv, "setImageBitmap"):
                                            iv.setImageBitmap(bmp)
                                    except Exception:
                                        pass
                                try:
                                    from android_utils import run_on_ui_thread
                                    run_on_ui_thread(_apply)
                                except Exception:
                                    _apply()
                            except Exception:
                                pass
                        threading.Thread(target=_load, daemon=True).start()
                    except Exception:
                        pass

                def _make_round_text_button(text, text_size):
                    """Cria botão redondo com texto/emoji"""
                    try:
                        tv = TextView(ctx)
                        tv.setText(text)
                        tv.setTextSize(text_size)
                        tv.setGravity(Gravity.CENTER if Gravity else 17)
                        
                        # Cor do texto (branco translúcido)
                        try:
                            tv.setTextColor(0xCCFFFFFF)  # Branco com 80% opacidade
                        except Exception:
                            pass
                        
                        lp = LinearLayout.LayoutParams(size, size)
                        
                        # Fundo redondo
                        try:
                            bg = GradientDrawable() if GradientDrawable else None
                            if bg:
                                bg.setShape(GradientDrawable.RECTANGLE)
                                bg.setCornerRadius(float(int(size/2)))
                                bg.setColor(0x22FFFFFF)  # Fundo translúcido
                                try:
                                    bg.setStroke(AndroidUtilities.dp(1), 0x55FFFFFF)  # Borda sutil
                                except Exception:
                                    pass
                                tv.setBackground(bg)
                        except Exception:
                            pass
                        
                        try:
                            tv.setClickable(True)
                            tv.setFocusable(True)
                        except Exception:
                            pass
                        
                        return tv, lp
                        
                    except Exception as e:
                        log(f"[Nowfy] Error creating text button: {e}")
                        # Fallback: criar TextView simples
                        tv = TextView(ctx)
                        tv.setText(text)
                        lp = LinearLayout.LayoutParams(size, size)
                        return tv, lp

                def _make_round_image_button(icon_url):
                    iv = None
                    try:
                        from android.widget import ImageView as _ImageView
                        iv = _ImageView(ctx)
                        try:
                            iv.setAdjustViewBounds(True)
                        except Exception:
                            pass
                        try:
                            st = getattr(_ImageView, "ScaleType", None)
                            if st and getattr(st, "CENTER_INSIDE", None):
                                iv.setScaleType(st.CENTER_INSIDE)
                        except Exception:
                            pass
                    except Exception:
                        try:
                            from hook_utils import find_class
                            IV = find_class("android.widget.ImageView")
                            if IV:
                                iv = IV(ctx)
                        except Exception:
                            iv = None
                    if iv is None:
                        iv = TextView(ctx)
                    lp = LinearLayout.LayoutParams(size, size)
                    try:
                        style_idx = 0
                        try:
                            style_idx = int(self.get_setting("control_style_selector", 0) or 0)
                        except Exception:
                            style_idx = 0
                        if style_idx == 3:
                            try:
                                iv.setBackground(None)
                            except Exception:
                                pass
                        else:
                            bg = GradientDrawable() if GradientDrawable else None
                            if bg:
                                bg.setShape(GradientDrawable.RECTANGLE)
                                bg.setCornerRadius(float(int(size/2)))
                                bg.setColor(0x22FFFFFF)
                                try:
                                    bg.setStroke(AndroidUtilities.dp(1), 0x55FFFFFF)
                                except Exception:
                                    pass
                                iv.setBackground(bg)
                    except Exception:
                        pass
                    try:
                        iv.setClickable(True)
                        iv.setFocusable(True)
                    except Exception:
                        pass
                    _set_image(iv, icon_url)
                    return iv, lp

                # Helper robusto para aplicar ícone (prioriza cache local)
                def _di_apply_icon(ivv, urlv):
                    try:
                        import os
                        cache_dir = self._di_cache_dir()
                        fname = _di_guess_name(urlv)
                        local_path = os.path.join(cache_dir, fname) if cache_dir else None
                        bmp = None
                        try:
                            from hook_utils import find_class
                            BitmapFactory = find_class("android.graphics.BitmapFactory")
                        except Exception:
                            BitmapFactory = None
                        if BitmapFactory is not None and local_path:
                            try:
                                bmp = BitmapFactory.decodeFile(local_path)
                            except Exception:
                                bmp = None
                        if bmp is not None:
                            def _apply_local():
                                try:
                                    if hasattr(ivv, "setImageBitmap"):
                                        ivv.setImageBitmap(bmp)
                                except Exception:
                                    pass
                            try:
                                from android_utils import run_on_ui_thread
                                run_on_ui_thread(_apply_local)
                            except Exception:
                                _apply_local()
                        else:
                            try:
                                fb_map = getattr(self, "_di_icon_fallbacks", None)
                                alt_v = fb_map.get(urlv) if isinstance(fb_map, dict) and urlv in fb_map else None
                            except Exception:
                                alt_v = None
                            _set_image(ivv, urlv, alt=alt_v)
                    except Exception:
                        _set_image(ivv, urlv)
                try:
                    self._di_apply_icon = _di_apply_icon
                except Exception:
                    pass

                # Inicializar botões com ícones
                btn_prev, lp_prev = _make_round_image_button(BACK_URL)
                # play/pause conforme estado atual
                try:
                    is_playing = bool(self._check_music_playing())
                except Exception:
                    is_playing = False
                initial_pp_url = PAUSE_URL if is_playing else PLAY_URL
                btn_pp, lp_pp = _make_round_image_button(initial_pp_url)
                # aplicar novamente via cache local para garantir PLAY
                try:
                    _di_apply_icon(btn_pp, initial_pp_url)
                except Exception:
                    pass
                btn_next, lp_next = _make_round_image_button(NEXT_URL)

                # Margens realmente simétricas para eliminar áreas cinzas
                try:
                    # Usar gap menor e simétrico para todos os botões
                    small_gap = gap_mc // 2  # Metade do gap original
                    
                    lp_prev.leftMargin = small_gap
                    lp_prev.rightMargin = small_gap
                    lp_pp.leftMargin = small_gap
                    lp_pp.rightMargin = small_gap
                    lp_next.leftMargin = small_gap
                    lp_next.rightMargin = small_gap
                except Exception:
                    pass

                mini_controls.addView(btn_prev, lp_prev)
                mini_controls.addView(btn_pp, lp_pp)
                mini_controls.addView(btn_next, lp_next)
                # Botão Send
                btn_send, lp_send = _make_round_image_button(SEND_URL)
                try:
                    # Usar a mesma margem simétrica do Send
                    small_gap = gap_mc // 2
                    lp_send.leftMargin = small_gap
                    lp_send.rightMargin = small_gap
                except Exception:
                    pass
                mini_controls.addView(btn_send, lp_send)
                
                # Botão Search (Pesquisar) - usando sistema de ícones
                icons = self._di_icon_sources()
                SEARCH_URL = icons.get("search", {}).get("primary")
                if SEARCH_URL:
                    btn_search, lp_search = _make_round_image_button(SEARCH_URL)
                else:
                    btn_search, lp_search = _make_round_text_button("S", 16)
                try:
                    # Usar a mesma margem simétrica
                    small_gap = gap_mc // 2
                    lp_search.leftMargin = small_gap
                    lp_search.rightMargin = small_gap
                except Exception:
                    pass
                mini_controls.addView(btn_search, lp_search)

                self._di_btn_prev = btn_prev
                self._di_btn_pp = btn_pp
                self._di_btn_next = btn_next
                self._di_btn_send = btn_send
                self._di_btn_search = btn_search
                self._di_mini_controls = mini_controls
                self._di_play_url = PLAY_URL
                self._di_pause_url = PAUSE_URL
                self._di_set_image = _set_image
                try:
                    enabled = bool(self.get_setting("mini_control_enabled", False))
                    mini_controls.setVisibility(0 if enabled else 8)
                    send_enabled = bool(self.get_setting("send_button_enabled", False))
                    btn_send.setVisibility(0 if send_enabled else 8)
                    search_enabled = bool(self.get_setting("search_button_enabled", False))
                    btn_search.setVisibility(0 if search_enabled else 8)
                except Exception:
                    pass
                except Exception:
                    pass
                try:
                    lp_mc = LinearLayout.LayoutParams(-1, -2)
                    lp_mc.gravity = Gravity.CENTER_HORIZONTAL
                    
                    # Eliminar áreas cinzas ajustando margin baseado no estilo
                    try:
                        island_style = int(self.get_setting("island_styles_selector", 0))
                        if island_style == 1 or island_style == 3:  # BG Cover ou No Blur - margin negativo para colar
                            lp_mc.topMargin = AndroidUtilities.dp(-6) if AndroidUtilities else -18
                        elif island_style == 2:  # Pure - margin negativo para colar também
                            lp_mc.topMargin = AndroidUtilities.dp(-8) if AndroidUtilities else -24
                        else:  # Default - margin normal
                            lp_mc.topMargin = AndroidUtilities.dp(-2) if AndroidUtilities else -6
                    except Exception:
                        lp_mc.topMargin = AndroidUtilities.dp(-2) if AndroidUtilities else -6
                    
                    root.addView(mini_controls, lp_mc)
                except Exception:
                    root.addView(mini_controls)
            except Exception:
                pass

            # Controles (coluna direita): minimizar e fechar, um abaixo do outro
            controls = LinearLayout(ctx)
            controls.setOrientation(LinearLayout.VERTICAL)
            try:
                controls.setGravity(Gravity.CENTER_VERTICAL)
            except Exception:
                pass
            try:
                pad = AndroidUtilities.dp(4)
                btn_radius = AndroidUtilities.dp(6)
                margin = AndroidUtilities.dp(6)
                col_w = AndroidUtilities.dp(40)
            except Exception:
                dm = ctx.getResources().getDisplayMetrics()
                d = dm.density
                pad = int(d * 4)
                btn_radius = int(d * 6)
                margin = int(d * 6)
                col_w = int(d * 40)
            controls.setPadding(0, 0, 0, 0)

            def _make_icon_button(url):
                # Cria um botão como ImageView e carrega ícone da URL, sem bordas
                iv = None
                try:
                    from android.widget import ImageView as _ImageView
                    iv = _ImageView(ctx)
                    try:
                        iv.setAdjustViewBounds(True)
                    except Exception:
                        pass
                    try:
                        st = getattr(_ImageView, "ScaleType", None)
                        if st and getattr(st, "CENTER_INSIDE", None):
                            iv.setScaleType(st.CENTER_INSIDE)
                    except Exception:
                        pass
                except Exception:
                    try:
                        from hook_utils import find_class
                        IV = find_class("android.widget.ImageView")
                        if IV:
                            iv = IV(ctx)
                    except Exception:
                        iv = None
                if iv is None:
                    # Fallback mínimo para evitar quebra
                    iv = TextView(ctx)
                try:
                    iv.setBackground(None)
                except Exception:
                    pass
                try:
                    iv.setPadding(pad, pad, pad, pad)
                except Exception:
                    pass
                try:
                    iv.setClickable(True)
                    iv.setFocusable(True)
                except Exception:
                    pass
                # Carrega o ícone assincronamente
                try:
                    import threading
                    def _load():
                        try:
                            import requests, time
                            s = requests.Session()
                            try:
                                s.headers.update({
                                    "User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) Nowfy/DI",
                                    "Accept": "image/avif,image/webp,image/apng,image/*,*/*;q=0.8",
                                    "Connection": "keep-alive",
                                    "Referer": "https://disk.yandex.com",
                                })
                            except Exception:
                                pass
                            attempts = 3
                            data = None
                            bmp = None
                            local_path = None
                            try:
                                import os
                                def _guess_name(u):
                                    try:
                                        from urllib.parse import urlparse, parse_qs
                                        qs = parse_qs(urlparse(u).query)
                                        name = (qs.get("filename") or qs.get("file") or [None])[0]
                                        if name: return name
                                        base = os.path.basename(urlparse(u).path) or "icon"
                                        if "." not in base: base += ".png"
                                        return base
                                    except Exception:
                                        return "icon.png"
                                cache_dir = self._di_cache_dir()
                                fname = _guess_name(url)
                                local_path = os.path.join(cache_dir, fname)
                            except Exception:
                                local_path = None
                            try:
                                from hook_utils import find_class
                                BitmapFactory = find_class("android.graphics.BitmapFactory")
                            except Exception:
                                BitmapFactory = None
                            if BitmapFactory is not None and local_path:
                                try:
                                    bmp = BitmapFactory.decodeFile(local_path)
                                except Exception:
                                    bmp = None
                            if bmp is None:
                                alt_url = url
                                try:
                                    fb_map = getattr(self, "_di_icon_fallbacks", None)
                                    if isinstance(fb_map, dict) and url in fb_map:
                                        alt_url = fb_map[url]
                                    elif "/refs/heads/" in url:
                                        alt_url = url.replace("/refs/heads/", "/")
                                except Exception:
                                    try:
                                        if "/refs/heads/" in url:
                                            alt_url = url.replace("/refs/heads/", "/")
                                    except Exception:
                                        alt_url = url
                                last_exc = None
                                for i in range(attempts):
                                    try:
                                        use_url = url if i < 2 else alt_url
                                        resp = s.get(use_url, timeout=(5, 10))
                                        ct = str(resp.headers.get("Content-Type", ""))
                                        if resp.status_code == 200 and resp.content and (("image" in ct) or len(resp.content) > 64):
                                            data = resp.content
                                            break
                                    except Exception as ie:
                                        last_exc = ie
                                    time.sleep(0.4 * (i + 1))
                                if data and BitmapFactory is not None:
                                    try:
                                        bmp = BitmapFactory.decodeByteArray(data, 0, len(data))
                                    except Exception:
                                        bmp = None
                                    try:
                                        if local_path and data:
                                            with open(local_path, "wb") as f:
                                                f.write(data)
                                    except Exception:
                                        pass
                            def _apply():
                                try:
                                    if bmp and hasattr(iv, "setImageBitmap"):
                                        iv.setImageBitmap(bmp)
                                except Exception:
                                    pass
                            try:
                                from android_utils import run_on_ui_thread
                                run_on_ui_thread(_apply)
                            except Exception:
                                _apply()
                        except Exception:
                            pass
                    threading.Thread(target=_load, daemon=True).start()
                except Exception:
                    pass
                return iv

            # Ícones dos botões
            MINI_URL = "https://i.postimg.cc/y8QHJzyz/mini.png"
            CLOSE_URL = "https://i.postimg.cc/nhRJstY6/close.png"
            try:
                fb_map = getattr(self, "_di_icon_fallbacks", None)
                if isinstance(fb_map, dict):
                    fb_map[MINI_URL] = "https://i.postimg.cc/y8QHJzyz/mini.png"
                    fb_map[CLOSE_URL] = "https://i.postimg.cc/nhRJstY6/close.png"
            except Exception:
                pass
            # Pré-baixar minimizar/fechar em background
            try:
                import threading
                for u in (MINI_URL, CLOSE_URL):
                    threading.Thread(target=lambda url=u: _di_prefetch_icon(url), daemon=True).start()
            except Exception:
                pass
            btn_min = _make_icon_button(MINI_URL)
            btn_close = _make_icon_button(CLOSE_URL)
            try:
                if hasattr(btn_min, "setAlpha"):
                    btn_min.setAlpha(0.85)
                if hasattr(btn_close, "setAlpha"):
                    btn_close.setAlpha(0.85)
            except Exception:
                pass

            # Cada botão ocupa metade da coluna (altura) com espaçamento sutil
            lp_btn_min = LinearLayout.LayoutParams(-1, 0)
            lp_btn_close = LinearLayout.LayoutParams(-1, 0)
            try:
                lp_btn_min.weight = 1.0
                lp_btn_close.weight = 1.0
            except Exception:
                pass
            # margem sutil entre botões
            try:
                gap_px = AndroidUtilities.dp(4)
            except Exception:
                gap_px = int(ctx.getResources().getDisplayMetrics().density * 4)
            try:
                lp_btn_min.bottomMargin = gap_px
                lp_btn_close.topMargin = gap_px
            except Exception:
                pass
            controls.addView(btn_min, lp_btn_min)
            controls.addView(btn_close, lp_btn_close)

            # Adicionar coluna de controles à direita, altura igual à ilha
            try:
                lp_controls = FrameLayout.LayoutParams(col_w, -1)
                lp_controls.gravity = Gravity.END
                lp_controls.rightMargin = margin
            except Exception:
                lp_controls = FrameLayout.LayoutParams(col_w, -1)
            frame.addView(controls, lp_controls)

            # Garantir que o conteúdo não fique sob a coluna (padding à direita)
            try:
                base_pad = AndroidUtilities.dp(12)
            except Exception:
                base_pad = int(ctx.getResources().getDisplayMetrics().density * 12)
            try:
                content.setPadding(base_pad, base_pad, base_pad + col_w + margin, base_pad)
            except Exception:
                pass

            # Lógica de minimizar/restaurar
            self._di_minimized = False
            def _toggle_minimize(_):
                try:
                    self._di_minimized = not bool(self._di_minimized)
                    
                    if self._di_minimized:
                        # MODO PÍLULA: Ocultar TUDO e mostrar só a pílula
                        try:
                            # Ocultar todos os elementos normais
                            info.setVisibility(8)
                            controls.setVisibility(8)
                            self._di_cover.setVisibility(8)
                            
                            # Mostrar e configurar pílula
                            if getattr(self, '_di_pill_container', None):
                                self._di_pill_container.setVisibility(0)
                                
                                # Sincronizar capa da pílula
                                if hasattr(self, '_di_pill_cover') and self._di_pill_cover and hasattr(self, '_di_cover') and self._di_cover:
                                    try:
                                        main_drawable = self._di_cover.getDrawable()
                                        if main_drawable:
                                            self._di_pill_cover.setImageDrawable(main_drawable)
                                            # Aplicar CENTER_CROP
                                            try:
                                                from hook_utils import find_class
                                                ImageViewCls = find_class("android.widget.ImageView")
                                                st = getattr(ImageViewCls, "ScaleType", None) if ImageViewCls else None
                                                if st and hasattr(self._di_pill_cover, "setScaleType") and getattr(st, "CENTER_CROP", None):
                                                    self._di_pill_cover.setScaleType(st.CENTER_CROP)
                                            except Exception:
                                                pass
                                    except Exception:
                                        pass
                        except Exception:
                            pass
                    else:
                        # MODO NORMAL: Mostrar elementos normais e ocultar pílula
                        try:
                            # Mostrar elementos normais
                            info.setVisibility(0)
                            controls.setVisibility(0)
                            self._di_cover.setVisibility(0)
                            
                            # Ocultar pílula
                            if getattr(self, '_di_pill_container', None):
                                self._di_pill_container.setVisibility(8)
                        except Exception:
                            pass
                    # Iniciar/pausar animação de barras conforme estado e reprodução
                    try:
                        playing_now = False
                        try:
                            playing_now = bool(self._check_music_playing())
                        except Exception:
                            playing_now = False
                        if bool(self._di_minimized):
                            if playing_now and getattr(self, '_di_start_wave_anim', None):
                                self._di_start_wave_anim()
                            elif getattr(self, '_di_stop_wave_anim', None):
                                self._di_stop_wave_anim()
                        else:
                            if getattr(self, '_di_stop_wave_anim', None):
                                self._di_stop_wave_anim()
                    except Exception:
                        pass
                    # Always on Top não interfere no movimento durante o uso
                    
                    # Garantir que o Pop Size seja aplicado corretamente sempre
                    try:
                        self._apply_pop_style_to_overlay()
                    except Exception:
                        pass
                    
                    # Garantir que o Island Style seja aplicado corretamente sempre
                    try:
                        self._apply_island_style_to_overlay()
                    except Exception:
                        pass
                    # Capa sempre visível e sem margem à direita no modo compacto
                    try:
                        if self._di_cover:
                            self._di_cover.setVisibility(0)
                            lp_cov = self._di_cover.getLayoutParams()
                            try:
                                if self._di_minimized:
                                    lp_cov.rightMargin = 0
                                else:
                                    # restaurar a margem padrão da capa
                                    if 'margin_right' in locals():
                                        lp_cov.rightMargin = margin_right
                                    else:
                                        try:
                                            lp_cov.rightMargin = AndroidUtilities.dp(12)
                                        except Exception:
                                            lp_cov.rightMargin = int(ctx.getResources().getDisplayMetrics().density * 12)
                            except Exception:
                                pass
                            # Ajuste de escala para preencher melhor sem distorcer
                            try:
                                from hook_utils import find_class
                                ImageViewCls = find_class("android.widget.ImageView")
                                st = getattr(ImageViewCls, "ScaleType", None) if ImageViewCls else None
                                if st and hasattr(self._di_cover, "setScaleType") and getattr(st, "CENTER_CROP", None):
                                    self._di_cover.setScaleType(st.CENTER_CROP)
                            except Exception:
                                try:
                                    # Fallback comum
                                    from android.widget import ImageView as _IV
                                    st = getattr(_IV, "ScaleType", None)
                                    if st and hasattr(self._di_cover, "setScaleType") and getattr(st, "CENTER_CROP", None):
                                        self._di_cover.setScaleType(st.CENTER_CROP)
                                except Exception:
                                    pass
                            try:
                                self._di_cover.setAdjustViewBounds(True)
                            except Exception:
                                pass
                            # Ajustar dimensões do frame para formato de pílula
                            try:
                                if self._di_minimized:
                                    # Forçar dimensões de pílula no frame
                                    def _apply_pill_dimensions():
                                        try:
                                            # Não redimensionar durante arraste
                                            if getattr(self, '_di_dragging', False):
                                                return
                                                
                                            frame_lp = frame.getLayoutParams()
                                            if frame_lp:
                                                # Pílula: bem larga e baixa
                                                pill_width = AndroidUtilities.dp(140) if AndroidUtilities else int(ctx.getResources().getDisplayMetrics().density * 140)
                                                pill_height = AndroidUtilities.dp(36) if AndroidUtilities else int(ctx.getResources().getDisplayMetrics().density * 36)
                                                frame_lp.width = pill_width
                                                frame_lp.height = pill_height
                                                frame.setLayoutParams(frame_lp)
                                                
                                                # Forçar padding mínimo para pílula
                                                frame.setPadding(4, 4, 4, 4)
                                        except Exception:
                                            pass
                                    
                                    # Aplicar imediatamente e com delay (se não estiver arrastando)
                                    if not getattr(self, '_di_dragging', False):
                                        _apply_pill_dimensions()
                                        try:
                                            frame.post(_apply_pill_dimensions)
                                        except Exception:
                                            pass
                                        
                                else:
                                    # Restaurar dimensões normais (não durante arraste)
                                    try:
                                        if not getattr(self, '_di_dragging', False):
                                            frame_lp = frame.getLayoutParams()
                                            if frame_lp:
                                                frame_lp.width = LinearLayout.LayoutParams.WRAP_CONTENT
                                                frame_lp.height = LinearLayout.LayoutParams.WRAP_CONTENT
                                                frame.setLayoutParams(frame_lp)
                                    except Exception:
                                        pass
                            except Exception:
                                pass
                    except Exception:
                        pass
                    # Ajustar padding simples
                    try:
                        p_content = AndroidUtilities.dp(4 if self._di_minimized else 12)
                        p_frame = AndroidUtilities.dp(6 if self._di_minimized else 12)
                    except Exception:
                        dm2 = ctx.getResources().getDisplayMetrics()
                        p_content = int(dm2.density * (4 if self._di_minimized else 12))
                        p_frame = int(dm2.density * (6 if self._di_minimized else 12))
                    
                    try:
                        if self._di_minimized:
                            frame.setPadding(p_frame, p_frame, p_frame, p_frame)
                            content.setPadding(p_content, p_content, p_content, p_content)
                            content.setGravity(Gravity.CENTER)
                        else:
                            frame.setPadding(p_frame, p_frame, p_frame, p_frame)
                            content.setPadding(p_content, p_content, p_content + col_w + margin, p_content)
                            content.setGravity(Gravity.CENTER_VERTICAL)
                    except Exception:
                        pass

                    # Enforce square frame when minimized and sync cover radius
                    try:
                        if self._di_minimized:
                            # Compute square dimension: cover + content/frame paddings
                            try:
                                lp_cov2 = self._di_cover.getLayoutParams()
                                cover_w = int(getattr(lp_cov2, 'width', 0))
                                cover_h = int(getattr(lp_cov2, 'height', 0))
                            except Exception:
                                cover_w = 0
                                cover_h = 0
                            cover_side = cover_w if cover_w > 0 else (cover_h if cover_h > 0 else 0)
                            if cover_side <= 0:
                                try:
                                    cover_side = int(AndroidUtilities.dp(80))
                                except Exception:
                                    cover_side = int(ctx.getResources().getDisplayMetrics().density * 80)
                            square = int(cover_side + (p_content * 2) + (p_frame * 2))
                            try:
                                # Não redimensionar durante arraste
                                if not getattr(self, '_di_dragging', False):
                                    flp = frame.getLayoutParams()
                                    flp.width = int(square)
                                    flp.height = int(square)
                                    frame.setLayoutParams(flp)
                            except Exception:
                                pass
                            # Sync cover corner to island radius (circle)
                            try:
                                cbg = getattr(self._di_cover, 'getBackground', lambda: None)()
                                if cbg is not None:
                                    try:
                                        r = float(int(square / 2))
                                    except Exception:
                                        r = float(int(cover_side / 2))
                                    try:
                                        cbg.setCornerRadius(r)
                                        self._di_cover.setBackground(cbg)
                                    except Exception:
                                        pass
                            except Exception:
                                pass
                        else:
                            # Restore wrap_content on expand (não durante arraste)
                            try:
                                if not getattr(self, '_di_dragging', False):
                                    flp = frame.getLayoutParams()
                                    flp.width = -2
                                    flp.height = -2
                                    frame.setLayoutParams(flp)
                            except Exception:
                                pass
                            # Restore cover corner radius to default when expanded (non-circular)
                            try:
                                style_idx2 = int(self.get_setting('pop_style_selector', 0))
                            except Exception:
                                style_idx2 = 0
                            try:
                                cbg2 = getattr(self._di_cover, 'getBackground', lambda: None)()
                                if cbg2 is not None and style_idx2 != 1:
                                    try:
                                        rdef = int(AndroidUtilities.dp(10))
                                    except Exception:
                                        rdef = int(ctx.getResources().getDisplayMetrics().density * 10)
                                    try:
                                        cbg2.setCornerRadius(float(rdef))
                                        self._di_cover.setBackground(cbg2)
                                    except Exception:
                                        pass
                            except Exception:
                                pass
                    except Exception:
                        pass

                    # Estilo Circular: tornar a ilha minimizada um círculo (esconder fundo do frame)
                    try:
                        style_idx = int(self.get_setting("pop_style_selector", 0))
                    except Exception:
                        style_idx = 0
                    try:
                        if getattr(self, '_di_frame_bg', None):
                            if style_idx == 1:
                                if self._di_minimized:
                                    try:
                                        # Fundo transparente para evitar o bloco arredondado
                                        self._di_frame_bg.setColor(0x00000000)
                                        self._di_frame_bg.setStroke(0, 0)
                                    except Exception:
                                        pass
                                else:
                                    try:
                                        # Restaurar fundo padrão quando expandido
                                        self._di_frame_bg.setColor(0xEE151515)
                                        from hook_utils import find_class
                                        AndroidUtilities2 = find_class("org.telegram.messenger.AndroidUtilities")
                                        sw = AndroidUtilities2.dp(1) if AndroidUtilities2 else 1
                                        self._di_frame_bg.setStroke(0, 0)
                                    except Exception:
                                        pass
                                try:
                                    frame.setBackground(self._di_frame_bg)
                                except Exception:
                                    pass
                    except Exception:
                        pass

                    # Reaplicar estilo da capa para garantir círculo após redimensionar
                    try:
                        self._apply_pop_style_to_overlay()
                    except Exception:
                        pass
                    # Ajustar gravidade do container no FrameLayout para centralizar quando compacto
                    try:
                        if getattr(self, '_di_content', None):
                            clp = self._di_content.getLayoutParams()
                            try:
                                from android.view import Gravity as _G
                                center_g = _G.CENTER
                                normal_g = (_G.START | _G.CENTER_VERTICAL)
                            except Exception:
                                center_g = Gravity.CENTER
                                normal_g = (Gravity.START | Gravity.CENTER_VERTICAL)
                            clp.gravity = center_g if self._di_minimized else normal_g
                            try:
                                self._di_content.setLayoutParams(clp)
                            except Exception:
                                pass
                    except Exception:
                        pass
                    # Atualizar intensidade do blur conforme estado (8dp minimizado; 14dp expandido)
                    try:
                        from hook_utils import find_class
                        BuildVersion = find_class("android.os.Build$VERSION")
                        AndroidUtilities = find_class("org.telegram.messenger.AndroidUtilities")
                        sdk = int(getattr(BuildVersion, "SDK_INT", 0)) if BuildVersion else 0
                        lp = getattr(self, "_di_layout_params", None)
                        if sdk >= 31 and lp is not None:
                            try:
                                # Raio bem arredondado para pílula (metade da altura) e normal para expandida
                                radius_dp = 16 if self._di_minimized else 14
                                radius_px = int(AndroidUtilities.dp(radius_dp)) if AndroidUtilities else int(radius_dp)
                            except Exception:
                                radius_px = 16 if self._di_minimized else 14
                            try:
                                if hasattr(lp, "setBlurBehindRadius"):
                                    lp.setBlurBehindRadius(int(radius_px))
                                elif hasattr(lp, "blurBehindRadius"):
                                    try:
                                        setattr(lp, "blurBehindRadius", int(radius_px))
                                    except Exception:
                                        pass
                            except Exception:
                                pass
                    except Exception:
                        pass
                    # Forçar re-medição apenas se não estiver arrastando
                    try:
                        # Evitar requestLayout durante arraste para prevenir redimensionamento
                        if not getattr(self, '_di_dragging', False):
                            if getattr(self, '_di_window_manager', None) and getattr(self, '_di_layout', None) and getattr(self, '_di_layout_params', None):
                                self._di_window_manager.updateViewLayout(self._di_layout, self._di_layout_params)
                    except Exception:
                        try:
                            # Só fazer requestLayout se não estiver arrastando
                            if not getattr(self, '_di_dragging', False) and getattr(self, '_di_layout', None):
                                self._di_layout.requestLayout()
                        except Exception:
                            pass
                    # Atualiza visibilidade dos Mini Controls conforme estado
                    try:
                        mc = getattr(self, '_di_mini_controls', None)
                        if mc is not None:
                            if bool(getattr(self, '_di_minimized', False)):
                                mc.setVisibility(8)
                            else:
                                enabled = bool(self.get_setting('mini_control_enabled', False))
                                mc.setVisibility(0 if enabled else 8)
                    except Exception:
                        pass
                except Exception:
                    pass

            def _close(_):
                try:
                    self._di_closed_by_user = True
                    self._stop_dynamic_island_overlay()
                except Exception:
                    pass

            def _toggle_play_pause(_):
                try:
                    playing = bool(self._check_music_playing())
                    if playing:
                        self._pause_playback_only(None)
                        try:
                            if getattr(self, "_di_btn_pp", None) and getattr(self, "_di_apply_icon", None) and getattr(self, "_di_play_url", None):
                                self._di_apply_icon(self._di_btn_pp, self._di_play_url)
                        except Exception:
                            pass
                        # Parar animação das barras ao pausar quando minimizada
                        try:
                            if bool(getattr(self, "_di_minimized", False)) and getattr(self, "_di_stop_wave_anim", None):
                                self._di_stop_wave_anim()
                        except Exception:
                            pass
                    else:
                        self._resume_playback_only(None)
                        try:
                            if getattr(self, "_di_btn_pp", None) and getattr(self, "_di_apply_icon", None) and getattr(self, "_di_pause_url", None):
                                self._di_apply_icon(self._di_btn_pp, self._di_pause_url)
                        except Exception:
                            pass
                        # Iniciar animação das barras ao tocar quando minimizada
                        try:
                            if bool(getattr(self, "_di_minimized", False)) and getattr(self, "_di_start_wave_anim", None):
                                self._di_start_wave_anim()
                        except Exception:
                            pass
                except Exception:
                    pass

            # Vincular cliques com proxy seguro
            try:
                from hook_utils import find_class
                OnClickListenerCls = find_class("android.view.View$OnClickListener")
            except Exception:
                OnClickListenerCls = None
            if OnClickListenerCls is not None:
                # Háptico opcional + guarda contra cliques duplicados
                def _maybe_haptic(v):
                    try:
                        if not bool(self.get_setting("di_haptic_enabled", False)):
                            return
                        try:
                            HFC = find_class("android.view.HapticFeedbackConstants")
                        except Exception:
                            HFC = None
                        try:
                            if hasattr(v, "performHapticFeedback"):
                                const = None
                                try:
                                    const = HFC.KEYBOARD_TAP if HFC and hasattr(HFC, "KEYBOARD_TAP") else (HFC.VIRTUAL_KEY if HFC and hasattr(HFC, "VIRTUAL_KEY") else None)
                                except Exception:
                                    const = None
                                try:
                                    v.performHapticFeedback(const if const is not None else 1)
                                    return
                                except Exception:
                                    pass
                        except Exception:
                            pass
                        try:
                            Context = find_class("android.content.Context")
                            Vibrator = find_class("android.os.Vibrator")
                            ctx2 = v.getContext() if hasattr(v, "getContext") else ctx
                            service = ctx2.getSystemService("vibrator") if ctx2 else None
                            if service and hasattr(service, "vibrate"):
                                try:
                                    service.vibrate(20)
                                except Exception:
                                    pass
                        except Exception:
                            pass
                    except Exception:
                        pass
                def _should_skip_click():
                    try:
                        import time
                        now = int(time.time()*1000)
                        last = int(getattr(self, "_di_last_click_ms", 0))
                        if now - last < 250:
                            return True
                        self._di_last_click_ms = now
                        return False
                    except Exception:
                        return False
                class _Click(dynamic_proxy(OnClickListenerCls)):
                    def __init__(self, fn):
                        super().__init__()
                        self._fn = fn
                    def onClick(self, v):
                        try:
                            if _should_skip_click():
                                return
                            _maybe_haptic(v)
                            self._fn(v)
                        except Exception:
                            pass
                btn_min.setOnClickListener(_Click(_toggle_minimize))
                btn_close.setOnClickListener(_Click(_close))
                try:
                    if getattr(self, "_di_btn_prev", None):
                        self._di_btn_prev.setOnClickListener(_Click(lambda v: self._previous_track(None)))
                    if getattr(self, "_di_btn_pp", None):
                        self._di_btn_pp.setOnClickListener(_Click(_toggle_play_pause))
                    if getattr(self, "_di_btn_next", None):
                        self._di_btn_next.setOnClickListener(_Click(lambda v: self._skip_track(None)))
                    if getattr(self, "_di_btn_send", None):
                        self._di_btn_send.setOnClickListener(_Click(lambda v: self._send_now_playing_card(True)))
                    if getattr(self, "_di_btn_search", None):
                        self._di_btn_search.setOnClickListener(_Click(lambda v: self._show_spotify_search_dialog()))
                except Exception:
                    pass
                try:
                    # Clique na capa restaura apenas se estiver minimizada
                    def _maybe_restore(_):
                        try:
                            if bool(getattr(self, '_di_minimized', False)):
                                _toggle_minimize(_)
                        except Exception:
                            pass
                    if self._di_cover:
                        self._di_cover.setOnClickListener(_Click(_maybe_restore))
                except Exception:
                    pass
            else:
                try:
                    from android_utils import OnClickListener
                    # Háptico opcional + guarda contra cliques duplicados
                    def _maybe_haptic(v):
                        try:
                            if not bool(self.get_setting("di_haptic_enabled", False)):
                                return
                            try:
                                from hook_utils import find_class
                                HFC = find_class("android.view.HapticFeedbackConstants")
                            except Exception:
                                HFC = None
                            try:
                                if hasattr(v, "performHapticFeedback"):
                                    const = None
                                    try:
                                        const = HFC.KEYBOARD_TAP if HFC and hasattr(HFC, "KEYBOARD_TAP") else (HFC.VIRTUAL_KEY if HFC and hasattr(HFC, "VIRTUAL_KEY") else None)
                                    except Exception:
                                        const = None
                                    try:
                                        v.performHapticFeedback(const if const is not None else 1)
                                        return
                                    except Exception:
                                        pass
                            except Exception:
                                pass
                            try:
                                from hook_utils import find_class
                                Context = find_class("android.content.Context")
                                Vibrator = find_class("android.os.Vibrator")
                                ctx2 = v.getContext() if hasattr(v, "getContext") else ctx
                                service = ctx2.getSystemService("vibrator") if ctx2 else None
                                if service and hasattr(service, "vibrate"):
                                    try:
                                        service.vibrate(20)
                                    except Exception:
                                        pass
                            except Exception:
                                pass
                        except Exception:
                            pass
                    def _should_skip_click():
                        try:
                            import time
                            now = int(time.time()*1000)
                            last = int(getattr(self, "_di_last_click_ms", 0))
                            if now - last < 250:
                                return True
                            self._di_last_click_ms = now
                            return False
                        except Exception:
                            return False
                    def _wrap_click(fn):
                        def _inner(v):
                            try:
                                if _should_skip_click():
                                    return
                                _maybe_haptic(v)
                                fn(v)
                            except Exception:
                                pass
                        return _inner
                    btn_min.setOnClickListener(OnClickListener(_wrap_click(_toggle_minimize)))
                    btn_close.setOnClickListener(OnClickListener(_wrap_click(_close)))
                    try:
                        if getattr(self, "_di_btn_prev", None):
                            self._di_btn_prev.setOnClickListener(OnClickListener(_wrap_click(lambda v: self._previous_track(None))))
                        if getattr(self, "_di_btn_pp", None):
                            self._di_btn_pp.setOnClickListener(OnClickListener(_wrap_click(_toggle_play_pause)))
                        if getattr(self, "_di_btn_next", None):
                            self._di_btn_next.setOnClickListener(OnClickListener(_wrap_click(lambda v: self._skip_track(None))))
                        if getattr(self, "_di_btn_send", None):
                            self._di_btn_send.setOnClickListener(OnClickListener(_wrap_click(lambda v: self._send_now_playing_card(True))))
                        if getattr(self, "_di_btn_search", None):
                            self._di_btn_search.setOnClickListener(OnClickListener(_wrap_click(lambda v: self._show_spotify_search_dialog())))
                    except Exception:
                        pass
                    try:
                        # Clique na capa restaura apenas se estiver minimizada
                        def _maybe_restore(_):
                            try:
                                if bool(getattr(self, '_di_minimized', False)):
                                    _toggle_minimize(_)
                            except Exception:
                                pass
                        if self._di_cover:
                            self._di_cover.setOnClickListener(OnClickListener(_wrap_click(_maybe_restore)))
                    except Exception:
                        pass
                except Exception:
                    pass

            # Configurar touch slop para distinguir clique de arraste
            # Touch slop mais preciso para melhor responsividade
            try:
                from android.view import ViewConfiguration as _VC
                try:
                    _touch_slop = int(_VC.get(ctx).getScaledTouchSlop())
                    # Reduzir touch slop para toque mais preciso
                    _touch_slop = max(4, _touch_slop // 2)
                except Exception:
                    try:
                        _touch_slop = int(AndroidUtilities.dp(3))  # Ainda mais sensível para arraste fluido
                    except Exception:
                        _touch_slop = max(2, int(ctx.getResources().getDisplayMetrics().density * 3))
            except Exception:
                try:
                    _touch_slop = int(AndroidUtilities.dp(3))  # Otimizado para responsividade
                except Exception:
                    _touch_slop = max(2, int(ctx.getResources().getDisplayMetrics().density * 3))

            def on_touch(v, event):
                try:
                    # Registrar última atividade por toque
                    try:
                        import time as _t
                        self._di_last_activity_ts = float(_t.time())
                    except Exception:
                        pass
                    action = event.getAction()
                    if action == MotionEvent.ACTION_DOWN:
                        # Bloqueia arrasto quando “On Notch” estiver ativo (minimizada e expandida)
                        # Removido: bloqueio de arraste do Always on Top
                        # Inicializa sem marcar como "arrastando" para não consumir cliques
                        self._di_dragging = False
                        # Usar float para maior precisão no arraste
                        self._di_drag_start_raw_x = event.getRawX()
                        self._di_drag_start_raw_y = event.getRawY()
                        
                        # Inicializar sistema de throttling otimizado
                        self._di_last_update_time = 0
                        self._di_update_pending = False
                        self._di_drag_start_x = self._di_layout_params.x if self._di_layout_params else 0
                        try:
                            default_y = AndroidUtilities.dp(16)
                        except Exception:
                            default_y = int(ctx.getResources().getDisplayMetrics().density * 16)
                        self._di_drag_start_y = self._di_layout_params.y if self._di_layout_params else default_y
                        return False  # não consome DOWN; permite clique funcionar
                    elif action == MotionEvent.ACTION_MOVE:
                        # Bloqueia arrasto quando “On Notch” estiver ativo (minimizada e expandida)
                        # Removido: segundo bloqueio de arraste do Always on Top
                        # Cálculo de delta com maior precisão
                        dx = event.getRawX() - self._di_drag_start_raw_x
                        dy = event.getRawY() - self._di_drag_start_raw_y
                        
                        # Touch slop mais sensível para início mais rápido do arraste
                        sensitive_slop = max(1, _touch_slop // 2)  # Metade do touch slop padrão
                        
                        if (not self._di_dragging) and (abs(dx) >= sensitive_slop or abs(dy) >= sensitive_slop):
                            self._di_dragging = True
                            log("[Nowfy] Touch: Started smooth dragging")
                        if self._di_dragging and self._di_layout_params and self._di_window_manager:
                            # Calcular nova posição com precisão float
                            new_x = self._di_drag_start_x + dx
                            new_y = self._di_drag_start_y + dy
                            
                            # Atualizar posição com valores inteiros para evitar subpixel rendering
                            self._di_layout_params.x = int(round(new_x))
                            self._di_layout_params.y = int(round(new_y))
                            
                            # Sistema de throttling otimizado para 60fps
                            try:
                                current_time = event.getEventTime()
                                
                                # Update imediato no primeiro movimento
                                if self._di_last_update_time == 0:
                                    self._di_window_manager.updateViewLayout(self._di_layout, self._di_layout_params)
                                    self._di_last_update_time = current_time
                                    self._di_update_pending = False
                                # Throttling para 60fps (16.67ms)
                                elif current_time - self._di_last_update_time >= 16:
                                    self._di_window_manager.updateViewLayout(self._di_layout, self._di_layout_params)
                                    self._di_last_update_time = current_time
                                    self._di_update_pending = False
                                else:
                                    # Marcar update pendente para o próximo frame
                                    self._di_update_pending = True
                                    
                            except Exception as e:
                                # Fallback: update direto sem throttling
                                try:
                                    self._di_window_manager.updateViewLayout(self._di_layout, self._di_layout_params)
                                except Exception:
                                    pass
                            return True
                        return False
                    elif action in (MotionEvent.ACTION_UP, MotionEvent.ACTION_CANCEL):
                        # Quando “On Notch” estiver ativo, não salvar X/Y e reforçar posição
                        try:
                            if bool(self.get_setting("on_notch_enabled", False)):
                                # Always on Top: não interfere no movimento - apenas define posição inicial
                                pass
                        except Exception:
                            pass
                        if self._di_dragging:
                            # Update final se havia um pendente
                            if getattr(self, '_di_update_pending', False) and self._di_layout_params and self._di_window_manager:
                                try:
                                    self._di_window_manager.updateViewLayout(self._di_layout, self._di_layout_params)
                                except Exception:
                                    pass
                            
                            self._di_dragging = False
                            self._di_update_pending = False
                            log("[Nowfy] Touch: Finished smooth dragging")
                            
                            # Salvar posição final
                            try:
                                if self._di_layout_params:
                                    self.set_setting("dynamic_island_last_x", int(self._di_layout_params.x))
                                    self.set_setting("dynamic_island_last_y", int(self._di_layout_params.y))
                            except Exception:
                                pass
                            return True
                        return False
                    return False
                except Exception as e:
                    log(f"[Nowfy] Dynamic Island onTouch error: {e}")
                    return False
            # Corrigindo listener de toque: resolver interface via find_class e usar dynamic_proxy com classe
            try:
                from hook_utils import find_class
                OnTouchListenerCls = find_class("android.view.View$OnTouchListener")
            except Exception:
                OnTouchListenerCls = None
            if OnTouchListenerCls is not None:
                class _NowfyTouchListener(dynamic_proxy(OnTouchListenerCls)):
                    def __init__(self, fn):
                        super().__init__()
                        self._fn = fn
                    def onTouch(self, v, event):
                        try:
                            return bool(self._fn(v, event))
                        except Exception:
                            return False
                tl = _NowfyTouchListener(on_touch)
                frame.setOnTouchListener(tl)
                try:
                    root.setOnTouchListener(tl)
                except Exception:
                    pass
                # Mini Controls removidos: nenhum listener de toque para mini container
                try:
                    content.setOnTouchListener(tl)
                except Exception:
                    pass
                try:
                    controls.setOnTouchListener(tl)
                except Exception:
                    pass
                try:
                    if self._di_cover:
                        self._di_cover.setOnTouchListener(tl)
                except Exception:
                    pass
                try:
                    btn_min.setOnTouchListener(tl)
                    btn_close.setOnTouchListener(tl)
                except Exception:
                    pass
            else:
                try:
                    from android_utils import OnTouchListener
                    tl = OnTouchListener(on_touch)
                    frame.setOnTouchListener(tl)
                    try:
                        root.setOnTouchListener(tl)
                    except Exception:
                        pass
                    # Mini Controls removidos: nenhum listener de toque para mini container
                    try:
                        content.setOnTouchListener(tl)
                    except Exception:
                        pass
                    try:
                        controls.setOnTouchListener(tl)
                    except Exception:
                        pass
                    try:
                        if self._di_cover:
                            self._di_cover.setOnTouchListener(tl)
                    except Exception:
                        pass
                    try:
                        btn_min.setOnTouchListener(tl)
                        btn_close.setOnTouchListener(tl)
                    except Exception:
                        pass
                except Exception:
                    # Fallback final: sem listener, apenas retorna a view
                    pass
            return root
        except Exception as e:
            log(f"[Nowfy] Error creating Dynamic Island view: {e}")
            return None



    def _sync_cover_style(self, style_idx, is_pill=False):
        """Sincroniza o formato da capa com o estilo da ilha"""
        try:
            if not hasattr(self, '_di_cover') or not self._di_cover:
                return
            
            from android.graphics.drawable import GradientDrawable
            
            # Obter contexto
            ctx = ApplicationLoader.applicationContext
            
            # Criar drawable para a capa
            cover_bg = GradientDrawable()
            cover_bg.setShape(GradientDrawable.RECTANGLE)
            cover_bg.setColor(0x00000000)  # Transparente
            
            if style_idx == 1:  # Circular
                # Capa circular
                if is_pill:
                    radius = AndroidUtilities.dp(14) if AndroidUtilities else int(ctx.getResources().getDisplayMetrics().density * 14)
                else:
                    radius = AndroidUtilities.dp(26) if AndroidUtilities else int(ctx.getResources().getDisplayMetrics().density * 26)
                cover_bg.setCornerRadius(float(radius))
            else:  # Arredondado normal
                # Capa com cantos arredondados
                if is_pill:
                    radius = AndroidUtilities.dp(8) if AndroidUtilities else int(ctx.getResources().getDisplayMetrics().density * 8)
                else:
                    radius = AndroidUtilities.dp(10) if AndroidUtilities else int(ctx.getResources().getDisplayMetrics().density * 10)
                cover_bg.setCornerRadius(float(radius))
            
            # Aplicar o drawable como fundo da capa
            try:
                self._di_cover.setBackground(cover_bg)
                # Garantir que a imagem seja cortada conforme o fundo
                self._di_cover.setClipToOutline(True)
            except Exception:
                pass
                
        except Exception:
            pass



    def _get_default_island_y(self, ctx):
        try:
            res = ctx.getResources()
            res_id = res.getIdentifier("status_bar_height", "dimen", "android")
            sb_height = 0
            if res_id and res_id > 0:
                sb_height = int(res.getDimensionPixelSize(res_id))
        except Exception:
            sb_height = 0
        
        # Posição baseada nas configurações do usuário
        try:
            if bool(self.get_setting('on_notch_enabled', False)):
                # Always on Top: posição fixa padrão no topo
                offset_dp = -5  # Posição padrão próxima ao topo
                margin = AndroidUtilities.dp(offset_dp) if AndroidUtilities else int(ctx.getResources().getDisplayMetrics().density * offset_dp)
            else:
                # Posição normal quando não está no modo Always on Top
                margin = AndroidUtilities.dp(12) if AndroidUtilities else int(ctx.getResources().getDisplayMetrics().density * 12)
        except Exception:
            margin = int(ctx.getResources().getDisplayMetrics().density * -5) if bool(self.get_setting('on_notch_enabled', False)) else int(ctx.getResources().getDisplayMetrics().density * 12)
        
        try:
            base = max(0, sb_height) + margin
            # Garantir que não fique negativo demais
            if base < 0:
                base = max(0, sb_height // 2)
            return int(base)
        except Exception:
            return margin if margin > 0 else 0

    def _reposition_dynamic_island_to_notch(self):
        try:
            wm = getattr(self, '_di_window_manager', None)
            layout = getattr(self, '_di_layout', None)
            lp = getattr(self, '_di_layout_params', None)
            if not (wm and layout and lp):
                return False
            on_notch = bool(self.get_setting('on_notch_enabled', False))
            ctx = ApplicationLoader.applicationContext
            try:
                from android.view import Gravity as _G
                G_TOP_CENTER = _G.TOP | _G.CENTER_HORIZONTAL
                G_TOP_START = _G.TOP | _G.START
            except Exception:
                G_TOP_CENTER = Gravity.TOP | Gravity.CENTER_HORIZONTAL
                G_TOP_START = Gravity.TOP | Gravity.START
            if on_notch:
                lp.gravity = G_TOP_CENTER
                lp.x = 0
                try:
                    _base_y = int(self._get_default_island_y(ctx))
                except Exception:
                    try:
                        _base_y = AndroidUtilities.dp(16)
                    except Exception:
                        _base_y = int(ctx.getResources().getDisplayMetrics().density * 16)
                # Posicionamento simples
                try:
                    lp.y = int(_base_y)
                except Exception:
                    lp.y = int(_base_y)
            else:
                last_x = self.get_setting('dynamic_island_last_x', None)
                last_y = self.get_setting('dynamic_island_last_y', None)
                if last_x is None or last_y is None:
                    lp.gravity = G_TOP_CENTER
                    lp.x = 0
                    try:
                        lp.y = int(self._get_default_island_y(ctx))
                    except Exception:
                        try:
                            lp.y = AndroidUtilities.dp(16)
                        except Exception:
                            lp.y = int(ctx.getResources().getDisplayMetrics().density * 16)
                else:
                    lp.gravity = G_TOP_START
                    lp.x = int(last_x)
                    lp.y = int(last_y)
            try:
                wm.updateViewLayout(layout, lp)
                return True
            except Exception:
                return False
        except Exception:
            return False

    def _start_dynamic_island_overlay(self):
        try:
            if self._di_is_active:
                return
            fragment = get_last_fragment()
            ctx = fragment.getParentActivity() if fragment and fragment.getParentActivity() else ApplicationLoader.applicationContext
            # Priorizar WindowManager da Activity quando disponível; fallback para Application
            wm = None
            try:
                if fragment and fragment.getParentActivity():
                    act = fragment.getParentActivity()
                    try:
                        wm = act.getSystemService(Context.WINDOW_SERVICE)
                    except Exception:
                        wm = None
                    try:
                        if wm is None and hasattr(act, "getWindowManager"):
                            wm = act.getWindowManager()
                    except Exception:
                        pass
            except Exception:
                wm = None
            if wm is None:
                wm = ApplicationLoader.applicationContext.getSystemService(Context.WINDOW_SERVICE)
            self._di_window_manager = wm
            # Limpeza preventiva de instâncias anteriores para evitar duplicação
            try:
                if self._di_layout is not None:
                    def _remove_prev():
                        try:
                            try:
                                self._di_window_manager.removeViewImmediate(self._di_layout)
                            except Exception:
                                self._di_window_manager.removeView(self._di_layout)
                        except Exception:
                            pass
                    try:
                        from android_utils import run_on_ui_thread
                        run_on_ui_thread(_remove_prev)
                    except Exception:
                        _remove_prev()
            except Exception:
                pass
            view = self._create_dynamic_island_view(ctx)
            if not view:
                BulletinHelper.show_info(tr("error_generic").format(error="Failed to create overlay") if "error_generic" in TRANSLATIONS else "Failed to create overlay")
                return

            width = WindowManager.LayoutParams.WRAP_CONTENT
            height = WindowManager.LayoutParams.WRAP_CONTENT
            # Check overlay permission for API >= 23
            try:
                if Build.VERSION.SDK_INT >= 23 and not Settings.canDrawOverlays(ctx):
                    try:
                        intent = Intent(Settings.ACTION_MANAGE_OVERLAY_PERMISSION, Uri.parse("package:" + str(ctx.getPackageName())))
                        intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK)
                        ctx.startActivity(intent)
                    except Exception as pe:
                        log(f"[Nowfy] Error opening overlay permission settings: {pe}")
                    BulletinHelper.show_info(tr("error_generic").format(error="Overlay permission required") if "error_generic" in TRANSLATIONS else "Overlay permission required")
                    # Prosseguir com fallback in-app (TYPE_APPLICATION) sem finalizar aqui
            except Exception as pe:
                log(f"[Nowfy] Overlay permission check error: {pe}")
            # Use system overlay type for API >= 26, fallback to TYPE_PHONE
            window_type = None
            try:
                if Build.VERSION.SDK_INT >= 26 and Settings.canDrawOverlays(ctx):
                    window_type = WindowManager.LayoutParams.TYPE_APPLICATION_OVERLAY
                elif Build.VERSION.SDK_INT < 26 and (Build.VERSION.SDK_INT >= 23 and Settings.canDrawOverlays(ctx)):
                    window_type = WindowManager.LayoutParams.TYPE_PHONE
                else:
                    window_type = WindowManager.LayoutParams.TYPE_APPLICATION
            except Exception:
                window_type = WindowManager.LayoutParams.TYPE_APPLICATION_OVERLAY if Build.VERSION.SDK_INT >= 26 else WindowManager.LayoutParams.TYPE_PHONE
            # Flags otimizadas para arraste suave e performance
            flags = (WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE | 
                    WindowManager.LayoutParams.FLAG_NOT_TOUCH_MODAL | 
                    WindowManager.LayoutParams.FLAG_LAYOUT_NO_LIMITS |
                    WindowManager.LayoutParams.FLAG_HARDWARE_ACCELERATED)  # Aceleração por hardware
            # Criar LayoutParams via propriedades, compatível com ambientes do plugin
            lp = WindowManager.LayoutParams()
            lp.width = width
            lp.height = height
            lp.type = window_type
            lp.flags = flags
            lp.format = PixelFormat.TRANSLUCENT
            try:
                pass
            except Exception:
                pass

            # Always on Top: define posição inicial apenas quando não há posição salva
            always_on_top = bool(self.get_setting("on_notch_enabled", False))
            last_x = self.get_setting("dynamic_island_last_x", None)
            last_y = self.get_setting("dynamic_island_last_y", None)
            
            if always_on_top and (last_x is None or last_y is None):
                # Always on Top ativo e sem posição salva: abrir no topo centralizado
                lp.gravity = Gravity.TOP | Gravity.CENTER_HORIZONTAL
                lp.x = 0
                try:
                    lp.y = int(self._get_default_island_y(ctx))
                except Exception:
                    try:
                        lp.y = AndroidUtilities.dp(16)
                    except Exception:
                        lp.y = int(ctx.getResources().getDisplayMetrics().density * 16)
            elif last_x is not None and last_y is not None:
                # Usar posição salva (independente do Always on Top)
                lp.gravity = Gravity.TOP | Gravity.START
                lp.x = int(last_x)
                lp.y = int(last_y)
            else:
                # Fallback: posição padrão normal
                lp.gravity = Gravity.TOP | Gravity.CENTER_HORIZONTAL
                lp.x = 0
                try:
                    lp.y = AndroidUtilities.dp(16)
                except Exception:
                    lp.y = int(ctx.getResources().getDisplayMetrics().density * 16)

            # Adiciona a view ao WindowManager com fallback: TYPE_APPLICATION_OVERLAY/TYPE_PHONE -> TYPE_APPLICATION
            try:
                # Tentar anexar token quando usando TYPE_APPLICATION
                try:
                    if lp.type == WindowManager.LayoutParams.TYPE_APPLICATION and fragment and fragment.getParentActivity():
                        win = fragment.getParentActivity().getWindow()
                        if win and hasattr(win, "getDecorView"):
                            decor = win.getDecorView()
                            if decor and hasattr(decor, "getWindowToken"):
                                lp.token = decor.getWindowToken()
                except Exception:
                    pass
                try:
                    from android_utils import run_on_ui_thread
                    run_on_ui_thread(lambda: wm.addView(view, lp))
                except Exception:
                    wm.addView(view, lp)
            except Exception as ae:
                log(f"[Nowfy] Falha ao criar overlay Dynamic Island (type={lp.type}): {ae}")
                # Fallback: mudar para TYPE_APPLICATION se ainda não for e tentar novamente
                try:
                    if lp.type != WindowManager.LayoutParams.TYPE_APPLICATION:
                        lp.type = WindowManager.LayoutParams.TYPE_APPLICATION
                        try:
                            if fragment and fragment.getParentActivity():
                                win = fragment.getParentActivity().getWindow()
                                if win and hasattr(win, "getDecorView"):
                                    decor = win.getDecorView()
                                    if decor and hasattr(decor, "getWindowToken"):
                                        lp.token = decor.getWindowToken()
                        except Exception:
                            pass
                        try:
                            from android_utils import run_on_ui_thread
                            run_on_ui_thread(lambda: wm.addView(view, lp))
                        except Exception:
                            try:
                                wm.addView(view, lp)
                            except Exception as ae2:
                                log(f"[Nowfy] Fallback TYPE_APPLICATION falhou: {ae2}")
                                BulletinHelper.show_info(tr("error_generic").format(error=str(ae2)) if "error_generic" in TRANSLATIONS else f"Failed to create overlay: {ae2}")
                                return
                    else:
                        BulletinHelper.show_info(tr("error_generic").format(error=str(ae)) if "error_generic" in TRANSLATIONS else f"Failed to create overlay: {ae}")
                        return
                except Exception:
                    BulletinHelper.show_info(tr("error_generic"))
                    return
            self._di_layout = view
            self._di_layout_params = lp
            self._di_is_active = True
            self._di_closed_by_user = False
            try:
                import time as _t
                self._di_last_activity_ts = float(_t.time())
            except Exception:
                pass
            BulletinHelper.show_success(tr("dynamic_island_started"))
            try:
                if bool(self.get_setting("on_notch_enabled", False)):
                    self._reposition_dynamic_island_to_notch()
            except Exception:
                pass
            
            # Garantir que o Pop Size seja aplicado na inicialização
            try:
                self._apply_pop_style_to_overlay()
            except Exception:
                pass
            
            # Garantir que o Island Style seja aplicado na inicialização
            try:
                self._apply_island_style_to_overlay()
            except Exception:
                pass
            # Aplicar bordas arredondadas após medida, com OutlineProvider fallback
            try:
                if hasattr(view, "post"):
                    def _apply_rounded_bg():
                        try:
                            from hook_utils import find_class
                            AndroidUtilities = find_class("org.telegram.messenger.AndroidUtilities")
                            GradientDrawable = find_class("android.graphics.drawable.GradientDrawable")
                            Color = find_class("android.graphics.Color")
                            if AndroidUtilities and GradientDrawable and Color:
                                bg = GradientDrawable()
                                bg.setShape(GradientDrawable.RECTANGLE)
                                try:
                                    if hasattr(Color, "parseColor"):
                                        bg.setColor(Color.parseColor("#CC151515"))
                                    else:
                                        if hasattr(Color, "argb"):
                                            bg.setColor(Color.argb(204, 21, 21, 21))
                                except Exception:
                                    try:
                                        if hasattr(Color, "BLACK"):
                                            bg.setColor(Color.BLACK)
                                    except Exception:
                                        pass
                                try:
                                    radius = AndroidUtilities.dp(24)
                                except Exception:
                                    try:
                                        density = float(ctx.getResources().getDisplayMetrics().density)
                                        radius = int(24 * density)
                                    except Exception:
                                        radius = 24
                                try:
                                    bg.setCornerRadius(float(radius))
                                except Exception:
                                    pass
                                try:
                                    stroke_w = AndroidUtilities.dp(1)
                                except Exception:
                                    try:
                                        density = float(ctx.getResources().getDisplayMetrics().density)
                                        stroke_w = int(1 * density)
                                    except Exception:
                                        stroke_w = 1
                                try:
                                    if hasattr(Color, "argb"):
                                        bg.setStroke(0, 0)
                                except Exception:
                                    pass
                                try:
                                    if hasattr(view, "setBackground"):
                                        view.setBackground(bg)
                                except Exception:
                                    pass
                                # OutlineProvider personalizado como fallback
                                try:
                                    ViewOutlineProvider = find_class("android.view.ViewOutlineProvider")
                                    Outline = find_class("android.graphics.Outline")
                                    if ViewOutlineProvider and Outline and AndroidUtilities:
                                        class RoundedOutlineProvider(ViewOutlineProvider):
                                            def getOutline(self, v, outline):
                                                try:
                                                    r = AndroidUtilities.dp(24)
                                                except Exception:
                                                    try:
                                                        density = float(ctx.getResources().getDisplayMetrics().density)
                                                        r = int(24 * density)
                                                    except Exception:
                                                        r = 24
                                                try:
                                                    outline.setRoundRect(0, 0, v.getWidth(), v.getHeight(), float(r))
                                                except Exception:
                                                    pass
                                        try:
                                            provider = RoundedOutlineProvider()
                                            if hasattr(view, "setOutlineProvider"):
                                                view.setOutlineProvider(provider)
                                        except Exception:
                                            pass
                                except Exception:
                                    pass
                                try:
                                    if hasattr(view, "setClipToOutline"):
                                        view.setClipToOutline(True)
                                except Exception:
                                    pass
                        except Exception as e:
                            try:
                                log(f"[Nowfy] Erro ao aplicar bordas arredondadas: {e}")
                            except Exception:
                                pass
                    try:
                        view.post(_apply_rounded_bg)
                    except Exception:
                        _apply_rounded_bg()
            except Exception:
                pass
            # Atualização inicial imediata de título/autor/capa
            try:
                td = self._get_current_track_for_nowcast()
                try:
                    from android_utils import run_on_ui_thread
                    run_on_ui_thread(lambda: self._update_dynamic_island_content(td))
                except Exception:
                    self._update_dynamic_island_content(td)
            except Exception as e:
                log(f"[Nowfy] Initial content update error: {e}")
            self._start_dynamic_island_refresh()
        except Exception as e:
            log(f"[Nowfy] Error starting Dynamic Island overlay: {e}")

    def _stop_dynamic_island_overlay(self):
        try:
            log("[Nowfy] Stopping Dynamic Island overlay...")
            if not self._di_is_active:
                log("[Nowfy] Dynamic Island already inactive")
                return
            try:
                if self._di_refresh_stop_event:
                    self._di_refresh_stop_event.set()
                self._di_refresh_stop_event = None
            except Exception:
                pass
            try:
                if self._di_refresh_thread and self._di_refresh_thread.is_alive():
                    pass
                self._di_refresh_thread = None
            except Exception:
                pass
            if self._di_window_manager and self._di_layout:
                try:
                    def _remove():
                        removed_ok = False
                        try:
                            try:
                                if hasattr(self._di_layout, "isAttachedToWindow"):
                                    if not self._di_layout.isAttachedToWindow():
                                        removed_ok = True
                                    else:
                                        self._di_window_manager.removeViewImmediate(self._di_layout)
                                        removed_ok = True
                                else:
                                    self._di_window_manager.removeViewImmediate(self._di_layout)
                                    removed_ok = True
                            except Exception:
                                try:
                                    self._di_window_manager.removeView(self._di_layout)
                                    removed_ok = True
                                except Exception:
                                    removed_ok = False
                        finally:
                            try:
                                if removed_ok:
                                    self._di_window_manager = None
                                    self._di_layout = None
                                    self._di_layout_params = None
                                    self._di_text_view = None
                                    self._di_cover = None
                                    self._di_title_view = None
                                    self._di_artist_view = None

                                    self._di_mini_controls = None
                            except Exception:
                                pass
                    try:
                        from android_utils import run_on_ui_thread
                        run_on_ui_thread(_remove)
                    except Exception:
                        _remove()
                except Exception:
                    pass
            self._di_is_active = False
            # Não limpe referências aqui; faça isso após remover a view.
        except Exception as e:
            log(f"[Nowfy] Error stopping Dynamic Island overlay: {e}")

    def _is_pop_island_allowed(self, allow_bulletin=False):
        try:
            # Permitir iniciar a Pop Island apenas quando o switch estiver ligado
            # e quando NÃO estiver marcada como fechada pelo usuário.
            # Isso impede auto-starts indesejados após o usuário fechar manualmente.
            if not bool(self.get_setting("dynamic_island_overlay", False)):
                return False
            if bool(getattr(self, "_di_closed_by_user", False)):
                return False
            return True
        except Exception:
            return False

    def _safe_start_dynamic_island_overlay(self):
        try:
            # Gate activation: Spotify as source/player and valid credentials
            if not self._is_pop_island_allowed(allow_bulletin=True):
                log("[Nowfy] Floatify activation blocked by gating")
                return
            if not getattr(self, '_di_is_active', False):
                self._start_dynamic_island_overlay()
            else:
                try:
                    td = self._get_current_track_for_nowcast()
                    try:
                        import android_utils as _au
                        fn = getattr(_au, "run_on_ui_thread", None)
                        if fn:
                            fn(lambda: self._update_dynamic_island_content(td))
                        else:
                            raise Exception("no run_on_ui_thread")
                    except Exception:
                        self._update_dynamic_island_content(td)
                except Exception:
                    pass
        except Exception as e:
            log(f"[Nowfy] Error ensuring Dynamic Island overlay: {e}")

    def _start_dynamic_island_refresh(self):
        try:
            self._di_refresh_stop_event = threading.Event()
            def worker():
                try:
                    while self._di_is_active and self._di_refresh_stop_event and not self._di_refresh_stop_event.is_set():
                        try:
                            data = self._get_current_track_for_nowcast()
                            try:
                                from android_utils import run_on_ui_thread
                                run_on_ui_thread(lambda: self._update_dynamic_island_content(data))
                            except Exception:
                                self._update_dynamic_island_content(data)
                            # Inatividade: auto desligar conforme preferência
                            try:
                                import time as _t
                                if bool(self.get_setting("overlay_auto_disable_inactivity", False)):
                                    timeout_values = [1, 5, 10, 15, 30, 60]
                                    try:
                                        minutes = int(self.get_setting("overlay_inactivity_timeout_minutes", 10))
                                    except Exception:
                                        minutes = 10
                                    if minutes not in timeout_values:
                                        minutes = 10
                                    threshold = max(60, int(minutes) * 60)
                                    now = float(_t.time())
                                    last_ts = float(getattr(self, "_di_last_activity_ts", now))
                                    try:
                                        is_playing = bool(self._check_music_playing())
                                    except Exception:
                                        is_playing = False
                                    if (not is_playing) and ((now - last_ts) >= float(threshold)):
                                        try:
                                            from org.telegram.messenger import R as R_tg
                                            fragment = get_last_fragment()
                                        except Exception:
                                            R_tg = None
                                            fragment = get_last_fragment()
                                        try:
                                            BulletinHelper.show_two_line(
                                                tr("pop_island_title") if "pop_island_title" in TRANSLATIONS else "Floatify",
                                                tr("dynamic_island_auto_disabled_subtitle") if "dynamic_island_auto_disabled_subtitle" in TRANSLATIONS else "Disabled due to inactivity",
                                                (R_tg.raw.chats_infotip if R_tg else 0),
                                                fragment
                                            )
                                        except Exception:
                                            pass
                                        try:
                                            fn = None
                                            try:
                                                import android_utils as _au
                                                fn = getattr(_au, "run_on_ui_thread", None)
                                            except Exception:
                                                fn = None
                                            if fn:
                                                fn(lambda: self._stop_dynamic_island_overlay())
                                            else:
                                                self._stop_dynamic_island_overlay()
                                        except Exception:
                                            self._stop_dynamic_island_overlay()
                                        break
                            except Exception:
                                pass
                        except Exception as ie:
                            log(f"[Nowfy] Dynamic Island refresh error: {ie}")
                        time.sleep(5)
                except Exception as e:
                    log(f"[Nowfy] Dynamic Island worker error: {e}")
            self._di_refresh_thread = threading.Thread(target=worker, daemon=True)
            self._di_refresh_thread.start()
        except Exception as e:
            log(f"[Nowfy] Error starting refresh thread: {e}")

    def _update_dynamic_island_content(self, track_data):
        try:
            # Skip if overlay is not active or disallowed by gating
            if not getattr(self, '_di_is_active', False):
                return
            try:
                if not self._is_pop_island_allowed(False):
                    return
            except Exception:
                pass
            title = None
            artist = None
            image_url = None
            image_pil = None
            if track_data:
                title = track_data.get('title') or track_data.get('name') or ''
                artist = track_data.get('artist') or ''
                image_url = track_data.get('image_url') or ''
                image_pil = track_data.get('image_pil')
            try:
                is_playing = False
                try:
                    is_playing = bool(self._check_music_playing())
                except Exception:
                    is_playing = False
                if is_playing:
                    import time as _t
                    self._di_last_activity_ts = float(_t.time())
            except Exception:
                pass

            # Atualizar textos
            if getattr(self, '_di_title_view', None) and getattr(self, '_di_artist_view', None):
                if title or artist:
                    try:
                        self._di_title_view.setText(title or "")
                    except Exception:
                        pass
                    try:
                        self._di_artist_view.setText(artist or "")
                    except Exception:
                        pass
                else:
                    try:
                        self._di_title_view.setText(tr("no_track_playing_title"))
                    except Exception:
                        pass
                    try:
                        self._di_artist_view.setText(tr("no_track_playing_artist_spotify"))
                    except Exception:
                        pass

            elif getattr(self, '_di_text_view', None):
                if title and artist:
                    self._di_text_view.setText(f"{title} — {artist}")
                elif title:
                    self._di_text_view.setText(title)
                else:
                    self._di_text_view.setText(tr("no_track_playing") if "no_track_playing" in TRANSLATIONS else "No music playing")

            # Ajuste de rolagem condicional no título: ativa marquee somente se houver corte com "..."
            try:
                tv = getattr(self, '_di_title_view', None)
                if tv:
                    def _apply_marquee_if_needed():
                        try:
                            lay = tv.getLayout()
                            # Se layout ainda não está pronto, ignorar
                            if lay is not None:
                                lc = lay.getLineCount()
                                last = lc - 1 if lc > 0 else 0
                                ell = lay.getEllipsisCount(last)
                                try:
                                    from android.text import TextUtils as _TextUtils
                                    if ell > 0:
                                        tv.setEllipsize(_TextUtils.TruncateAt.MARQUEE)
                                        tv.setHorizontallyScrolling(True)
                                        tv.setSelected(True)
                                    else:
                                        tv.setEllipsize(_TextUtils.TruncateAt.END)
                                        tv.setHorizontallyScrolling(False)
                                        tv.setSelected(False)
                                except Exception:
                                    try:
                                        from hook_utils import find_class
                                        TU = find_class('android.text.TextUtils')
                                        if TU and getattr(TU, 'TruncateAt', None):
                                            if ell > 0:
                                                tv.setEllipsize(TU.TruncateAt.MARQUEE)
                                                tv.setHorizontallyScrolling(True)
                                                tv.setSelected(True)
                                            else:
                                                tv.setEllipsize(TU.TruncateAt.END)
                                                tv.setHorizontallyScrolling(False)
                                                tv.setSelected(False)
                                    except Exception:
                                        pass
                        except Exception:
                            pass
                    try:
                        tv.post(_apply_marquee_if_needed)
                    except Exception:
                        _apply_marquee_if_needed()
            except Exception:
                pass

            # Mini Controls removidos: nenhum estado adicional para botões mini

            # Atualizar capa se disponível
            try:
                if (image_pil or image_url) and getattr(self, '_di_cover', None):
                    import threading
                    def _load():
                        try:
                            data = None
                            if image_pil is not None:
                                try:
                                    from io import BytesIO as _BytesIO
                                    _buf = _BytesIO()
                                    try:
                                        im_rgba = image_pil.convert("RGBA")
                                    except Exception:
                                        im_rgba = image_pil
                                    im_rgba.save(_buf, format="PNG")
                                    data = _buf.getvalue()
                                except Exception:
                                    data = None
                            elif image_url:
                                try:
                                    import requests
                                    resp = requests.get(image_url, timeout=6)
                                    if resp.status_code == 200 and resp.content:
                                        data = resp.content
                                except Exception:
                                    data = None
                            if not data:
                                return
                            bmp = None
                            blurred_bmp = None
                            try:
                                from hook_utils import find_class
                                BitmapFactory = find_class("android.graphics.BitmapFactory")
                                if BitmapFactory is not None:
                                    bmp = BitmapFactory.decodeByteArray(data, 0, len(data))
                            except Exception:
                                bmp = None
                            # Fallback desativado: remover processamento pesado de blur para performance
                            blurred_bmp = None
                            def _apply():
                                try:
                                    if bmp:
                                        self._di_cover.setImageBitmap(bmp)
                                        try:
                                            if image_url:
                                                self._di_last_cover_url = image_url
                                        except Exception:
                                            pass
                                        
                                        # Reaplicar Island Style quando a capa muda
                                        try:
                                            self._apply_island_style_to_overlay()
                                        except Exception:
                                            pass
                                            
                                except Exception:
                                    pass
                            try:
                                from android_utils import run_on_ui_thread
                                run_on_ui_thread(_apply)
                            except Exception:
                                _apply()
                        except Exception:
                            pass
                    threading.Thread(target=_load, daemon=True).start()
                else:
                    try:
                        cover = getattr(self, '_di_cover', None)
                        apply_fn = getattr(self, '_di_apply_icon', None)
                        if cover:
                            FALLBACK_COVER_URL = "https://i.postimg.cc/mktzh58h/icon-island.png"
                            if apply_fn:
                                apply_fn(cover, FALLBACK_COVER_URL)
                            else:
                                import threading, requests
                                def _load_fallback():
                                    try:
                                        resp = requests.get(FALLBACK_COVER_URL, timeout=6)
                                        if resp.status_code == 200 and resp.content:
                                            from hook_utils import find_class
                                            BF = find_class("android.graphics.BitmapFactory")
                                            bmp = BF.decodeByteArray(resp.content, 0, len(resp.content)) if BF else None
                                            def _apply_fb():
                                                try:
                                                    if bmp:
                                                        cover.setImageBitmap(bmp)
                                                except Exception:
                                                    pass
                                            try:
                                                from android_utils import run_on_ui_thread
                                                run_on_ui_thread(_apply_fb)
                                            except Exception:
                                                _apply_fb()
                                    except Exception:
                                        pass
                                threading.Thread(target=_load_fallback, daemon=True).start()
                    except Exception:
                        pass
            except Exception:
                pass

            # Sincronizar ícone do botão play/pause conforme estado atual
            try:
                btn = getattr(self, '_di_btn_pp', None)
                apply_fn = getattr(self, '_di_apply_icon', None)
                play_url = getattr(self, '_di_play_url', None)
                pause_url = getattr(self, '_di_pause_url', None)
                if btn and apply_fn and (play_url or pause_url):
                    use_url = (pause_url if is_playing else play_url) or play_url or pause_url
                    if use_url:
                        apply_fn(btn, use_url)
            except Exception:
                pass

        except Exception as e:
            log(f"[Nowfy] Error updating Dynamic Island content: {e}")

    def _apply_pop_style_to_overlay(self):
        try:
            cover = getattr(self, "_di_cover", None)
            if not cover:
                return
                
            # Obter configurações
            style_idx = 0
            size_idx = 2  # Padrão Medium
            try:
                style_idx = int(self.get_setting("pop_style_selector", 0))
                size_idx = int(self.get_setting("pop_size_selector", 2))
            except Exception:
                pass
                
            from hook_utils import find_class
            GD = find_class("android.graphics.drawable.GradientDrawable")
            Color = find_class("android.graphics.Color")
            VOP = find_class("android.view.ViewOutlineProvider")
            AndroidUtilities = find_class("org.telegram.messenger.AndroidUtilities")
            
            # Aplicar tamanho baseado no Pop Size
            try:
                size_multipliers = {
                    0: 0.7,   # Tiny
                    1: 0.85,  # Small  
                    2: 1.0,   # Medium (padrão)
                    3: 1.2    # Large
                }
                size_factor = size_multipliers.get(size_idx, 1.0)
                base_size = int(52 * size_factor)
                new_size = AndroidUtilities.dp(base_size) if AndroidUtilities else int(base_size * 3)
                
                # Aplicar novo tamanho
                lp = cover.getLayoutParams()
                if lp:
                    lp.width = new_size
                    lp.height = new_size
                    cover.setLayoutParams(lp)
            except Exception:
                pass
            
            # Aplicar estilo visual
            if GD:
                bg = GD()
                try:
                    bg.setShape(GD.RECTANGLE)
                except Exception:
                    pass
                try:
                    if Color:
                        bg.setColor(Color.parseColor("#000000"))
                except Exception:
                    pass
                try:
                    if style_idx == 1:  # Circular
                        h = int(cover.getHeight())
                        w = int(cover.getWidth())
                        if h > 0 and w > 0:
                            r = float(int(min(h, w) / 2))
                        else:
                            r = float(AndroidUtilities.dp(26)) if AndroidUtilities else 26.0
                    else:  # Arredondado
                        r = float(AndroidUtilities.dp(10)) if AndroidUtilities else 10.0
                    bg.setCornerRadius(r)
                except Exception:
                    pass
                try:
                    cover.setBackground(bg)
                except Exception:
                    pass
                try:
                    if VOP and hasattr(cover, "setOutlineProvider"):
                        cover.setOutlineProvider(VOP.BACKGROUND)
                except Exception:
                    pass
                try:
                    cover.setClipToOutline(True)
                except Exception:
                    pass
        except Exception as e:
            try:
                log(f"[Nowfy] Failed to apply pop style: {e}")
            except Exception:
                pass

    def _apply_island_style_to_overlay(self):
        """Aplica o estilo da ilha (Default ou BG Cover)"""
        try:
            log("[Nowfy] Island Style: Starting to apply style")
            
            # Obter o frame principal da ilha
            frame = getattr(self, "_di_frame", None)
            if not frame:
                log("[Nowfy] Island Style: No frame found")
                return
                
            # Obter configuração do estilo
            style_idx = 0
            try:
                style_idx = int(self.get_setting("island_styles_selector", 0))
            except Exception:
                pass
            
            log(f"[Nowfy] Island Style: Selected style index: {style_idx}")
            
            from hook_utils import find_class
            GD = find_class("android.graphics.drawable.GradientDrawable")
            Color = find_class("android.graphics.Color")
            BitmapDrawable = find_class("android.graphics.drawable.BitmapDrawable")
            AndroidUtilities = find_class("org.telegram.messenger.AndroidUtilities")
            
            if style_idx == 0:  # Default - estilo padrão
                self._apply_default_island_background(frame, GD, Color, AndroidUtilities)
            elif style_idx == 1:  # BG Cover - capa como fundo com blur
                self._apply_bg_cover_island_background(frame, GD, Color, BitmapDrawable, AndroidUtilities)
            elif style_idx == 2:  # Pure - sem fundo, totalmente transparente
                self._apply_pure_island_background(frame, GD, Color, AndroidUtilities)
            elif style_idx == 3:  # No Blur - capa como fundo sem blur
                self._apply_no_blur_island_background(frame, GD, Color, BitmapDrawable, AndroidUtilities)
                
        except Exception as e:
            try:
                log(f"[Nowfy] Failed to apply island style: {e}")
            except Exception:
                pass

    def _apply_default_island_background(self, frame, GD, Color, AndroidUtilities):
        """Aplica o fundo padrão da ilha mantendo o outline para recorte"""
        try:
            if not GD:
                return
            
            # Reutiliza o GradientDrawable original do frame para preservar o outline
            bg = getattr(self, "_di_frame_bg", None)
            if bg is None:
                bg = GD()
                bg.setShape(GD.RECTANGLE)
                try:
                    radius = AndroidUtilities.dp(24) if AndroidUtilities else 24
                    bg.setCornerRadius(float(radius))
                except Exception:
                    pass
                self._di_frame_bg = bg
            
            # Cor padrão do fundo
            try:
                if Color and hasattr(Color, "parseColor"):
                    bg.setColor(Color.parseColor("#CC151515"))  # Fundo escuro semi-transparente
                elif Color and hasattr(Color, "argb"):
                    bg.setColor(Color.argb(204, 21, 21, 21))
            except Exception:
                pass
            
            try:
                frame.setBackground(bg)
            except Exception:
                pass
            
            # Oculta camadas de BG Cover quando estilo padrão estiver ativo
            try:
                if getattr(self, "_di_bg_image", None):
                    self._di_bg_image.setVisibility(8)
                if getattr(self, "_di_bg_overlay", None):
                    self._di_bg_overlay.setVisibility(8)
            except Exception:
                pass
            
        except Exception as e:
            try:
                log(f"[Nowfy] Failed to apply default background: {e}")
            except Exception:
                pass

    def _apply_bg_cover_island_background(self, frame, GD, Color, BitmapDrawable, AndroidUtilities):
        """Aplica a capa da música como fundo simples - SEM alterar tamanho da ilha"""
        try:
            # Limpar qualquer background anterior criado pela implementação complexa
            try:
                if hasattr(self, "_di_bg_image") and self._di_bg_image:
                    frame.removeView(self._di_bg_image)
                    self._di_bg_image = None
            except Exception:
                pass
            try:
                if hasattr(self, "_di_bg_overlay") and self._di_bg_overlay:
                    frame.removeView(self._di_bg_overlay)
                    self._di_bg_overlay = None
            except Exception:
                pass
            
            # Obter a capa atual
            cover = getattr(self, "_di_cover", None)
            if not cover:
                log("[Nowfy] BG Cover: No cover found, using default background")
                self._apply_default_island_background(frame, GD, Color, AndroidUtilities)
                return
            
            # Obter o drawable da capa
            cover_drawable = cover.getDrawable()
            if not cover_drawable:
                log("[Nowfy] BG Cover: No drawable found, using default background")
                self._apply_default_island_background(frame, GD, Color, AndroidUtilities)
                return
            
            log("[Nowfy] BG Cover: Applying simple background")
            
            # Abordagem com CROP: criar bitmap redimensionado para o formato da ilha
            try:
                from hook_utils import find_class
                LayerDrawable = find_class("android.graphics.drawable.LayerDrawable")
                BitmapDrawable = find_class("android.graphics.drawable.BitmapDrawable")
                Bitmap = find_class("android.graphics.Bitmap")
                Canvas = find_class("android.graphics.Canvas")
                Paint = find_class("android.graphics.Paint")
                Rect = find_class("android.graphics.Rect")
                RectF = find_class("android.graphics.RectF")
                
                if LayerDrawable and GD and BitmapDrawable and Bitmap:
                    # Obter dimensões reais da ilha (adaptável ao conteúdo)
                    try:
                        # Usar as dimensões reais do frame para se adaptar ao texto
                        frame.measure(0, 0)  # Forçar medição
                        island_width = max(frame.getMeasuredWidth(), AndroidUtilities.dp(200) if AndroidUtilities else 200)
                        island_height = max(frame.getMeasuredHeight(), AndroidUtilities.dp(80) if AndroidUtilities else 80)
                        
                        # Garantir dimensões mínimas e máximas razoáveis
                        min_width = AndroidUtilities.dp(200) if AndroidUtilities else 200
                        max_width = AndroidUtilities.dp(400) if AndroidUtilities else 400
                        island_width = max(min_width, min(island_width, max_width))
                        
                        log(f"[Nowfy] BG Cover: Using adaptive width {island_width}x{island_height}")
                    except Exception as e:
                        log(f"[Nowfy] BG Cover: Error getting frame dimensions: {e}")
                        # Fallback para dimensões fixas menores
                        island_width = AndroidUtilities.dp(250) if AndroidUtilities else 250
                        island_height = AndroidUtilities.dp(80) if AndroidUtilities else 80
                    
                    # Criar bitmap cropado da capa
                    cropped_drawable = None
                    try:
                        # Obter bitmap da capa original
                        if hasattr(cover_drawable, "getBitmap"):
                            original_bitmap = cover_drawable.getBitmap()
                        else:
                            # Fallback: criar bitmap a partir do drawable
                            original_bitmap = Bitmap.createBitmap(
                                island_width, island_height, Bitmap.Config.ARGB_8888
                            )
                            canvas = Canvas(original_bitmap)
                            cover_drawable.setBounds(0, 0, island_width, island_height)
                            cover_drawable.draw(canvas)
                        
                        if original_bitmap:
                            # Calcular crop para CENTER_CROP
                            orig_width = original_bitmap.getWidth()
                            orig_height = original_bitmap.getHeight()
                            
                            # Crop CENTER_CROP nativo - igual à capa circular (SEM distorção)
                            
                            # Calcular escala para preencher completamente (CENTER_CROP)
                            scale_x = float(island_width) / float(orig_width)
                            scale_y = float(island_height) / float(orig_height)
                            scale = max(scale_x, scale_y)  # Maior escala para preencher
                            
                            # Dimensões após escala (mantendo proporção)
                            new_width = int(orig_width * scale)
                            new_height = int(orig_height * scale)
                            
                            # Crop para pegar a parte central/superior
                            crop_x = (new_width - island_width) // 2
                            crop_y = int((new_height - island_height) * 0.3)  # 30% do topo
                            
                            # Garantir limites válidos
                            crop_x = max(0, crop_x)
                            crop_y = max(0, crop_y)
                            
                            # Escalar bitmap mantendo proporção
                            scaled_bitmap = Bitmap.createScaledBitmap(
                                original_bitmap, new_width, new_height, True
                            )
                            
                            # Crop final - exatamente como CENTER_CROP faria
                            cropped_bitmap = Bitmap.createBitmap(
                                scaled_bitmap, crop_x, crop_y, island_width, island_height
                            )
                            
                            # Aplicar blur e escurecimento ao bitmap cropado
                            final_bitmap = self._apply_blur_and_darken(cropped_bitmap)
                            
                            # Criar drawable do bitmap processado
                            cropped_drawable = BitmapDrawable(frame.getContext().getResources(), final_bitmap)
                            
                            # Aplicar bordas arredondadas ao drawable da capa também
                            try:
                                # Criar um GradientDrawable para aplicar bordas ao bitmap
                                bitmap_bg = GD()
                                bitmap_bg.setShape(GD.RECTANGLE)
                                
                                # Usar o bitmap como textura
                                from hook_utils import find_class
                                BitmapShader = find_class("android.graphics.BitmapShader")
                                Shader = find_class("android.graphics.Shader")
                                
                                if BitmapShader and Shader:
                                    shader = BitmapShader(final_bitmap, Shader.TileMode.CLAMP, Shader.TileMode.CLAMP)
                                    # Nota: GradientDrawable não suporta shader diretamente
                                    # Vamos manter o BitmapDrawable e aplicar clip no frame
                                
                            except Exception as e:
                                log(f"[Nowfy] BG Cover: Error applying corners to bitmap: {e}")
                            
                    except Exception as e:
                        log(f"[Nowfy] BG Cover: Error creating cropped bitmap: {e}")
                        cropped_drawable = cover_drawable  # Fallback para drawable original
                    
                    # Se não conseguiu criar o crop, usar drawable original
                    if not cropped_drawable:
                        cropped_drawable = cover_drawable
                    
                    # 2. Overlay escuro para legibilidade
                    overlay = GD()
                    overlay.setShape(GD.RECTANGLE)
                    
                    try:
                        if Color and hasattr(Color, "parseColor"):
                            overlay.setColor(Color.parseColor("#80000000"))  # 50% transparência
                        elif Color and hasattr(Color, "argb"):
                            overlay.setColor(Color.argb(128, 0, 0, 0))
                    except Exception:
                        pass
                    
                    # Bordas arredondadas - respeitando estado do Mini Control
                    try:
                        radius = AndroidUtilities.dp(24) if AndroidUtilities else 24
                        
                        # Verificar se Mini Control está ativo para ajustar bordas
                        mini_control_enabled = bool(self.get_setting("mini_control_enabled", False))
                        
                        if mini_control_enabled:
                            # Mini Control ativo: bordas inferiores retas
                            radii = [
                                float(radius), float(radius),  # top-left
                                float(radius), float(radius),  # top-right
                                0.0, 0.0,                      # bottom-right (reto)
                                0.0, 0.0                       # bottom-left (reto)
                            ]
                            overlay.setCornerRadii(radii)
                            log("[Nowfy] BG Cover: Applied straight bottom corners for Mini Control")
                        else:
                            # Mini Control inativo: todas as bordas arredondadas
                            overlay.setCornerRadius(float(radius))
                            log("[Nowfy] BG Cover: Applied all rounded corners")
                            
                    except Exception as e:
                        log(f"[Nowfy] BG Cover: Error setting corner radius: {e}")
                        # Fallback para bordas arredondadas normais
                        try:
                            radius = AndroidUtilities.dp(24) if AndroidUtilities else 24
                            overlay.setCornerRadius(float(radius))
                        except Exception:
                            pass
                    
                    # Criar layer drawable com capa cropada
                    layers = [cropped_drawable, overlay]
                    layer_drawable = LayerDrawable(layers)
                    
                    # Aplicar diretamente ao frame
                    frame.setBackground(layer_drawable)
                    
                    # Garantir que o frame faça clip das bordas corretamente
                    try:
                        frame.setClipToOutline(True)
                        # Forçar outline provider para garantir clip correto
                        from hook_utils import find_class
                        ViewOutlineProvider = find_class("android.view.ViewOutlineProvider")
                        if ViewOutlineProvider:
                            frame.setOutlineProvider(ViewOutlineProvider.BACKGROUND)
                    except Exception as e:
                        log(f"[Nowfy] BG Cover: Error setting clip outline: {e}")
                    
                    log("[Nowfy] BG Cover: Applied cropped background with proper clipping")
                    
                else:
                    # Fallback: fundo padrão
                    log("[Nowfy] BG Cover: Required classes not available, using default")
                    self._apply_default_island_background(frame, GD, Color, AndroidUtilities)
                    
            except Exception as e:
                log(f"[Nowfy] BG Cover: Error in simple background: {e}")
                self._apply_default_island_background(frame, GD, Color, AndroidUtilities)
            
        except Exception as e:
            try:
                log(f"[Nowfy] Failed to apply BG cover background: {e}")
            except Exception:
                pass

    def _apply_no_blur_island_background(self, frame, GD, Color, BitmapDrawable, AndroidUtilities):
        """Aplica a capa da música como fundo SEM blur - igual ao BG Cover mas sem desfoque"""
        try:
            # Limpar qualquer background anterior criado pela implementação complexa
            try:
                if hasattr(self, "_di_bg_image") and self._di_bg_image:
                    frame.removeView(self._di_bg_image)
                    self._di_bg_image = None
            except Exception:
                pass
            try:
                if hasattr(self, "_di_bg_overlay") and self._di_bg_overlay:
                    frame.removeView(self._di_bg_overlay)
                    self._di_bg_overlay = None
            except Exception:
                pass
            
            # Obter a capa atual
            cover = getattr(self, "_di_cover", None)
            if not cover:
                log("[Nowfy] No Blur: No cover found, using default background")
                self._apply_default_island_background(frame, GD, Color, AndroidUtilities)
                return
            
            # Obter o drawable da capa
            cover_drawable = cover.getDrawable()
            if not cover_drawable:
                log("[Nowfy] No Blur: No drawable found, using default background")
                self._apply_default_island_background(frame, GD, Color, AndroidUtilities)
                return
            
            log("[Nowfy] No Blur: Applying background without blur")
            
            # Abordagem com CROP: criar bitmap redimensionado para o formato da ilha (SEM BLUR)
            try:
                from hook_utils import find_class
                LayerDrawable = find_class("android.graphics.drawable.LayerDrawable")
                BitmapDrawable = find_class("android.graphics.drawable.BitmapDrawable")
                Bitmap = find_class("android.graphics.Bitmap")
                Canvas = find_class("android.graphics.Canvas")
                Paint = find_class("android.graphics.Paint")
                Rect = find_class("android.graphics.Rect")
                RectF = find_class("android.graphics.RectF")
                
                if LayerDrawable and GD and BitmapDrawable and Bitmap:
                    # Obter dimensões reais da ilha (adaptável ao conteúdo) - igual ao BG Cover
                    try:
                        # Usar as dimensões reais do frame para se adaptar ao texto
                        frame.measure(0, 0)  # Forçar medição
                        island_width = max(frame.getMeasuredWidth(), AndroidUtilities.dp(200) if AndroidUtilities else 200)
                        island_height = max(frame.getMeasuredHeight(), AndroidUtilities.dp(80) if AndroidUtilities else 80)
                        
                        # Garantir dimensões mínimas e máximas razoáveis
                        min_width = AndroidUtilities.dp(200) if AndroidUtilities else 200
                        max_width = AndroidUtilities.dp(400) if AndroidUtilities else 400
                        island_width = max(min_width, min(island_width, max_width))
                        
                        log(f"[Nowfy] No Blur: Using adaptive width {island_width}x{island_height}")
                    except Exception as e:
                        log(f"[Nowfy] No Blur: Error getting frame dimensions: {e}")
                        # Fallback para dimensões fixas menores
                        island_width = AndroidUtilities.dp(250) if AndroidUtilities else 250
                        island_height = AndroidUtilities.dp(80) if AndroidUtilities else 80
                    
                    # Criar bitmap cropado da capa (SEM BLUR)
                    cropped_drawable = None
                    try:
                        # Obter bitmap da capa original
                        if hasattr(cover_drawable, "getBitmap"):
                            original_bitmap = cover_drawable.getBitmap()
                        else:
                            # Fallback: criar bitmap a partir do drawable
                            original_bitmap = Bitmap.createBitmap(
                                island_width, island_height, Bitmap.Config.ARGB_8888
                            )
                            canvas = Canvas(original_bitmap)
                            cover_drawable.setBounds(0, 0, island_width, island_height)
                            cover_drawable.draw(canvas)
                        
                        if original_bitmap:
                            # Calcular crop para CENTER_CROP
                            orig_width = original_bitmap.getWidth()
                            orig_height = original_bitmap.getHeight()
                            
                            # Crop CENTER_CROP nativo - igual à capa circular (SEM distorção)
                            
                            # Calcular escala para preencher completamente (CENTER_CROP)
                            scale_x = float(island_width) / float(orig_width)
                            scale_y = float(island_height) / float(orig_height)
                            scale = max(scale_x, scale_y)  # Maior escala para preencher
                            
                            # Dimensões após escala (mantendo proporção)
                            new_width = int(orig_width * scale)
                            new_height = int(orig_height * scale)
                            
                            # Crop para pegar a parte central/superior
                            crop_x = (new_width - island_width) // 2
                            crop_y = int((new_height - island_height) * 0.3)  # 30% do topo
                            
                            # Garantir limites válidos
                            crop_x = max(0, crop_x)
                            crop_y = max(0, crop_y)
                            
                            # Escalar bitmap mantendo proporção
                            scaled_bitmap = Bitmap.createScaledBitmap(
                                original_bitmap, new_width, new_height, True
                            )
                            
                            # Crop final - exatamente como CENTER_CROP faria
                            cropped_bitmap = Bitmap.createBitmap(
                                scaled_bitmap, crop_x, crop_y, island_width, island_height
                            )
                            
                            # DIFERENÇA: NÃO aplicar blur - usar bitmap direto
                            final_bitmap = cropped_bitmap  # SEM BLUR!
                            
                            # Criar drawable do bitmap processado
                            cropped_drawable = BitmapDrawable(frame.getContext().getResources(), final_bitmap)
                            
                            # Aplicar bordas arredondadas ao drawable da capa também
                            try:
                                # Criar um GradientDrawable para aplicar bordas ao bitmap
                                bitmap_bg = GD()
                                bitmap_bg.setShape(GD.RECTANGLE)
                                
                                # Usar o bitmap como textura
                                from hook_utils import find_class
                                BitmapShader = find_class("android.graphics.BitmapShader")
                                Shader = find_class("android.graphics.Shader")
                                
                                if BitmapShader and Shader:
                                    shader = BitmapShader(final_bitmap, Shader.TileMode.CLAMP, Shader.TileMode.CLAMP)
                                    # Nota: GradientDrawable não suporta shader diretamente
                                    # Vamos manter o BitmapDrawable e aplicar clip no frame
                                
                            except Exception as e:
                                log(f"[Nowfy] No Blur: Error applying corners to bitmap: {e}")
                            
                    except Exception as e:
                        log(f"[Nowfy] No Blur: Error creating cropped bitmap: {e}")
                        cropped_drawable = cover_drawable  # Fallback para drawable original
                    
                    # Se não conseguiu criar o crop, usar drawable original
                    if not cropped_drawable:
                        cropped_drawable = cover_drawable
                    
                    # 2. Overlay escuro para legibilidade (igual ao BG Cover)
                    overlay = GD()
                    overlay.setShape(GD.RECTANGLE)
                    
                    try:
                        if Color and hasattr(Color, "parseColor"):
                            overlay.setColor(Color.parseColor("#80000000"))  # 50% transparência
                        elif Color and hasattr(Color, "argb"):
                            overlay.setColor(Color.argb(128, 0, 0, 0))
                    except Exception:
                        pass
                    
                    # Bordas arredondadas - respeitando estado do Mini Control
                    try:
                        radius = AndroidUtilities.dp(24) if AndroidUtilities else 24
                        
                        # Verificar se Mini Control está ativo para ajustar bordas
                        mini_control_enabled = bool(self.get_setting("mini_control_enabled", False))
                        
                        if mini_control_enabled:
                            # Mini Control ativo: bordas inferiores retas
                            radii = [
                                float(radius), float(radius),  # top-left
                                float(radius), float(radius),  # top-right
                                0.0, 0.0,                      # bottom-right (reto)
                                0.0, 0.0                       # bottom-left (reto)
                            ]
                            overlay.setCornerRadii(radii)
                            log("[Nowfy] No Blur: Applied straight bottom corners for Mini Control")
                        else:
                            # Mini Control inativo: todas as bordas arredondadas
                            overlay.setCornerRadius(float(radius))
                            log("[Nowfy] No Blur: Applied all rounded corners")
                            
                    except Exception as e:
                        log(f"[Nowfy] No Blur: Error setting corner radius: {e}")
                        # Fallback para bordas arredondadas normais
                        try:
                            radius = AndroidUtilities.dp(24) if AndroidUtilities else 24
                            overlay.setCornerRadius(float(radius))
                        except Exception:
                            pass
                    
                    # Criar layer drawable com capa cropada (SEM BLUR)
                    layers = [cropped_drawable, overlay]
                    layer_drawable = LayerDrawable(layers)
                    
                    # Aplicar diretamente ao frame
                    frame.setBackground(layer_drawable)
                    
                    # Garantir que o frame faça clip das bordas corretamente
                    try:
                        frame.setClipToOutline(True)
                        # Forçar outline provider para garantir clip correto
                        from hook_utils import find_class
                        ViewOutlineProvider = find_class("android.view.ViewOutlineProvider")
                        if ViewOutlineProvider:
                            frame.setOutlineProvider(ViewOutlineProvider.BACKGROUND)
                    except Exception as e:
                        log(f"[Nowfy] No Blur: Error setting clip outline: {e}")
                    
                    log("[Nowfy] No Blur: Applied cropped background without blur")
                    
                else:
                    # Fallback: fundo padrão
                    log("[Nowfy] No Blur: Required classes not available, using default")
                    self._apply_default_island_background(frame, GD, Color, AndroidUtilities)
                    
            except Exception as e:
                log(f"[Nowfy] No Blur: Error in background application: {e}")
                self._apply_default_island_background(frame, GD, Color, AndroidUtilities)
            
        except Exception as e:
            try:
                log(f"[Nowfy] Failed to apply No Blur background: {e}")
            except Exception:
                pass
            
            # Fallback para fundo padrão
            self._apply_default_island_background(frame, GD, Color, AndroidUtilities)

    def _apply_pure_island_background(self, frame, GD, Color, AndroidUtilities):
        """Aplica estilo Pure - totalmente transparente, sem fundo"""
        try:
            # Remover qualquer background
            frame.setBackground(None)
            
            # Garantir transparência total
            try:
                frame.setBackgroundColor(0x00000000)  # Totalmente transparente
            except Exception:
                pass
            
            log("[Nowfy] Pure Style: Applied transparent background")
            
        except Exception as e:
            try:
                log(f"[Nowfy] Failed to apply pure background: {e}")
            except Exception:
                pass


    def _apply_blur_and_darken(self, bitmap):
        """Aplica blur e escurecimento ao bitmap da capa"""
        try:
            from PIL import Image, ImageFilter, ImageEnhance
            import io
            
            # Converter Android Bitmap para PIL Image
            try:
                from hook_utils import find_class
                ByteArrayOutputStream = find_class("java.io.ByteArrayOutputStream")
                CompressFormat = find_class("android.graphics.Bitmap$CompressFormat")
                
                if ByteArrayOutputStream and CompressFormat:
                    # Converter bitmap para bytes
                    stream = ByteArrayOutputStream()
                    bitmap.compress(CompressFormat.PNG, 100, stream)
                    byte_array = stream.toByteArray()
                    stream.close()
                    
                    # Converter para PIL Image
                    pil_image = Image.open(io.BytesIO(byte_array))
                    
                    # Aplicar blur mais forte (desfoque)
                    blurred_image = pil_image.filter(ImageFilter.GaussianBlur(radius=15))
                    
                    # Aplicar escurecimento
                    enhancer = ImageEnhance.Brightness(blurred_image)
                    darkened_image = enhancer.enhance(0.6)  # 60% do brilho original (40% mais escuro)
                    
                    # Converter de volta para Android Bitmap
                    output_stream = io.BytesIO()
                    darkened_image.save(output_stream, format='PNG')
                    output_bytes = output_stream.getvalue()
                    output_stream.close()
                    
                    # Criar novo bitmap Android
                    BitmapFactory = find_class("android.graphics.BitmapFactory")
                    if BitmapFactory:
                        processed_bitmap = BitmapFactory.decodeByteArray(output_bytes, 0, len(output_bytes))
                        if processed_bitmap:
                            log("[Nowfy] BG Cover: Applied blur and darkening")
                            return processed_bitmap
                
            except Exception as e:
                log(f"[Nowfy] BG Cover: Error in blur/darken processing: {e}")
            
            # Fallback: retornar bitmap original se o processamento falhar
            log("[Nowfy] BG Cover: Using original bitmap (blur/darken failed)")
            return bitmap
            
        except Exception as e:
            log(f"[Nowfy] BG Cover: Error in _apply_blur_and_darken: {e}")
            return bitmap

    def _apply_mini_control_backdrop_blur(self, mini_controls, ctx):
        """Aplica backdrop blur especificamente ao mini control para ocultar texto atrás"""
        try:
            log("[Nowfy] Mini Control Backdrop Blur: Starting application")
            
            from hook_utils import find_class
            
            # Classes necessárias
            GradientDrawable = find_class("android.graphics.drawable.GradientDrawable")
            Bitmap = find_class("android.graphics.Bitmap")
            Canvas = find_class("android.graphics.Canvas")
            Paint = find_class("android.graphics.Paint")
            BitmapDrawable = find_class("android.graphics.drawable.BitmapDrawable")
            LayerDrawable = find_class("android.graphics.drawable.LayerDrawable")
            AndroidUtilities = find_class("org.telegram.messenger.AndroidUtilities")
            
            if not all([GradientDrawable, Bitmap, Canvas, Paint, BitmapDrawable, LayerDrawable]):
                log("[Nowfy] Mini Control Backdrop Blur: Required classes not available")
                raise Exception("Required classes not available")
            
            # Obter dimensões do mini control
            try:
                # Forçar medição do mini control
                mini_controls.measure(0, 0)
                width = mini_controls.getMeasuredWidth()
                height = mini_controls.getMeasuredHeight()
                
                # Se ainda não tem dimensões, usar valores padrão
                if width <= 0 or height <= 0:
                    width = AndroidUtilities.dp(200) if AndroidUtilities else 200
                    height = AndroidUtilities.dp(52) if AndroidUtilities else 52
                
                log(f"[Nowfy] Mini Control Backdrop Blur: Dimensions {width}x{height}")
                
            except Exception as e:
                log(f"[Nowfy] Mini Control Backdrop Blur: Error getting dimensions: {e}")
                width = AndroidUtilities.dp(200) if AndroidUtilities else 200
                height = AndroidUtilities.dp(52) if AndroidUtilities else 52
            
            # Criar bitmap para captura do fundo
            backdrop_bitmap = Bitmap.createBitmap(width, height, Bitmap.Config.ARGB_8888)
            backdrop_canvas = Canvas(backdrop_bitmap)
            
            # Preencher com cor base escura
            backdrop_canvas.drawColor(0xFF1A1A1A)
            
            # Tentar capturar o que está atrás do mini control
            try:
                # Obter a view pai (container principal)
                parent_view = mini_controls.getParent()
                if parent_view and hasattr(parent_view, 'draw'):
                    # Salvar estado atual
                    current_visibility = mini_controls.getVisibility()
                    
                    # Temporariamente ocultar o mini control
                    mini_controls.setVisibility(8)  # INVISIBLE
                    
                    # Capturar o fundo
                    try:
                        # Salvar e restaurar transformações do canvas
                        backdrop_canvas.save()
                        
                        # Obter posição do mini control relativa ao pai
                        mini_x = mini_controls.getLeft() if hasattr(mini_controls, 'getLeft') else 0
                        mini_y = mini_controls.getTop() if hasattr(mini_controls, 'getTop') else 0
                        
                        # Transladar canvas para capturar a área correta
                        backdrop_canvas.translate(-mini_x, -mini_y)
                        
                        # Desenhar o pai no canvas
                        parent_view.draw(backdrop_canvas)
                        
                        backdrop_canvas.restore()
                        log("[Nowfy] Mini Control Backdrop Blur: Successfully captured background")
                        
                    except Exception as e:
                        log(f"[Nowfy] Mini Control Backdrop Blur: Error in capture: {e}")
                    
                    # Restaurar visibilidade
                    mini_controls.setVisibility(current_visibility)
                    
            except Exception as e:
                log(f"[Nowfy] Mini Control Backdrop Blur: Error in background capture: {e}")
            
            # Aplicar blur ao bitmap capturado
            blurred_bitmap = self._apply_simple_blur_mini_control(backdrop_bitmap, 15)  # Blur médio para mini control
            
            if blurred_bitmap:
                # Criar drawable do bitmap com blur
                blurred_drawable = BitmapDrawable(ctx.getResources(), blurred_bitmap)
                
                # Criar overlay escuro para garantir legibilidade dos ícones
                overlay = GradientDrawable()
                overlay.setShape(GradientDrawable.RECTANGLE)
                overlay.setColor(0x80000000)  # 50% transparência preta
                
                # Bordas arredondadas para o mini control (formato pílula)
                try:
                    radius = AndroidUtilities.dp(18) if AndroidUtilities else 18  # Bem arredondado
                    overlay.setCornerRadius(float(radius))
                    log(f"[Nowfy] Mini Control Backdrop Blur: Applied corner radius {radius}")
                except Exception as e:
                    log(f"[Nowfy] Mini Control Backdrop Blur: Error setting corner radius: {e}")
                
                # Criar layer drawable com fundo blur + overlay
                layers = [blurred_drawable, overlay]
                layer_drawable = LayerDrawable(layers)
                
                # Aplicar ao mini control
                mini_controls.setBackground(layer_drawable)
                
                # Garantir clip correto para bordas arredondadas
                try:
                    mini_controls.setClipToOutline(True)
                    ViewOutlineProvider = find_class("android.view.ViewOutlineProvider")
                    if ViewOutlineProvider:
                        mini_controls.setOutlineProvider(ViewOutlineProvider.BACKGROUND)
                except Exception as e:
                    log(f"[Nowfy] Mini Control Backdrop Blur: Error setting clip: {e}")
                
                log("[Nowfy] Mini Control Backdrop Blur: Successfully applied backdrop blur")
                
            else:
                # Fallback: fundo opaco
                log("[Nowfy] Mini Control Backdrop Blur: Blur failed, using opaque background")
                bg = GradientDrawable()
                bg.setShape(GradientDrawable.RECTANGLE)
                bg.setColor(0xE6151515)  # Fundo bem opaco
                radius = AndroidUtilities.dp(18) if AndroidUtilities else 18
                bg.setCornerRadius(float(radius))
                mini_controls.setBackground(bg)
                
        except Exception as e:
            log(f"[Nowfy] Mini Control Backdrop Blur: Failed to apply: {e}")
            raise e

    def _apply_simple_blur_mini_control(self, bitmap, radius):
        """Aplica blur simples otimizado para o mini control"""
        try:
            if not bitmap:
                return None
                
            log(f"[Nowfy] Mini Control Blur: Applying blur with radius {radius}")
            
            from hook_utils import find_class
            Bitmap = find_class("android.graphics.Bitmap")
            Canvas = find_class("android.graphics.Canvas")
            Paint = find_class("android.graphics.Paint")
            
            if not all([Bitmap, Canvas, Paint]):
                return bitmap
            
            # Criar cópia do bitmap
            width = bitmap.getWidth()
            height = bitmap.getHeight()
            
            # Reduzir resolução para melhor performance (mais agressivo para mini control)
            scale_factor = 0.3  # 30% da resolução original para mini control
            small_width = max(1, int(width * scale_factor))
            small_height = max(1, int(height * scale_factor))
            
            # Criar bitmap menor para blur
            small_bitmap = Bitmap.createScaledBitmap(bitmap, small_width, small_height, True)
            
            # Aplicar blur usando RenderScript se disponível
            try:
                from hook_utils import find_class
                RenderScript = find_class("android.renderscript.RenderScript")
                Allocation = find_class("android.renderscript.Allocation")
                ScriptIntrinsicBlur = find_class("android.renderscript.ScriptIntrinsicBlur")
                
                if RenderScript and Allocation and ScriptIntrinsicBlur:
                    # Usar RenderScript para blur nativo
                    from org.telegram.messenger import ApplicationLoader
                    rs = RenderScript.create(ApplicationLoader.applicationContext)
                    input_allocation = Allocation.createFromBitmap(rs, small_bitmap)
                    output_allocation = Allocation.createTyped(rs, input_allocation.getType())
                    
                    blur_script = ScriptIntrinsicBlur.create(rs, input_allocation.getElement())
                    blur_script.setRadius(min(25.0, max(1.0, float(radius))))
                    blur_script.setInput(input_allocation)
                    blur_script.forEach(output_allocation)
                    
                    output_allocation.copyTo(small_bitmap)
                    
                    rs.destroy()
                    log("[Nowfy] Mini Control Blur: Used RenderScript blur")
                    
            except Exception as e:
                log(f"[Nowfy] Mini Control Blur: RenderScript failed, using fallback: {e}")
                # Fallback: aplicar escurecimento simples para simular blur
                canvas = Canvas(small_bitmap)
                paint = Paint()
                paint.setColor(0x60000000)  # Overlay mais escuro para mini control
                canvas.drawRect(0, 0, small_width, small_height, paint)
            
            # Escalar de volta para o tamanho original
            blurred_bitmap = Bitmap.createScaledBitmap(small_bitmap, width, height, True)
            
            log("[Nowfy] Mini Control Blur: Blur applied successfully")
            return blurred_bitmap
            
        except Exception as e:
            log(f"[Nowfy] Mini Control Blur: Error applying blur: {e}")
            return bitmap

    def _apply_control_style_to_overlay(self):
        try:
            icons = self._di_icon_sources()
            # Atualiza mapa de fallbacks para novas URLs primárias (somente quando existir)
            fb_map = {}
            try:
                for k in icons:
                    p = icons[k].get("primary")
                    f = icons[k].get("fallback")
                    if p and f:
                        fb_map[p] = f
            except Exception:
                fb_map = {}
            try:
                if isinstance(self._di_icon_fallbacks, dict):
                    self._di_icon_fallbacks.update(fb_map)
                else:
                    self._di_icon_fallbacks = fb_map
            except Exception:
                self._di_icon_fallbacks = fb_map

            play_url = icons.get("play", {}).get("primary")
            pause_url = icons.get("pause", {}).get("primary")
            back_url = icons.get("back", {}).get("primary")
            next_url = icons.get("next", {}).get("primary")
            send_url = icons.get("send", {}).get("primary")

            # Limpa cache local para evitar colisão de nomes entre estilos
            try:
                import os
                cd = self._di_cache_dir()
                if cd:
                    for n in ("back.png","play.png","pause.png","next.png","send.png","search.png"):
                        p = os.path.join(cd, n)
                        try:
                            if os.path.exists(p):
                                os.remove(p)
                        except Exception:
                            pass
            except Exception:
                pass

            # Atualiza URLs salvas para uso em _toggle_play_pause
            try:
                if play_url:
                    self._di_play_url = play_url
                if pause_url:
                    self._di_pause_url = pause_url
            except Exception:
                pass

            # Reaplica ícones nos botões existentes
            try:
                if hasattr(self, "_di_apply_icon") and callable(self._di_apply_icon):
                    if hasattr(self, "_di_btn_prev") and self._di_btn_prev and back_url:
                        self._di_apply_icon(self._di_btn_prev, back_url)
                    if hasattr(self, "_di_btn_next") and self._di_btn_next and next_url:
                        self._di_apply_icon(self._di_btn_next, next_url)
                    if hasattr(self, "_di_btn_send") and self._di_btn_send and send_url:
                        self._di_apply_icon(self._di_btn_send, send_url)
                    if hasattr(self, "_di_btn_pp") and self._di_btn_pp and (play_url or pause_url):
                        try:
                            is_playing = bool(self._check_music_playing())
                        except Exception:
                            is_playing = False
                        use_url = (pause_url if is_playing else play_url) or play_url or pause_url
                        if use_url:
                            self._di_apply_icon(self._di_btn_pp, use_url)
            except Exception:
                pass
        except Exception as e:
            try:
                log(f"[Nowfy] Failed to apply control style: {e}")
            except Exception:
                pass

    def on_setting_changed(self, key, value):
        if key == "show_chat_menu":
            self.remove_menu_items()
            self._add_menu_items()
        elif key == "enable_now_playing":
            # Atualiza o item do menu de contexto (e chat) quando o switch universal muda
            try:
                self._update_now_playing_context_menu_item()
                self._update_now_playing_chat_menu_item()
            except Exception as e:
                log(f"[Nowfy] Error updating Now Playing menus on setting change: {e}")
        elif key == "nowcast_enabled":
            print(f"[DEBUG] on_setting_changed chamado para nowcast_enabled: {value}")
            if value:
                print("[DEBUG] Ativando NowCast...")
                # Verificar se está configurado corretamente
                if self._verify_nowcast_setup():
                    print("[DEBUG] Configuração verificada com sucesso")
                    # Iniciar worker do NowCast
                    if not self._nowcast_worker_running:
                        import threading
                        print("[DEBUG] Criando thread do NowCast worker...")
                        threading.Thread(target=self._nowcast_worker, daemon=True).start()
                        print("[DEBUG] Thread iniciada")
                        print(f"[NowCast] {NOWCAST_MESSAGES['worker_started']}")
                        
                        # Mostrar bulletin de confirmação
                        print("[DEBUG] Tentando mostrar bulletin de confirmação...")
                        try:
                            BulletinHelper.show_bulletin(
                                NOWCAST_MESSAGES['nowcast_enabled'],
                                NOWCAST_MESSAGES['nowcast_ready']
                            )
                            print("[DEBUG] Bulletin de confirmação enviado com sucesso")
                        except Exception as e:
                            print(f"[DEBUG] Erro ao mostrar bulletin: {e}")
                    else:
                        print("[DEBUG] Worker já está rodando")
                else:
                    print("[DEBUG] Configuração inválida, desativando NowCast")
                    # Desativar se não estiver configurado
                    self.set_setting("nowcast_enabled", False)
                    try:
                        BulletinHelper.show_bulletin(
                            "NowCast",
                            NOWCAST_MESSAGES['nowcast_error']
                        )
                    except Exception as e:
                        print(f"[DEBUG] Erro ao mostrar bulletin de erro: {e}")
            else:
                print("[DEBUG] Desativando NowCast...")
                print(f"[NowCast] {NOWCAST_MESSAGES['worker_stopping']}")
                try:
                    BulletinHelper.show_bulletin(
                        "NowCast",
                        NOWCAST_MESSAGES['nowcast_disabled']
                    )
                    print("[DEBUG] Bulletin de desativação enviado")
                except Exception as e:
                    print(f"[DEBUG] Erro ao mostrar bulletin de desativação: {e}")

    def on_plugin_load(self):
        self.add_on_send_message_hook()
        # Não iniciar cache se logs estiverem desativados
        if not bool(self.get_setting("disable_logs", False)):
            self._start_cache_system()
        self._add_menu_items()
        # Garantir item 'Pop Island' no menu lateral apenas se overlay estiver ativo
        try:
            if bool(self.get_setting("dynamic_island_overlay", False)):
                self._ensure_pop_island_drawer_item()
        except Exception as _e:
            log(f"[Nowfy] Failed to add Floatify drawer item: {_e}")
        
        # Garantir item 'Nowfy' no menu lateral se habilitado
        try:
            if bool(self.get_setting("nowfy_drawer_enabled", False)):
                self._ensure_nowfy_drawer_item()
        except Exception as _e:
            log(f"[Nowfy] Failed to add Nowfy drawer item: {_e}")
        
        # Iniciar NowCast automaticamente se estiver habilitado
        # Evitar iniciar NowCast se logs estiverem desativados
        if self.get_setting("nowcast_enabled", False) and not bool(self.get_setting("disable_logs", False)):
            print("[DEBUG] NowCast habilitado detectado no carregamento do plugin")
            if self._verify_nowcast_setup():
                print("[DEBUG] Iniciando NowCast automaticamente...")
                if not self._nowcast_worker_running:
                    import threading
                    threading.Thread(target=self._nowcast_worker, daemon=True).start()
                    print("[NowCast] Worker iniciado automaticamente")
            else:
                print("[DEBUG] Configuração inválida, desabilitando NowCast")
                self.set_setting("nowcast_enabled", False)
        self._capture_original_bio()

        # Inicializar Chat List automaticamente se estiver habilitado
        try:
            if bool(self.get_setting("chat_list_integration", False)):
                # Usa o caminho de toggle para garantir título, worker e banner em sincronia
                self._toggle_chat_list_integration(True)
        except Exception:
            # Fallback simples: iniciar worker e aplicar banner
            try:
                self._start_chat_list_refresh_worker(15)
            except Exception:
                pass
            try:
                if self.get_setting("chat_list_show_cover", False):
                    self._apply_chat_list_cover_banner()
            except Exception:
                pass

        # Forçar atualização do ActionBar da Chat List ao reabrir o app,
        # se Chat List e Show Cover estiverem ativos e houver música tocando.
        try:
            self._force_update_chat_list_banner_if_playing_on_resume()
        except Exception:
            pass

    def on_plugin_unload(self):
        self._stop_bio_update = True
        if self._bio_update_thread:
            self._bio_update_thread.join(timeout=1)
        try:
            self.remove_menu_items()
        except:
            pass
        # Remover item 'Pop Island' do menu lateral
        try:
            self._remove_pop_island_drawer_item()
        except Exception:
            pass
        # Remover item 'Nowfy' do menu lateral
        try:
            self._remove_nowfy_drawer_item()
        except Exception:
            pass

    def _ensure_pop_island_drawer_item(self):
        try:
            if not getattr(self, "_pop_island_drawer_item", None):
                self._pop_island_drawer_item = self.add_menu_item(MenuItemData(
                    menu_type=MenuItemType.DRAWER_MENU,
                    text=tr("pop_island_drawer") if "pop_island_drawer" in TRANSLATIONS else "Floatify",
                    icon="msg_tone_on",
                    priority=160,
                    on_click=self._on_pop_island_drawer_click,
                ))
        except Exception as e:
            log(f"[Nowfy] Drawer item creation failed: {e}")

    def _remove_pop_island_drawer_item(self):
        try:
            if getattr(self, "_pop_island_drawer_item", None):
                self.remove_menu_item(self._pop_island_drawer_item)
                self._pop_island_drawer_item = None
        except Exception:
            pass

    def _on_pop_island_drawer_click(self, context):
        try:
            self.set_setting("dynamic_island_overlay", True)
        except Exception:
            pass
        try:
            self._di_closed_by_user = False
            self._safe_start_dynamic_island_overlay()
        except Exception:
            try:
                self._di_closed_by_user = False
                self._start_dynamic_island_overlay()
            except Exception as e:
                log(f"[Nowfy] Failed to start Dynamic Island from drawer: {e}")

    def _ensure_nowfy_drawer_item(self):
        try:
            if not getattr(self, "_nowfy_drawer_item", None):
                self._nowfy_drawer_item = self.add_menu_item(MenuItemData(
                    menu_type=MenuItemType.DRAWER_MENU,
                    text=(tr("nowfy_drawer") if "nowfy_drawer" in TRANSLATIONS else "Nowfy"),
                    icon="files_music",
                    priority=159,
                    on_click=lambda ctx: run_on_ui_thread(lambda: self._open_plugin_settings())
                ))
        except Exception as e:
            log(f"[Nowfy] Nowfy drawer item creation failed: {e}")

    def _remove_nowfy_drawer_item(self):
        try:
            if getattr(self, "_nowfy_drawer_item", None):
                self.remove_menu_item(self._nowfy_drawer_item)
                self._nowfy_drawer_item = None
        except Exception:
            pass

    def create_nowcast_info_warning(self):
        return [
            Divider(text=tr("nowcast_info_warning"))
        ]

    def create_chat_list_settings_subfragment(self):
        ui = [
            Divider(text=(tr("chat_list_settings_section") if "chat_list_settings_section" in TRANSLATIONS else "Chat List")),
            Switch(
                key="chat_list_integration",
                text=tr("chat_list_label"),
                subtext=tr("chat_list_sub"),
                default=self.get_setting("chat_list_integration", False),
                icon="msg_list",
                on_change=lambda v: (
                    self._toggle_chat_list_integration(v),
                    self.reload_settings()
                )
            ),
            Switch(
                key="chat_list_show_cover",
                text=tr("chat_list_show_cover_label"),
                subtext=tr("chat_list_show_cover_sub"),
                default=self.get_setting("chat_list_show_cover", False),
                icon="msg_photos",
                on_change=lambda v: (
                    self.set_setting("chat_list_show_cover", bool(v)),
                    self._apply_or_restore_chat_list_banner_on_toggle(bool(v)),
                    self.reload_settings()
                )
            ),
            Divider(text=(tr("cover_animation_section") if "cover_animation_section" in TRANSLATIONS else "Cover Animation")),
        ]

        ui.append(Selector(
            key="chat_list_cover_animation_selector",
            text=(tr("cover_animation_label") if "cover_animation_label" in TRANSLATIONS else "Cover animation"),
            default=self.get_setting("chat_list_cover_animation_selector", 0),
            items=[
                (tr("cover_animation_default") if "cover_animation_default" in TRANSLATIONS else "Default"),
                (tr("cover_animation_moving") if "cover_animation_moving" in TRANSLATIONS else "Moving")
            ],
            icon="msg_photo_curve_remix",
            on_change=lambda v: (
                self.set_setting("chat_list_cover_animation_selector", int(v)),
                self._apply_or_restore_chat_list_banner_on_toggle(self.get_setting("chat_list_show_cover", False)),
                (self._stop_chat_list_cover_animation(), self._start_chat_list_cover_animation()) if (self.get_setting("chat_list_integration", False) and self.get_setting("chat_list_show_cover", False) and int(v) > 0) else None,
                self.reload_settings()
            )
        ))

        # Exibir seletor de velocidade somente quando "Moving" estiver escolhido
        if int(self.get_setting("chat_list_cover_animation_selector", 0)) == 1:
            ui.append(Selector(
                key="chat_list_cover_anim_speed",
                text=(tr("cover_anim_speed_label") if "cover_anim_speed_label" in TRANSLATIONS else "Moving speed"),
                default=self.get_setting("chat_list_cover_anim_speed", 1),
                items=[
                    (tr("speed_slow") if "speed_slow" in TRANSLATIONS else "Slow"),
                    (tr("speed_normal") if "speed_normal" in TRANSLATIONS else "Normal"),
                    (tr("speed_fast") if "speed_fast" in TRANSLATIONS else "Fast")
                ],
                icon="msg_speed",
                on_change=lambda v: (
                    self.set_setting("chat_list_cover_anim_speed", int(v)),
                    (self._stop_chat_list_cover_animation(), self._start_chat_list_cover_animation()) if (self.get_setting("chat_list_integration", False) and self.get_setting("chat_list_show_cover", False) and int(self.get_setting("chat_list_cover_animation_selector", 0)) == 1) else None,
                    self.reload_settings()
                )
            ))

        return ui

    def create_nowcast_how_to_use(self):
        return [
            Divider(text=tr("nowcast_how_to_use") if "nowcast_how_to_use" in TRANSLATIONS else "HOW TO USE NOWCAST\n\nATIVAÇÃO:\n• Use o comando .bot para ativar e iniciar o NowCast.\n\nFUNCIONAMENTO:\n• Após alguns segundos, uma notificação (bulletin) aparecerá exibindo a música atual.\n• Em seguida, dentro de mais alguns segundos, o bot realizará o primeiro post no canal configurado.\n\nDESATIVAÇÃO AUTOMÁTICA:\n• Se a música ficar em pausa/inativa por mais de 10 minutos, o NowCast será desativado automaticamente.\n\nCOMPATIBILIDADE:\n• NowCast é exclusivo para Spotify (API).")
        ]

    def create_settings(self):
        show_credentials = self.get_setting("show_credentials", False)
        show_cache_settings = self.get_setting("show_cache_settings", False)
        custom_fonts = self._list_custom_fonts()
        font_selector = self.get_setting("font_selector", 0)
        font_items = [
            "SourceSansPro",
            "exteraCJK",
            "NotoNaskhArabic"
        ]
        if custom_fonts:
            font_items += custom_fonts
        settings = []
        
        # ═══════════════════════════════════════════════════════════════
        # CREDENCIAIS E AUTENTICAÇÃO
        # ═══════════════════════════════════════════════════════════════
        settings.append(Divider(text=tr("credentials_section")))
        


        # Spotify Credentials
        settings.append(
            Text(
                text=tr("spotify_credentials"),
                icon="menu_feature_reliable",
                create_sub_fragment=self.create_spotify_credentials_subfragment
            )
        )
        
        # Last.FM Credentials
        settings.append(
            Text(
                text=tr("lastfm_credentials"),
                icon="msg_permissions_solar",
                create_sub_fragment=self.create_lastfm_credentials_subfragment
            )
        )
        
        # Stats.FM Credentials
        settings.append(
            Text(
                text=tr("statsfm_credentials"),
                icon="menu_username_change",
                create_sub_fragment=self.create_statsfm_credentials_subfragment
            )
        )
        
        # ═══════════════════════════════════════════════════════════════
        # NOWCAST
        # ═══════════════════════════════════════════════════════════════
        settings.append(Divider(text=tr("nowcast_section")))
        
        # NowCast Settings
        settings.append(
            Text(
                text=tr("NowCast"),
                icon="filled_premium_bots",
                create_sub_fragment=self.create_nowcast_subfragment
            )
        )
        
        # ═══════════════════════════════════════════════════════════════
        # POP ISLAND
        # ═══════════════════════════════════════════════════════════════
        settings.extend([
            Divider(text=(tr("pop_island_section") if "pop_island_section" in TRANSLATIONS else "Floatify for Spotify • β")),
            Text(
                text=(tr("pop_island_settings_title") if "pop_island_settings_title" in TRANSLATIONS else "Floatify"),
                icon="msg_tone_on",
                create_sub_fragment=self.create_pop_island_subfragment
            )
        ])
        # Criar um novo divisor para separar Chat List da seção Floatify
        settings.extend([
            Divider(text=(tr("chat_list_divider_label") if "chat_list_divider_label" in TRANSLATIONS else "Chat List • β")),
            Text(
                text=(tr("chat_list_settings_header") if "chat_list_settings_header" in TRANSLATIONS else "Chat List (Beta)"),
                icon="msg_list",
                create_sub_fragment=self.create_chat_list_settings_subfragment
            )
        ])
        
        # ═══════════════════════════════════════════════════════════════
        # TEMAS E CONFIGURAÇÕES
        # ═══════════════════════════════════════════════════════════════
        
        # Temas unificados incluindo LastFM - StatsFM
        external_themes = self._get_external_themes()
        self._nlog(f"[NowFy] External themes found: {len(external_themes)}")
        theme_items = ["Apple"]
        # Adicionar temas externos diretamente na lista
        if external_themes:
            for theme_id, theme_data in external_themes.items():
                theme_items.append(theme_data['name'])
                self._nlog(f"[NowFy] Added external theme: {theme_data['name']}")
        # Adicionar tema Spotlight
        theme_items.append("Spotlight")
        # Adicionar tema Vinify
        theme_items.append("Vinify")
        # Adicionar novo tema Nowv
        theme_items.append("Nowv")
        # CustomFM sempre como penúltimo
        theme_items.append("CustomFM (Global)")
        # Mantém o tema Minimal sempre por último
        theme_items.append(tr("minimal"))
        self._nlog(f"[NowFy] Total theme items: {len(theme_items)}")
        settings.extend([
            Divider(text=tr("theme_selection_section")),
            # Seleção de Tema
            Selector(
                key="theme_selector",
                text=tr("theme_selector"),
                default=0,
                items=theme_items,
                icon="msg_theme",
                on_change=lambda v: self.reload_settings()
            )
        ])
        
        # Apple Skins - aparece logo após o Card Theme se Apple estiver selecionado
        current_theme = self.get_setting("theme_selector", 0)
        if current_theme == 0:  # Tema Apple
            settings.append(self._get_apple_skin_selector())
        
        # Spotlight Skins - aparece quando Spotlight estiver selecionado
        spotlight_index = len(external_themes) + 1  # Apple(0) + external_themes + Spotlight
        if current_theme == spotlight_index:  # Tema Spotlight
            settings.append(self._get_spotlight_skin_selector())
        
        # Calcular o índice do tema Minimal
        external_themes = self._get_external_themes()
        minimal_index = len(theme_items) - 1  # Minimal é sempre o último tema
        
        # Adicionar seletor de fontes apenas se não for o tema Minimal
        if current_theme != minimal_index:
            settings.append(
                Selector(
                    key="font_selector",
                    text=tr("font_selector_label"),
                    default=0,
                    items=font_items,
                    icon="msg_photo_text_framed3",
                )
            )
        
        # Divider anterior - Aparência
        settings.extend([
            Divider(text=tr("appearance_options_section")),
            # Opções de Aparência
        ])

        # Efeito visual ao enviar - AuraSend
        settings.append(
            Switch(
                key="enable_aurasend_on_send",
                text="AuraSend",
                subtext=tr("send_visual_effect_sub"),
                default=False,
                icon="menu_premium_effects",
                on_change=lambda v: self.reload_settings()
            )
        )
        
        # Quick Dismiss - fecha o diálogo logo após enviar o card
        settings.append(
            Switch(
                key="enable_quick_dismiss",
                text=tr("quick_dismiss_label"),
                subtext=tr("quick_dismiss_subtext"),
                default=True,
                icon="loading_animation",
                on_change=lambda v: self.reload_settings()
            )
        )

        # Novo Divider - Seção de Now Playing
        settings.extend([
            Divider(text=tr("now_playing_section")),
        ])

        # Now Playing - funcionalidade principal
        settings.append(
            Switch(
                key="enable_now_playing",
                text=tr("now_playing_label"),
                subtext=tr("now_playing_sub"),
                default=False,
                icon="msg_round_play_m",
                on_change=lambda v: (
                    self._update_now_playing_context_menu_item(),
                    self._update_now_playing_chat_menu_item(),
                    self.reload_settings()  # força recarregar a exibição do selector
                )
            )
        )

        # Chat List foi movido para a seção Experimental


        # Now Card Source - aparece apenas se Now Playing estiver ativado
        if self.get_setting("enable_now_playing", False):
            settings.append(
                Selector(
                    key="now_card_source",
                    text=tr("now_card_source_label"),
                    default=0,
                    items=[
                        "Spotify",
                        "Stats.fm", 
                        "Last.fm",
                        "AyuGram",
                        "exteraGram"
                    ],
                    icon="live_stream",
                    on_change=lambda v: self.reload_settings()
                )
            )

        # ExteraBar - aparece apenas se Apple estiver selecionado
        if current_theme == 0:  # Tema Apple
            settings.append(
                Switch(
                    key="show_extera_bar",
                    text=tr("extera_bar_label"),
                    subtext=tr("extera_bar_sub"),
                    default=True,
                    icon="msg_noise_on",
                    on_change=lambda v: self.reload_settings()
                )
            )

        #  - Seção Extra
        settings.extend([
            Divider(text=tr("extra_section")),
        ])

        # Random Theme Mode
        settings.append(
            Switch(
                key="random_theme_mode",
                text=tr("random_theme_mode"),
                subtext=tr("random_theme_mode_sub"),
                default=False,
                icon="menu_random",
            )
        )

        # Show Caption
        settings.append(
            Switch(
                key="show_caption",
                text=tr("show_caption"),
                default=True,
                icon="msg_chats_add_solar",
                on_change=lambda v: self.reload_settings()
            )
        )

        # Caption Style - aparece apenas se show_caption estiver ativo (True)
        if self.get_setting("show_caption", True):
            caption_style_items = [
                "Custom",
                "Apple Based", 
                "Pepe",
                "Minim",
                "Spoty"
            ]
            
            settings.append(
                Selector(
                    key="caption_style",
                    text=tr("caption_style"),
                    default=0,
                    items=caption_style_items,
                    icon="msg_photo_text_framed3",
                    on_change=lambda v: self.reload_settings()
                )
            )
            
            # Custom Footer Text - aparece apenas se caption_style for "Custom" (índice 0)
            if self.get_setting("caption_style", 0) == 0:
                settings.append(
                    Input(
                        key="custom_footer_text",
                        text=tr("custom_caption"),
                        default="",
                        icon="menu_topic_add",
                    )
                )

        settings.extend([
            Divider(text=tr("customization_section")),
            # Personalização - UI dinâmica baseada no tema selecionado
            *self._get_dynamic_ui_options(theme_items),
            Text(
                text=tr("link_options_header"),
                icon="msg_link2_remix",
                create_sub_fragment=self.create_link_options_subfragment
            ),
            Text(
                text=tr("how_to_use_premium_emoji"),
                accent=True,
                icon="msg_premium_prolfilestar",
                on_click=lambda view: self._show_premium_emoji_help()
            ),
            Divider(text=tr("help_info_section")),
            # Ajuda e Informações
            Text(
                text=tr("about_custom_fonts"),
                icon="msg_info",
                accent=True,
                on_click=lambda v: self._about_custom_fonts_dialog()
            ),
            Divider(),
        ])
        
        # 1. Bio Features (painel expansível) - PRIMEIRA SEÇÃO
        settings.append(Divider())
        settings.append(
            Switch(
                key="show_smart_bio_panel",
                text=tr("smart_bio_header"),
                subtext=tr("smart_bio_panel_sub"),
                default=False,
                icon="msg_contacts",
                on_change=lambda v: self.reload_settings()
            )
        )
        if self.get_setting("show_smart_bio_panel", False):
            settings.extend([
                Divider(text=tr("bio_automation_section")),
                
                # Automação da Bio
                Switch(key="enable_autobio", text=tr("smart_bio_enabled"), subtext=tr("autobio_sub"), default=False, icon="gift_upgrade"),
                Switch(key="enable_auto_bio_update", text=tr("smart_bio_auto_refresh"), subtext=tr("enable_auto_bio_update_sub"), default=False, icon="menu_browser_refresh"),
                Switch(key="show_bio_notification", text=tr("show_bio_notification"), subtext=tr("show_bio_notification_sub"), default=True, icon="msg2_notifications"),
                
                Divider(text=tr("bio_customization_section")),
                
                # Personalização da Bio
                Input(key="autobio_text", text=tr("bio_text"), default="Now Playing: {track} by {artist}", icon="msg_addbio"),
                Input(key="restore_bio_text", text=tr("restore_bio_text"), default="I'm using nowFy!", icon="msg_saved"),
                
                Divider(text=tr("bio_help_section")),
                
                # Ajuda e Informações
                Text(
                    text=tr("bio_command_info"),
                    icon="msg2_help",
                    accent=True,
                    on_click=lambda view: self._show_bio_command_info_dialog()
                ),
            ])
        
        # 2. Cache Settings - SEGUNDA SEÇÃO
        settings.append(Divider())
        settings.append(
            Switch(
                key="show_cache_settings",
                text=tr("show_cache_settings"),
                default=False,
                subtext=tr("show_cache_settings_sub"),
                icon="msg_addfolder",
                on_change=lambda v: self.reload_settings()
            )
        )
        if self.get_setting("show_cache_settings", False):
            settings.extend([
                # Configurações básicas de cache
                Switch(key="enable_cache", text=tr("enable_cache"), subtext=tr("enable_cache_sub"), default=False, icon="msg_photos_solar", on_change=lambda v: self._toggle_cache_system(v)),
                Switch(key="enable_compression", text=tr("enable_compression"), subtext=tr("enable_compression_sub"), default=False, icon="msg_addphoto_solar"),
                Input(key="cache_ttl", text=tr("cache_ttl"), default="5", icon="menu_clear_cache_remix"),
                
                Divider(text=tr("cache_performance_section")),
                
                # Otimizações de Performance
                Switch(key="enhanced_cache", text=tr("enhanced_cache"), subtext=tr("enhanced_cache_sub"), default=True, icon="msg_speed"),
                Selector(key="performance_mode", text=tr("performance_mode"), default=1, icon="qr_flashlight_remix", items=[
                    tr("turbo_mode") if "turbo_mode" in TRANSLATIONS else "Turbo",
                    tr("balanced_mode") if "balanced_mode" in TRANSLATIONS else "Balanceado",
                    tr("quality_mode") if "quality_mode" in TRANSLATIONS else "Qualidade"
                ]),
                Switch(key="enable_preload", text=tr("enable_preload"), subtext=tr("enable_preload_sub"), default=False, icon="msg_download"), 
                # Advanced Options
                Text(
                    text=tr("advanced_options_title"),
                    icon="msg_customize",
                    create_sub_fragment=self.create_advanced_options_subfragment
                ),
                Divider(text=tr("cache_management_section")),
                # Gerenciamento de cache
                Text(text=tr("clear_cache"), on_click=lambda v: self._clear_cache(), icon="msg_clear_solar", red=True),
            ])
        
        # 3. Miscellaneous - TERCEIRA SEÇÃO
        settings.append(Divider())
        settings.append(
            Switch(
                key="show_diversos",
                text=tr("diversos_header"),
                subtext=tr("diversos_sub"),
                default=False,
                icon="notifications_settings",
                on_change=lambda v: self.reload_settings()
            )
        )
        if self.get_setting("show_diversos", False):
            settings.extend([
                # Configurações de Comando
                Divider(text=tr("command_settings_section")),
                Input(
                    key="custom_command",
                    text=tr("diversos_custom_command"),
                    default=".now",
                    icon="input_bot1"
                ),
                # Configurações de Interface
                Divider(text=tr("interface_settings_section")),
                Switch(
                    key="show_chat_menu",
                    text=tr("diversos_show_chat_menu"),
                    default=True,
                    subtext=tr("show_chat_menu_sub"),
                    icon="preview_dots",
                    on_change=lambda v: self.reload_settings()
                ),

                Switch(
                    key="nowfy_drawer_enabled",
                    text=(tr("nowfy_drawer_label") if "nowfy_drawer_label" in TRANSLATIONS else "Show Nowfy in side menu"),
                    subtext=(tr("nowfy_drawer_sub") if "nowfy_drawer_sub" in TRANSLATIONS else "Adds a Nowfy shortcut to the drawer"),
                    default=self.get_setting("nowfy_drawer_enabled", False),
                    icon="msg_list",
                    on_change=lambda v: (
                        self._ensure_nowfy_drawer_item() if v else self._remove_nowfy_drawer_item(),
                        self.reload_settings()
                    )
                ),

                # Detecção de Música
                Divider(text=tr("music_detection_section")),
                Selector(
                    key="current_player",
                    icon="header_goinline_solar",
                    text=tr("active_player"),
                    default=0,
                    items=["Spotify", "YouTube", "YouTube Music", "exteraGram", "AyuGram", "SoundCloud", "Apple Music", "Yandex Music", "FM"],
                    on_change=lambda value: self._on_player_changed(value)
                ),
            ])
            
            # Ícone personalizado já está implementado no CustomFM UI
            
            # Obter configuração do player atual
            current_player_setting = self.get_setting("current_player", 0)
            
            # Mostrar "Modo de Dados" apenas quando Spotify estiver selecionado
            if current_player_setting == 0:  # Spotify
                settings.append(
                    Selector(
                        key="media_source",
                        icon="msg_filled_datausage",
                        text=tr("data_mode"),
                        default=0,
                        items=["Player", "Via Last.FM"]
                    )
                )
            
            settings.extend([
                # APIs e Integração
                Divider(text=tr("apis_integration_section")),
                Selector(
                    key="artwork_priority",
                    icon="msg_saved_ny_remix",
                    text=tr("diversos_artwork_api"),
                    default=0,
                    items=["Default", "Spotify", "Deezer", "Cover Art Archive", "iTunes", "YouTube", "LastFM"]
                ),

                # YouTube API agora usa chave universal integrada
                # Ajuda e Informações
                Divider(text=tr("help_info_section")),
                Text(
                    text=tr("diversos_media_source_info"),
                    icon="msg2_help",
                    accent=True,
                    on_click=lambda view: self._show_integration_info_dialog()
                ),
            ])
        settings.append(Divider())
        # 3.5 Experimental - NOVA SEÇÃO (logo após Miscellaneous)
        # Dicionário de chaves de texto para a seção Experimental
        EXPERIMENTAL_TEXT = {
            "header": "experimental_header",
            "sub": "experimental_sub",
            "section": "experimental_section",
            "notice": "experimental_notice",
            "chatlist_section": "chat_list_section",
        }
        settings.append(
            Switch(
                key="show_experimental",
                text=tr(EXPERIMENTAL_TEXT["header"]),
                subtext=tr(EXPERIMENTAL_TEXT["sub"]),
                default=False,
                icon="msg_customize",
                on_change=lambda v: self.reload_settings()
            )
        )
        if self.get_setting("show_experimental", False):
            settings.extend([
                Divider(text=tr(EXPERIMENTAL_TEXT["section"])),
                Switch(
                    key="disable_logs",
                    text=tr("disable_logs_label"),
                    subtext=tr("disable_logs_sub"),
                    default=self.get_setting("disable_logs", False),
                    icon="msg_info",
                    on_change=lambda v: (
                        self.set_setting("disable_logs", bool(v)),
                        _set_log_muted(bool(v)),
                        _apply_log_wrapper(True),
                        self.reload_settings()
                    )
                ),
            ])
        # 4. Extras
        settings.append(Divider())
        settings.append(Text(
            text=tr("dotted_credit") if "dotted_credit" in TRANSLATIONS else "Dotted Plugins",
            icon="etg_settings",
            accent=True,
            on_click=lambda view: run_on_ui_thread(lambda: get_messages_controller().openByUserName("exteraDevPlugins", get_last_fragment(), 1))
        ))
        settings.append(Text(
            text="Nowfy",
            icon="msg_reactions",
            accent=True,
            create_sub_fragment=self.create_about_plugin_subfragment
        ))
        return settings


    def create_lastfm_credentials_secure(self):
        return [
            Input(
                key="lastfm_user",
                text="Username",
                icon="menu_username_change",
                default=self.get_setting("lastfm_user", ""),
                subtext=tr("lastfm_user_subtext")
            ),
            Input(
                key="lastfm_api_key",
                text="Last.FM API Key",
                icon="filled_access_fingerprint",
                default=self.get_setting("lastfm_api_key", ""),
                subtext=tr("lastfm_api_key_subtext")
            ),
            Input(
                key="statsfm_username",
                text="Stats.fm Username",
                icon="menu_username_change",
                default=self.get_setting("statsfm_username", ""),
                subtext="Seu username do stats.fm"
            ),            
            Text(
                text=tr("lastfm_title"),
                icon="msg2_help",
                accent=True,
                on_click=lambda view: self._show_lastfm_api_dialog()
            ),
        ]

    def create_about_plugin_subfragment(self):
        return [
            Divider(text=tr("about_plugin_description")),
            Header(text=tr("about_plugin_header")),
            Text(
                text=tr("about_plugin_donate"),
                icon="msg_reactions",
                accent=True,
                on_click=lambda view: self._open_url("https://livepix.gg/makios")
            ),
            Text(
                text=tr("about_plugin_donate_kofi"),
                icon="msg_reactions",
                accent=True,
                on_click=lambda view: self._open_url("https://ko-fi.com/ageekapple")
            ),
            Text(
                text="TON",
                icon="msg_copy",
                accent=True,
                on_click=lambda view: run_on_ui_thread(lambda: self._copy_to_clipboard("TON", "UQCy_iox46geMTCNxxZ0G8W0_gg0NXQXz4_A2ho8UtciXvW1"))
            ),
            Text(
                text="TON Telegram",
                icon="msg_copy",
                accent=True,
                on_click=lambda view: run_on_ui_thread(lambda: self._copy_to_clipboard("TON Telegram", "UQAnV3cohn83QODugckxVP-f9jfjwsBgp6MR_RS4hLDWy1rT"))
            ),
            Text(
                text="BTC",
                icon="msg_copy",
                accent=True,
                on_click=lambda view: run_on_ui_thread(lambda: self._copy_to_clipboard("BTC", "bc1qkyq4zqy07agmspnuve6gtjlt40ew278l94ljry8fulykec7vhfuqnuh7he"))
            ),
            Text(
                text="Ethereum (ERC20)",
                icon="msg_copy",
                accent=True,
                on_click=lambda view: run_on_ui_thread(lambda: self._copy_to_clipboard("Ethereum", "0xd41a8f8aed90108380688a46b97ad0a15a91598b"))
            )
            ,
            Divider(text=tr("version_status_section")),
            Text(
                text=f"{tr('installed_version_label')}: {__version__}",
                icon="msg_info"
            ),
            Text(
                text=f"{tr('latest_version_label')}: {getattr(self, '_latest_version', None) or tr('version_status_unknown')}",
                icon="menu_factcheck"
            ),
            Text(
                text=(tr("update_available_text").format(version=getattr(self, "_latest_version", "")) if getattr(self, "_version_is_outdated", False) and getattr(self, "_latest_version", None) else tr("version_status_up_to_date")),
                icon=("msg_other_new_outline" if getattr(self, "_version_is_outdated", False) else "msg_rate_up_remix"),
                accent=True,
                on_click=lambda view: self._open_url(getattr(self, "_version_update_url", "https://github.com/soumaki/nowFy")) if getattr(self, "_version_is_outdated", False) else None
            ),
            Text(
                text=tr("check_version_now"),
                icon="msg_retry",
                accent=True,
                on_click=lambda view: self._check_version_async(True)
            )
        ]

    def _open_lastfm_settings(self):
        try:
            fragment = get_last_fragment()
            if fragment:
                # Teste: abrir um AlertDialog
                from ui.alert import AlertDialogBuilder
                ctx = fragment.getParentActivity() if fragment and fragment.getParentActivity() else ApplicationLoader.applicationContext
                builder = AlertDialogBuilder(ctx)
                builder.set_title("LastFM Settings")
                builder.set_message("Aqui será a interface de configurações do LastFM.")
                builder.set_positive_button("OK", lambda b, w: b.dismiss())
                run_on_ui_thread(builder.show)
        except Exception as e:
            log(f"[Nowfy] Erro ao abrir LastFM Settings: {e}")

    def _show_dynamic_island_preview_dialog(self):
        try:
            fragment = get_last_fragment()
            ctx = fragment.getParentActivity() if fragment and fragment.getParentActivity() else ApplicationLoader.applicationContext
            from ui.alert import AlertDialogBuilder
            builder = AlertDialogBuilder(ctx)
            builder.set_title(tr("pop_island_preview") if "pop_island_preview" in TRANSLATIONS else "Floatify Preview")

            container = LinearLayout(ctx)
            try:
                container.setOrientation(LinearLayout.VERTICAL)
            except Exception:
                pass
            try:
                pad = AndroidUtilities.dp(12)
                container.setPadding(pad, pad, pad, pad)
            except Exception:
                pass

            # WebView com configurações básicas
            WebViewCls = None
            WebViewClientCls = None
            try:
                from android.webkit import WebView as _WebView, WebViewClient as _WebViewClient
                WebViewCls = _WebView
                WebViewClientCls = _WebViewClient
            except Exception:
                try:
                    from hook_utils import find_class
                    WebViewCls = find_class("android.webkit.WebView")
                    WebViewClientCls = find_class("android.webkit.WebViewClient")
                except Exception:
                    pass

            if WebViewCls is None:
                # Fallback mínimo
                from org.telegram.ui import Components as _Comp
                try:
                    tv = TextView(ctx)
                    tv.setText("Preview indisponível neste dispositivo.")
                    container.addView(tv)
                except Exception:
                    pass
                builder.set_view(container)
                run_on_ui_thread(builder.show)
                return

            wv = WebViewCls(ctx)
            try:
                wv.getSettings().setJavaScriptEnabled(True)
                wv.getSettings().setDomStorageEnabled(True)
                wv.getSettings().setUseWideViewPort(True)
                wv.getSettings().setLoadWithOverviewMode(True)
                wv.getSettings().setAllowFileAccess(True)
                wv.getSettings().setAllowContentAccess(True)
            except Exception:
                pass

            # Cliente básico apenas para manter comportamento padrão
            try:
                if WebViewClientCls is not None:
                    wv.setWebViewClient(WebViewClientCls())
            except Exception:
                pass

            # Baixar imagem externa e usar fallback local em nowfy_icons
            PREVIEW_URL = "https://3.downloader.disk.yandex.com/preview/7699f84c59243235fe2cefecc2c3814c7e009c4ecde4d3e31afd6fd0746ab6fe/inf/o0XHy85Uhn0vqfIBhD6BYTEWkQAM-pa19i3oUdr2MXRAqfLooJ0jAIpDH-19Szdsd3XVsXtvtuW6HOPZME7yfQ%3D%3D?uid=2274632245&filename=previeww.png&disposition=inline&hash=&limit=0&content_type=image%2Fpng&owner_uid=2274632245&tknv=v3&size=1897x932"
            FALLBACK_URL = "https://i.postimg.cc/dtPGrFLC/previeww.png"
            local_preview_path = None
            try:
                import os, requests
                # Reutilizar pasta nowfy_icons
                def _di_cache_dir():
                    return self._di_cache_dir()
                # Usar múltiplos diretórios candidatos (Extera + Ayu)
                cache_dirs = []
                try:
                    import os as _os
                    ext_base = "/storage/emulated/0/Android/media/com.exteragram.messenger"
                    ayu_base = "/storage/emulated/0/Android/media/com.radolyn.ayugram"
                    if _os.path.isdir(ext_base):
                        cache_dirs.append(_os.path.join(ext_base, "nowfy_icons"))
                    if _os.path.isdir(ayu_base):
                        cache_dirs.append(_os.path.join(ayu_base, "nowfy_icons"))
                except Exception:
                    pass
                primary_dir = self._di_cache_dir()
                if primary_dir:
                    try:
                        import os as _os
                        _os.makedirs(primary_dir, exist_ok=True)
                    except Exception:
                        pass
                    if primary_dir not in cache_dirs:
                        cache_dirs.insert(0, primary_dir)
                # Selecionar o primeiro preview existente
                for d in cache_dirs:
                    pth = os.path.join(d, "previeww.png")
                    try:
                        if os.path.exists(pth) and os.path.getsize(pth) > 128:
                            local_preview_path = pth
                            break
                    except Exception:
                        pass
                # Se nenhum preview foi encontrado, preparar caminho no diretório primário
                if not local_preview_path and primary_dir:
                    local_preview_path = os.path.join(primary_dir, "previeww.png")
                # Verificar se precisa baixar
                need_download = True
                try:
                    if local_preview_path and os.path.exists(local_preview_path) and os.path.getsize(local_preview_path) > 128:
                        need_download = False
                except Exception:
                    pass
                    if need_download:
                        s = requests.Session()
                        try:
                            s.headers.update({
                                "User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) Nowfy/DI",
                                "Accept": "image/avif,image/webp,image/apng,image/*,*/*;q=0.8",
                                "Connection": "keep-alive",
                                "Referer": "https://disk.yandex.com",
                            })
                        except Exception:
                            pass
                        try:
                            downloaded = False
                            resp = s.get(PREVIEW_URL, timeout=(5, 10))
                            ct = str(resp.headers.get("Content-Type", "")).lower()
                            content = resp.content or b""
                            is_png_header = (len(content) >= 8 and content[:8] == b"\x89PNG\r\n\x1a\n")
                            if resp.status_code == 200 and content and (("image/png" in ct) or is_png_header):
                                with open(local_preview_path, "wb") as f:
                                    f.write(content)
                                downloaded = True
                            if not downloaded:
                                resp2 = s.get(FALLBACK_URL, timeout=(5, 10))
                                ct2 = str(resp2.headers.get("Content-Type", "")).lower()
                                content2 = resp2.content or b""
                                is_png_header2 = (len(content2) >= 8 and content2[:8] == b"\x89PNG\r\n\x1a\n")
                                if resp2.status_code == 200 and content2 and (("image/png" in ct2) or is_png_header2):
                                    with open(local_preview_path, "wb") as f:
                                        f.write(content2)
                        except Exception:
                            pass
            except Exception:
                pass

            # Carregar diretamente, simples: local se existir; senão PostImage (evita 403)
            try:
                img_url = None
                if local_preview_path and os.path.exists(local_preview_path) and os.path.getsize(local_preview_path) > 128:
                    img_url = "file://" + local_preview_path.replace("\\", "/")
                else:
                    img_url = FALLBACK_URL
                if img_url and img_url.startswith("file://"):
                    wv.loadUrl(img_url)
                else:
                    try:
                        from java.util import HashMap
                        headers = HashMap()
                        headers.put("User-Agent", "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/124 Safari/537.36")
                        headers.put("Referer", "https://disk.yandex.com")
                        wv.loadUrl(img_url, headers)
                    except Exception:
                        wv.loadUrl(img_url)
            except Exception:
                pass

            try:
                container.addView(wv, LinearLayout.LayoutParams(-1, -1))
            except Exception:
                pass

            try:
                builder.set_view(container)
                run_on_ui_thread(builder.show)
            except Exception:
                pass
        except Exception as e:
            log(f"[Nowfy] Preview dialog error: {e}")

    def _di_icon_catalog(self):
        try:
            return {
                "classic": {
                    "back": {
                        "primary": "https://3.downloader.disk.yandex.com/preview/143f85fc065205a9bc00b2b34d6dda362980dee30cbfb0ce8684e5d00c07c0d8/inf/Gxkh970a34XMuf4Cn0LZN3NHswX--zsrk1RGVLhz7Ueir3l7Jl8o6A7uSZfhNi19gnJMuslSFSuQUm2_8mMbEA%3D%3D?uid=2274632245&filename=back.png&disposition=inline&hash=&limit=0&content_type=image%2Fpng&owner_uid=2274632245&tknv=v3&size=1897x932",
                        "fallback": "https://i.postimg.cc/ht2cqcd9/back.png",
                    },
                    "play": {
                        "primary": "https://3.downloader.disk.yandex.com/preview/f83c54a206567a816d0214877897ac0261d3c2b2835e900b168e58c1952b13ef/inf/LKFeDmdHn_W2v5kh3x4U7_1OPh5j8tfeUktwnf1YLyGnlDpbvLvFPgXOXX_5nbab9hUcjvtUk7mCM8I72V5jjw%3D%3D?uid=2274632245&filename=play.png&disposition=inline&hash=&limit=0&content_type=image%2Fpng&owner_uid=2274632245&tknv=v3&size=1897x932",
                        "fallback": "https://i.postimg.cc/L8x2M21V/play.png",
                    },
                    "pause": {
                        "primary": "https://2.downloader.disk.yandex.com/preview/75ddd34bcf7edfe372a5f6438c6cfd28f3c763e38459b77b86a0582eb205300d/inf/sXQmXfxXFgoytfzxOIGoSGqSH6kV8DgnmBCT7U-q_-6jZqU0Y1Ts6fmAaCuek6a99E8AqiWhPo_-I9ciB_Onpg%3D%3D?uid=2274632245&filename=pause.png&disposition=inline&hash=&limit=0&content_type=image%2Fpng&owner_uid=2274632245&tknv=v3&size=1897x932",
                        "fallback": "https://i.postimg.cc/RZg4z4HR/pause.png",
                    },
                    "next": {
                        "primary": "https://2.downloader.disk.yandex.com/preview/2a31255580ef11b5beef7775d5203e1bc321cd37da5a52309e78d575c17b17d7/inf/XBsFROSdbFCYhjwqZdOd22qSH6kV8DgnmBCT7U-q_-5qb8eGkT-bf1_kTU6LVcqFcOfOpfReEDmz2Kg9mpDRHg%3D%3D?uid=2274632245&filename=next.png&disposition=inline&hash=&limit=0&content_type=image%2Fpng&owner_uid=2274632245&tknv=v3&size=1897x932",
                        "fallback": "https://i.postimg.cc/y8LszsZv/next.png",
                    },
                    "send": {
                        "primary": "https://4.downloader.disk.yandex.com/preview/78c8aaa6d5a1ed0d86129a59295141342fbfd84511ced65b06f70f9e1b510ebc/inf/LoCXSGSO2RkSA3xPWImDmCUfClKd-RWEryrkJISOsZDyb6toCs8g-B-dwOUSTs25o6JvsO-NjqCQHh8BVm_yew%3D%3D?uid=2274632245&filename=send.png&disposition=inline&hash=&limit=0&content_type=image%2Fpng&owner_uid=2274632245&tknv=v3&size=1897x932",
                        "fallback": "https://i.postimg.cc/JzpMWMkK/send.png",
                    },
                    "search": {
                        "primary": "https://i.postimg.cc/7LkbMWsr/search.png",
                        "fallback": "https://i.postimg.cc/7LkbMWsr/search.png",
                    },
                },
                "modern": {
                    "back": {
                        "primary": "https://2.downloader.disk.yandex.com/preview/429c11d0ff7cf7fe0a840e1966ab3794d59d24a70ea60e58e28c76e951c795a6/inf/WumN0tYosGza7Bwet8oarRJXd32NVIq_7GmfIZQuBPUAaKZxDrlHseDOiWmGb91B15LW7JvM28q6exFFRMsybA%3D%3D?uid=2274632245&filename=play_modern.png&disposition=inline&hash=&limit=0&content_type=image%2Fpng&owner_uid=2274632245&tknv=v3&size=1897x932",
                        "fallback": "https://raw.githubusercontent.com/soumaki/nowFy/refs/heads/main/img/modern/back_modern.png",
                        "fallback2": "https://i.postimg.cc/DZ2ZPBLN/back-modern.png",
                    },
                    "play": {
                        "primary": "https://2.downloader.disk.yandex.com/preview/429c11d0ff7cf7fe0a840e1966ab3794d59d24a70ea60e58e28c76e951c795a6/inf/WumN0tYosGza7Bwet8oarRJXd32NVIq_7GmfIZQuBPUAaKZxDrlHseDOiWmGb91B15LW7JvM28q6exFFRMsybA%3D%3D?uid=2274632245&filename=play_modern.png&disposition=inline&hash=&limit=0&content_type=image%2Fpng&owner_uid=2274632245&tknv=v3&size=1704x893",
                        "fallback": "https://raw.githubusercontent.com/soumaki/nowFy/refs/heads/main/img/modern/play_modern.png",
                        "fallback2": "https://i.postimg.cc/LXNsCL3N/play-modern.png",
                    },
                    "pause": {
                        "primary": "https://1.downloader.disk.yandex.com/preview/71a809396d9fc132679a20279bc3196394d358863ef63b24d6e335a64884543d/inf/4IslpTGoqV6-cYW2BkQC-4HkqvPA2RGNBsiDuurcQuckd6N6690FnMi0rOku9qzYWpXAah6KtCjyB-6Vcf-I-w%3D%3D?uid=2274632245&filename=pause_modern.png&disposition=inline&hash=&limit=0&content_type=image%2Fpng&owner_uid=2274632245&tknv=v3&size=1704x893",
                        "fallback": "https://raw.githubusercontent.com/soumaki/nowFy/refs/heads/main/img/modern/pause_modern.png",
                        "fallback2": "https://i.postimg.cc/tT2gSWNk/pause-modern.png",
                    },
                    "next": {
                        "primary": "https://4.downloader.disk.yandex.com/preview/c0868fbc1673f940d49c54d43128410d66e2fd1df3630980cca275bb4ee3b47c/inf/s7hMqAExRbDZco8g30j7c2TVJTI9PjAW21Sah-fv2IJyTXIBvtZ98uR-YQzOygWVhhWCG_e7mALO7Sapby-fVA%3D%3D?uid=2274632245&filename=next_modern.png&disposition=inline&hash=&limit=0&content_type=image%2Fpng&owner_uid=2274632245&tknv=v3&size=1704x893",
                        "fallback": "https://raw.githubusercontent.com/soumaki/nowFy/refs/heads/main/img/modern/next_modern.png",
                        "fallback2": "https://i.postimg.cc/B6MvYHBN/next-modern.png",
                    },
                    "send": {
                        "primary": "https://2.downloader.disk.yandex.com/preview/523f1d5e44fd6ccd8ac37673c8eca0a268f109d8ac8eafa08e6d27deb4b9e77b/inf/Vw564DnAUNOlbL2Ac19FojWVW9Xt4Ie9F_uMrpFYTbpZnmegZEBMdt7qzRaI40VDSShsGU4NruHotkg5XmStEA%3D%3D?uid=2274632245&filename=send_modern.png&disposition=inline&hash=&limit=0&content_type=image%2Fpng&owner_uid=2274632245&tknv=v3&size=1704x893",
                        "fallback": "https://raw.githubusercontent.com/soumaki/nowFy/refs/heads/main/img/modern/send_modern.png",
                        "fallback2": "https://i.postimg.cc/gJN0S8Hg/send-modern.png",
                    },
                    "search": {
                        "primary": "https://i.postimg.cc/mkGL3z2z/search-modern.png",
                        "fallback": "https://i.postimg.cc/mkGL3z2z/search-modern.png",
                    },
                },
                "gradient": {
                    "back": {
                        "primary": "https://i.postimg.cc/pTVJ9NVY/back-gradient.png"
                    },
                    "play": {
                        "primary": "https://i.postimg.cc/MTZmckZ9/play-gradient.png"
                    },
                    "pause": {
                        "primary": "https://i.postimg.cc/Jn75yw7Q/pause-gradient.png"
                    },
                    "next": {
                        "primary": "https://i.postimg.cc/sXf4BFfc/next-gradient.png"
                    },
                    "send": {
                        "primary": "https://i.postimg.cc/bJY9GXYL/send-gradient.png"
                    },
                    "search": {
                        "primary": "https://i.postimg.cc/j2rx6wdD/search-gradient.png",
                        "fallback": "https://i.postimg.cc/j2rx6wdD/search-gradient.png",
                    },
                },
                "silver": {
                    "back": {
                        "primary": "https://i.postimg.cc/v8Pp5NHk/back-silver.png"
                    },
                    "play": {
                        "primary": "https://i.postimg.cc/L5nQhnRr/play-silver.png"
                    },
                    "pause": {
                        "primary": "https://i.postimg.cc/Nf5ZDk5N/pause-silver.png"
                    },
                    "next": {
                        "primary": "https://i.postimg.cc/bNs4g9sm/next-silver.png"
                    },
                    "send": {
                        "primary": "https://i.postimg.cc/GtHg9Hdw/send-silver.png"
                    },
                    "search": {
                        "primary": "https://i.postimg.cc/kGdJN6XB/search-silver.png",
                        "fallback": "https://i.postimg.cc/kGdJN6XB/search-silver.png",
                    },
                },
            }
        except Exception:
            return {"classic": {}, "modern": {}, "gradient": {}}

    def _di_icon_sources(self):
        try:
            style_idx = 0
            try:
                style_idx = int(self.get_setting("control_style_selector", 0))
            except Exception:
                style_idx = 0
            catalog = self._di_icon_catalog()
            if style_idx == 3:
                return catalog.get("silver", {})
            if style_idx == 2:
                return catalog.get("gradient", {})
            return catalog.get("modern", {}) if style_idx == 1 else catalog.get("classic", {})
        except Exception:
            return {}

    def _di_cache_dir(self):
        try:
            import os
            from org.telegram.messenger import ApplicationLoader as _AL
            ext_base = "/storage/emulated/0/Android/media/com.exteragram.messenger"
            ayu_base = "/storage/emulated/0/Android/media/com.radolyn.ayugram"
            pkg = ""
            try:
                pkg = str(_AL.applicationContext.getPackageName() or "").lower()
            except Exception:
                pkg = ""
            base = None
            # Preferir diretório de acordo com o app atual
            if "ayugram" in pkg:
                if os.path.isdir(ayu_base):
                    base = ayu_base
                elif os.path.isdir(ext_base):
                    base = ext_base
            elif "exteragram" in pkg:
                if os.path.isdir(ext_base):
                    base = ext_base
                elif os.path.isdir(ayu_base):
                    base = ayu_base
            else:
                if os.path.isdir(ext_base):
                    base = ext_base
                elif os.path.isdir(ayu_base):
                    base = ayu_base
            if not base:
                base = _AL.getFilesDir().getAbsolutePath()
            p = os.path.join(base, "nowfy_icons")
            os.makedirs(p, exist_ok=True)
            return p
        except Exception:
            return None

    def _download_pop_island_resources(self):
        try:
            import os, threading, requests
            from ui.alert import AlertDialogBuilder
            from ui.bulletin import BulletinHelper
            try:
                from android_utils import run_on_ui_thread
            except Exception:
                pass

            fragment = get_last_fragment()
            ctx = fragment.getParentActivity() if fragment else ApplicationLoader.applicationContext
            progress_dialog = None
            try:
                progress_dialog = AlertDialogBuilder(ctx, AlertDialogBuilder.ALERT_TYPE_LOADING)
                progress_dialog.set_message(tr("resources_checking") if "resources_checking" in TRANSLATIONS else "Checking resources...")
                progress_dialog.set_progress(0)
                run_on_ui_thread(progress_dialog.show)
            except Exception:
                progress_dialog = None

            icons_current = self._di_icon_sources()
            try:
                style_idx = int(self.get_setting("control_style_selector", 0))
            except Exception:
                style_idx = 0

            # Fontes em catálogo único (Classic + Modern) sem repetir links
            catalog = self._di_icon_catalog()
            classic_icons = catalog.get("classic", {})
            modern_icons = catalog.get("modern", {})
            gradient_icons = catalog.get("gradient", {})
            silver_icons = catalog.get("silver", {})

            primaries = []
            fallbacks = {}
            fallback2s = {}

            for k in ("back", "play", "pause", "next", "send", "search"):
                if k in classic_icons:
                    p = classic_icons[k].get("primary")
                    f = classic_icons[k].get("fallback")
                    if p:
                        primaries.append(p)
                        if f:
                            fallbacks[p] = f
                if k in modern_icons:
                    p = modern_icons[k].get("primary")
                    f = modern_icons[k].get("fallback")
                    f2 = modern_icons[k].get("fallback2")
                    if p:
                        primaries.append(p)
                        if f:
                            fallbacks[p] = f
                        if f2:
                            fallback2s[p] = f2
                if k in gradient_icons:
                    p = gradient_icons[k].get("primary")
                    if p:
                        primaries.append(p)
                    # Gradient style intentionally has no fallbacks
                if k in silver_icons:
                    p = silver_icons[k].get("primary")
                    if p:
                        primaries.append(p)

            # Extras: ícones de minimizar/fechar e preview da Pop Island
            MINI_URL = "https://i.postimg.cc/y8QHJzyz/mini.png"
            CLOSE_URL = "https://i.postimg.cc/nhRJstY6/close.png"
            PREVIEW_URL = "https://3.downloader.disk.yandex.com/preview/7699f84c59243235fe2cefecc2c3814c7e009c4ecde4d3e31afd6fd0746ab6fe/inf/o0XHy85Uhn0vqfIBhD6BYTEWkQAM-pa19i3oUdr2MXRAqfLooJ0jAIpDH-19Szdsd3XVsXtvtuW6HOPZME7yfQ%3D%3D?uid=2274632245&filename=previeww.png&disposition=inline&hash=&limit=0&content_type=image%2Fpng&owner_uid=2274632245&tknv=v3&size=1897x932"
            PREVIEW_FALLBACK = "https://i.postimg.cc/dtPGrFLC/previeww.png"

            primaries.extend([MINI_URL, CLOSE_URL, PREVIEW_URL])
            fallbacks[MINI_URL] = "https://i.postimg.cc/y8QHJzyz/mini.png"
            fallbacks[CLOSE_URL] = "https://i.postimg.cc/nhRJstY6/close.png"
            fallbacks[PREVIEW_URL] = PREVIEW_FALLBACK

            # Fallback de capa quando nada está tocando
            FALLBACK_COVER_URL = "https://i.postimg.cc/mktzh58h/icon-island.png"
            primaries.append(FALLBACK_COVER_URL)

            # Nome alvo quando fallback2 for Modern (sempre)
            name_overrides = {}
            for k in ("back", "play", "pause", "next", "send", "search"):
                if k in modern_icons:
                    name_overrides[modern_icons[k]["primary"]] = f"{k}_modern.png"

            def _guess_name(u):
                try:
                    from urllib.parse import urlparse, parse_qs
                    qs = parse_qs(urlparse(u).query)
                    name = (qs.get("filename") or qs.get("file") or [None])[0]
                    if name:
                        return name
                    base = os.path.basename(urlparse(u).path) or "icon"
                    if "." not in base:
                        base += ".png"
                    return base
                except Exception:
                    return "icon.png"

            def _cache_dir():
                return self._di_cache_dir()

            def _fetch(u):
                try:
                    cd = _cache_dir()
                    if not cd:
                        return False
                    s = requests.Session()
                    try:
                        s.headers.update({
                            "User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) Nowfy/DI",
                            "Accept": "image/avif,image/webp,image/apng,image/*,*/*;q=0.8",
                            "Connection": "keep-alive",
                            "Referer": "https://disk.yandex.com",
                        })
                    except Exception:
                        pass
                    fb = fallbacks.get(u)
                    fb2 = fallback2s.get(u)
                    candidates = [u]
                    if fb2:
                        candidates.append(fb2)
                    if fb:
                        candidates.append(fb)

                    def _ensure_modern(name):
                        try:
                            import os as _os
                            base, ext = _os.path.splitext(name)
                            if not ext:
                                ext = ".png"
                            if base.endswith("_modern"):
                                return base + ext
                            return base + "_modern" + ext
                        except Exception:
                            return "icon_modern.png"

                    for try_u in candidates:
                        try_name = _guess_name(u)
                        if fb2 and try_u == fb2:
                            try_name = name_overrides.get(u) or _ensure_modern(try_name)
                        dest = os.path.join(cd, try_name)
                        try:
                            if os.path.exists(dest) and os.path.getsize(dest) > 64:
                                return True
                        except Exception:
                            pass
                        try:
                            resp = s.get(try_u, timeout=(5, 10))
                            ct = str(resp.headers.get("Content-Type", "")).lower()
                            cont = resp.content or b""
                            if resp.status_code == 200 and cont and (("image" in ct) or len(cont) > 64):
                                with open(dest, "wb") as f:
                                    f.write(cont)
                                return True
                        except Exception:
                            pass
                    return False
                except Exception:
                    return False

            def _do_work():
                try:
                    total = len(primaries)
                    if total == 0:
                        if progress_dialog:
                            try:
                                run_on_ui_thread(lambda: progress_dialog.set_progress(100))
                                run_on_ui_thread(progress_dialog.dismiss)
                            except Exception:
                                pass
                        try:
                            run_on_ui_thread(lambda: BulletinHelper.show_info(tr("resources_download_failed") if "resources_download_failed" in TRANSLATIONS else "Failed to prepare resources", fragment))
                        except Exception:
                            pass
                        return

                    cd = _cache_dir()
                    if not cd:
                        if progress_dialog:
                            try:
                                run_on_ui_thread(progress_dialog.dismiss)
                            except Exception:
                                pass
                        try:
                            run_on_ui_thread(lambda: BulletinHelper.show_info(tr("resources_download_failed") if "resources_download_failed" in TRANSLATIONS else "Failed to prepare resources", fragment))
                        except Exception:
                            pass
                        return

                    # Candidatos de diretório (Extera + Ayu) para verificação
                    candidate_dirs = []
                    try:
                        import os as _os
                        ext_base = "/storage/emulated/0/Android/media/com.exteragram.messenger"
                        ayu_base = "/storage/emulated/0/Android/media/com.radolyn.ayugram"
                        if _os.path.isdir(ext_base):
                            candidate_dirs.append(_os.path.join(ext_base, "nowfy_icons"))
                        if _os.path.isdir(ayu_base):
                            candidate_dirs.append(_os.path.join(ayu_base, "nowfy_icons"))
                    except Exception:
                        pass
                    try:
                        import os as _os
                        _os.makedirs(cd, exist_ok=True)
                    except Exception:
                        pass
                    if cd not in candidate_dirs:
                        candidate_dirs.insert(0, cd)

                    # Se todos já existem nos diretórios candidatos, apenas informar
                    try:
                        def _exists_any(u):
                            names = [_guess_name(u)]
                            if u in name_overrides:
                                names.append(name_overrides[u])
                            for nm in names:
                                for d in candidate_dirs:
                                    try:
                                        dest = os.path.join(d, nm)
                                        if os.path.exists(dest) and os.path.getsize(dest) > 64:
                                            return True
                                    except Exception:
                                        pass
                            return False

                        all_exist = True
                        for u in primaries:
                            if not _exists_any(u):
                                all_exist = False
                                break
                        if all_exist:
                            if progress_dialog:
                                try:
                                    run_on_ui_thread(lambda: progress_dialog.set_progress(100))
                                    run_on_ui_thread(progress_dialog.dismiss)
                                except Exception:
                                    pass
                            try:
                                run_on_ui_thread(lambda: BulletinHelper.show_success(tr("resources_already_downloaded") if "resources_already_downloaded" in TRANSLATIONS else "Resources already downloaded", fragment))
                            except Exception:
                                pass
                            return
                        else:
                            if progress_dialog:
                                try:
                                    missing = []
                                    for u in primaries:
                                        if not _exists_any(u):
                                            nm = _guess_name(u)
                                            if u in name_overrides:
                                                nm = name_overrides[u]
                                            missing.append(nm)
                                    list_title = tr("resources_to_download") if "resources_to_download" in TRANSLATIONS else "Resources to download:"
                                    download_msg = tr("resources_downloading") if "resources_downloading" in TRANSLATIONS else "Downloading resources..."
                                    message_text = list_title + "\n" + "\n".join([f"- {nm}" for nm in missing]) + "\n\n" + download_msg
                                    run_on_ui_thread(lambda msg=message_text: progress_dialog.set_message(msg))
                                except Exception:
                                    pass
                    except Exception:
                        pass

                    # Baixar com progresso
                    completed = 0
                    for u in primaries:
                        try:
                            _fetch(u)
                        except Exception:
                            pass
                        # Copiar recursos baixados para ambos diretórios candidatos (ExteraGram e AyuGram)
                        try:
                            names = [_guess_name(u)]
                            if u in name_overrides:
                                names.append(name_overrides[u])
                            for nm in names:
                                try:
                                    src = os.path.join(cd, nm)
                                    if os.path.exists(src) and os.path.getsize(src) > 64:
                                        for d in candidate_dirs:
                                            try:
                                                if d != cd:
                                                    os.makedirs(d, exist_ok=True)
                                                    dest = os.path.join(d, nm)
                                                    if not (os.path.exists(dest) and os.path.getsize(dest) > 64):
                                                        with open(src, "rb") as sf:
                                                            data = sf.read()
                                                        with open(dest, "wb") as df:
                                                            df.write(data)
                                            except Exception:
                                                pass
                                except Exception:
                                    pass
                        except Exception:
                            pass
                        completed += 1
                        pct = int((completed / float(total)) * 100)
                        if progress_dialog:
                            try:
                                run_on_ui_thread(lambda p=pct: progress_dialog.set_progress(p))
                            except Exception:
                                pass

                    # Validar e finalizar
                    ok_all = True
                    try:
                        for u in primaries:
                            names = [_guess_name(u)]
                            if u in name_overrides:
                                names.append(name_overrides[u])
                            exists = False
                            for nm in names:
                                for d in candidate_dirs:
                                    try:
                                        dest = os.path.join(d, nm)
                                        if os.path.exists(dest) and os.path.getsize(dest) > 64:
                                            exists = True
                                            break
                                    except Exception:
                                        pass
                                if exists:
                                    break
                            if not exists:
                                ok_all = False
                                break
                    except Exception:
                        ok_all = False

                    if progress_dialog:
                        try:
                            run_on_ui_thread(lambda: progress_dialog.set_progress(100))
                            run_on_ui_thread(progress_dialog.dismiss)
                        except Exception:
                            pass

                    msg = (tr("resources_downloaded") if "resources_downloaded" in TRANSLATIONS else "Resources downloaded") if ok_all else (tr("resources_download_failed") if "resources_download_failed" in TRANSLATIONS else "Failed to download resources")
                    try:
                        run_on_ui_thread(lambda: BulletinHelper.show_success(msg, fragment)) if ok_all else run_on_ui_thread(lambda: BulletinHelper.show_info(msg, fragment))
                    except Exception:
                        pass
                except Exception:
                    try:
                        if progress_dialog:
                            try:
                                run_on_ui_thread(progress_dialog.dismiss)
                            except Exception:
                                pass
                        run_on_ui_thread(lambda: BulletinHelper.show_info(tr("resources_download_failed") if "resources_download_failed" in TRANSLATIONS else "Failed to download resources", fragment))
                    except Exception:
                        pass

            try:
                threading.Thread(target=_do_work, daemon=True).start()
            except Exception:
                # Fallback sem thread
                _do_work()
        except Exception:
            try:
                fragment = get_last_fragment()
                run_on_ui_thread(lambda: BulletinHelper.show_info(tr("resources_download_failed") if "resources_download_failed" in TRANSLATIONS else "Failed to download resources", fragment))
            except Exception:
                pass

    def _copy_to_clipboard(self, label, text):
        fragment = get_last_fragment()
        ctx = fragment.getContext() if fragment else ApplicationLoader.applicationContext
        clipboard = ctx.getSystemService(Context.CLIPBOARD_SERVICE)
        clip = ClipData.newPlainText(label, text)
        clipboard.setPrimaryClip(clip)
        BulletinHelper.show_info(tr("copied_to_clipboard").format(label=label) if "copied_to_clipboard" in TRANSLATIONS else f"Copied {label} to clipboard")

    def _should_show_error_bulletin(self, error_type):
        """Verifica se deve mostrar o bulletin de erro para evitar spam"""
        import time
        current_time = time.time()
        
        # Inicializar controle de erro se não existir
        if not hasattr(self, '_error_display_control'):
            self._error_display_control = {}
        
        # Verificar se já foi mostrado recentemente (últimos 30 segundos)
        last_shown = self._error_display_control.get(error_type, 0)
        if current_time - last_shown < 30:  # 30 segundos de cooldown
            return False
        
        # Atualizar timestamp
        self._error_display_control[error_type] = current_time
        return True

    def _show_credentials_error_bulletin(self, error_type, error_log, missing_fields):
        """Mostra bulletin detalhado para erros de credenciais com botão de copiar logs"""
        try:
            fragment = get_last_fragment()
            if not fragment:
                return
                
            # Definir mensagens baseadas no tipo de erro
            error_messages = {
                "missing_credentials": {
                    "title": tr("credentials_missing_title"),
                    "message": tr("credentials_missing_message").format(fields=', '.join(missing_fields))
                },
                "invalid_credentials": {
                    "title": tr("credentials_invalid_title"),
                    "message": tr("credentials_invalid_message").format(fields=', '.join(missing_fields))
                },
                "invalid_refresh_token": {
                    "title": tr("refresh_token_invalid_title"),
                    "message": tr("refresh_token_invalid_message")
                },
                "api_error": {
                    "title": tr("api_error_title"),
                    "message": tr("api_error_message")
                },
                "connection_error": {
                    "title": tr("connection_error_title"),
                    "message": tr("connection_error_message")
                }
            }
            
            error_info = error_messages.get(error_type, {
                "title": tr("error_auth"),
                "message": tr("error_auth")
            })
            
            # Criar log detalhado para copiar
            detailed_log = f"""=== SPOTIFY AUTHENTICATION ERROR ===
Error Type: {error_type}
Timestamp: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}
Missing/Invalid Fields: {', '.join(missing_fields) if missing_fields else 'None'}

Detailed Log:
{error_log}

=== END ERROR LOG ==="""
            
            def on_copy_log():
                # Usar get_last_fragment() para compatibilidade
                fragment = get_last_fragment()
                if hasattr(fragment, 'getParentActivity') and fragment.getParentActivity():
                    context = fragment.getParentActivity()
                else:
                    from org.telegram.messenger import ApplicationLoader
                    context = ApplicationLoader.applicationContext
                
                # Copiar para clipboard usando context
                clipboard = context.getSystemService(Context.CLIPBOARD_SERVICE)
                clip = ClipData.newPlainText("log", detailed_log)
                clipboard.setPrimaryClip(clip)
                
                run_on_ui_thread(lambda: (
                    BulletinHelper.show_success(tr("copied_bulletin") if "copied_bulletin" in TRANSLATIONS else "Log copiado!", fragment)
                ))
            
            # Mostrar bulletin com botão de copiar (similar ao .list)
            error_icon = getattr(R.raw, "error", R.raw.info)
            run_on_ui_thread(lambda: BulletinHelper.show_with_button(
                error_info["message"],
                error_icon,
                tr("copy_button") if "copy_button" in TRANSLATIONS else "Copiar Log",
                on_copy_log,
                fragment
            ))
            
        except Exception as e:
            log(f"[Nowfy] Error showing credentials error bulletin: {e}")
            # Fallback para bulletin simples - só mostrar se não foi mostrado recentemente
            if self._should_show_error_bulletin("fallback_error"):
                BulletinHelper.show_info(tr("error_auth"))

     # --- AUTENTICAÇÃO SPOTIFY ---
    def _get_masked_setting(self, key):
        value = self.get_setting(key, "")
        if value and isinstance(value, str) and len(value) > 8:
            return value[:4] + "****" + value[-4:]
        elif value:
            return "****"
        return ""

    def _nlog(self, message):
        # Helper interno: respeita o estado de mute e evita exceptions de log
        if _NOWFY_LOGS_MUTED:
            return
        try:
            log(message)
        except Exception:
            pass

    def _get_access_token(self, show_error_bulletin=False):
        client_id = self.get_setting("client_id", "")
        client_secret = self.get_setting("client_secret", "")
        refresh_token = self.get_setting("refresh_token", "")
        self._nlog(f"[Nowfy] Credentials check - Client ID: {bool(client_id)}, Client Secret: {bool(client_secret)}, Refresh Token: {bool(refresh_token)}")
        
        # Verificar credenciais ausentes
        if not client_id or not client_secret or not refresh_token:
            missing_creds = []
            if not client_id: missing_creds.append("Client ID")
            if not client_secret: missing_creds.append("Client Secret")
            if not refresh_token: missing_creds.append("Refresh Token")
            
            error_log = f"[Nowfy] Missing credentials: {', '.join(missing_creds)}"
            self._nlog(error_log)
            # Só mostrar bulletin se explicitamente solicitado (comando .now)
            if show_error_bulletin and self._should_show_error_bulletin("missing_credentials"):
                self._show_credentials_error_bulletin("missing_credentials", error_log, missing_creds)
            return None
            
        try:
            auth = base64.b64encode(f"{client_id}:{client_secret}".encode()).decode()
            resp = requests.post(
                "https://accounts.spotify.com/api/token",
                data={"grant_type": "refresh_token", "refresh_token": refresh_token},
                headers={"Authorization": f"Basic {auth}"},
                timeout=5
            )
            self._nlog(f"[Nowfy] Token request response - Status: {resp.status_code}")
            
            if resp.status_code == 400:
                # Erro de credenciais inválidas
                try:
                    error_data = resp.json()
                    error_description = error_data.get("error_description", "Invalid credentials")
                    error_log = f"[Nowfy] Invalid credentials - Status: {resp.status_code}, Error: {error_description}"
                    self._nlog(error_log)
                    if show_error_bulletin and self._should_show_error_bulletin("invalid_credentials"):
                        self._show_credentials_error_bulletin("invalid_credentials", error_log, ["Client ID", "Client Secret"])
                except:
                    error_log = f"[Nowfy] Invalid credentials - Status: {resp.status_code}, Response: {resp.text if hasattr(resp, 'text') else 'No response text'}"
                    self._nlog(error_log)
                    if show_error_bulletin and self._should_show_error_bulletin("invalid_credentials"):
                        self._show_credentials_error_bulletin("invalid_credentials", error_log, ["Client ID", "Client Secret"])
                return None
            elif resp.status_code == 401:
                # Token de refresh inválido
                error_log = f"[Nowfy] Invalid refresh token - Status: {resp.status_code}, Response: {resp.text if hasattr(resp, 'text') else 'No response text'}"
                self._nlog(error_log)
                if show_error_bulletin and self._should_show_error_bulletin("invalid_refresh_token"):
                    self._show_credentials_error_bulletin("invalid_refresh_token", error_log, ["Refresh Token"])
                return None
            elif resp.status_code != 200:
                # Outros erros de API
                error_log = f"[Nowfy] API error - Status: {resp.status_code}, Response: {resp.text if hasattr(resp, 'text') else 'No response text'}"
                self._nlog(error_log)
                if show_error_bulletin and self._should_show_error_bulletin("api_error"):
                    self._show_credentials_error_bulletin("api_error", error_log, [])
                return None
                
            data = resp.json()
            access_token = data.get("access_token")
            self._nlog(f"[Nowfy] Access token obtained successfully: {bool(access_token)}")
            return access_token
        except Exception as e:
            error_log = f"[Nowfy] Exception getting access token: {str(e)}"
            self._nlog(error_log)
            if show_error_bulletin and self._should_show_error_bulletin("connection_error"):
                self._show_credentials_error_bulletin("connection_error", error_log, [])
            return None

    def _exchange_code(self, code):
        log(f"[NowFy] Iniciando _exchange_code com código: {code[:10]}...")
        
        client_id = self.get_setting("client_id", "")
        client_secret = self.get_setting("client_secret", "")
        
        log(f"[NowFy] Client ID: {client_id[:10] if client_id else 'VAZIO'}...")
        log(f"[NowFy] Client Secret: {client_secret[:10] if client_secret else 'VAZIO'}...")
        
        if not client_id or not client_secret:
            log("[NowFy] Credenciais faltando!")
            return False, "Missing Client ID or Client Secret"
            
        try:
            auth = base64.b64encode(f"{client_id}:{client_secret}".encode()).decode()
            log(f"[NowFy] Auth header criado: {auth[:20]}...")
            
            payload = {
                "grant_type": "authorization_code", 
                "code": code, 
                "redirect_uri": "https://example.com/callback"
            }
            log(f"[NowFy] Payload: {payload}")
            
            resp = requests.post(
                "https://accounts.spotify.com/api/token",
                data=payload,
                headers={"Authorization": f"Basic {auth}"},
                timeout=10
            )
            
            log(f"[NowFy] Status da resposta: {resp.status_code}")
            log(f"[NowFy] Resposta completa: {resp.text}")
            
            if resp.status_code != 200:
                error_msg = f"Spotify API Error {resp.status_code}"
                try:
                    error_data = resp.json()
                    if "error_description" in error_data:
                        error_msg = error_data["error_description"]
                    elif "error" in error_data:
                        error_msg = error_data["error"]
                except:
                    pass
                log(f"[NowFy] ERRO na API do Spotify: {resp.status_code} - {resp.text}")
                return False, error_msg
                
            data = resp.json()
            log(f"[NowFy] Dados recebidos: {list(data.keys())}")
            
            if "refresh_token" in data:
                refresh_token = data["refresh_token"]
                self.set_setting("refresh_token", refresh_token)
                log(f"[NowFy] Refresh token salvo: {refresh_token[:10]}...")
                
                if "access_token" in data:
                    self.set_setting("access_token", data["access_token"])
                    self.set_setting("token_expiry", str(int(time.time()) + data.get("expires_in", 3600)))
                    log(f"[NowFy] Access token também salvo")
                
                log(f"[NowFy] SUCESSO! Token obtido")
                return True, None
            else:
                error_msg = f"No refresh_token in response: {list(data.keys())}"
                log(f"[NowFy] Resposta sem refresh_token: {data}")
                return False, error_msg
                
        except Exception as e:
            error_msg = f"Exception: {str(e)}"
            log(f"[NowFy] EXCEÇÃO ao trocar código: {str(e)}")
            import traceback
            log(f"[NowFy] Traceback: {traceback.format_exc()}")
            return False, error_msg
    # --- EXPERIMENTAL ---  


    def _validate_credentials(self):
        return self._get_access_token() is not None

    def _get_spotify_user_profile(self):
        """Obtém informações do perfil do usuário usando a API oficial do Spotify."""
        try:
            token = self._get_access_token(show_error_bulletin=False)
            if not token:
                return None
            
            # Usar o endpoint /me para obter o perfil do usuário atual
            resp = requests.get(
                "https://api.spotify.com/v1/me",
                headers={"Authorization": f"Bearer {token}"},
                timeout=5
            )
            
            if resp.status_code == 200 and resp.content:
                data = resp.json()
                
                # Extrair informações do perfil
                profile_info = {
                    "display_name": data.get("display_name", ""),
                    "id": data.get("id", ""),
                    "followers": data.get("followers", {}).get("total", 0),
                    "country": data.get("country", ""),
                    "product": data.get("product", ""),  # free, premium, etc.
                    "images": data.get("images", [])
                }
                
                # Obter a melhor imagem de perfil disponível
                if profile_info["images"]:
                    # Ordenar por tamanho (maior primeiro) e pegar a primeira
                    sorted_images = sorted(
                        profile_info["images"], 
                        key=lambda x: x.get("width", 0) * x.get("height", 0), 
                        reverse=True
                    )
                    profile_info["profile_image_url"] = sorted_images[0].get("url", "")
                else:
                    profile_info["profile_image_url"] = ""
                
                return profile_info
            
            return None
        except Exception as e:
            log(f"[Nowfy] Error getting Spotify user profile: {str(e)}")
            return None

    def create_link_options_subfragment(self):
        # Detectar se FM está ativo
        current_player_setting = self.get_setting("current_player", 0)
        is_fm_player = current_player_setting == 7

        # Calcular visibilidade para duplicar "Player" em Apple, Spotlight e Vinify
        external_themes = self._get_external_themes() or {}
        current_theme = self.get_setting("theme_selector", 0)
        spotlight_index = len(external_themes) + 1
        vinify_index = spotlight_index + 1
        nowv_index = vinify_index + 1
        show_player_duplicate = is_fm_player and (current_theme in [0, spotlight_index, vinify_index, nowv_index])

        options = [
            # Platform Links Selector
            Selector(
                key="platform_links",
                text=tr("platform_links"),
                default=0,  # Spotify como padrão
                items=[
                    tr("platform_links_spotify"),
                    tr("platform_links_universal"),
                    tr("platform_links_both")
                ],
                icon="msg_link",
                on_change=lambda value: self.show_universal_link_dialog() if value == 1 else None
            ),
            Switch(
                key="show_track_link",
                text=tr("show_track_link"),
                subtext=tr("show_track_link_sub"),
                default=True,
                icon="filled_link_remix"
            ),
            # Seção FM Links
            Divider(text=tr("fm_links_section")),
            Selector(
                key="fm_link_option",
                icon="menu_username_change",
                text=tr("fm_link_selector"),
                default=0,
                items=["None", "LastFM", "StatsFM", "Custom Link"]
            )
        ]

        # Input Custom Link (URL) abaixo de FM Link, visível apenas com FM ativo
        if is_fm_player:
            options.append(Input(
                key="fm_custom_link_url",
                text=tr("fm_custom_link_url") if "fm_custom_link_url" in TRANSLATIONS else "Custom Link (URL)",
                icon="msg_link2_remix",
                default=self.get_setting("fm_custom_link_url", ""),
                subtext=tr("fm_custom_link_url_sub") if "fm_custom_link_url_sub" in TRANSLATIONS else "Paste here the custom link for FM"
            ))

        # Duplicar input "Player" quando FM ativo e tema Apple/Vinify/Spotlight
        if show_player_duplicate:
            options.append(Input(
                key="fm_custom_player_name",
                text=tr("customfm_custom_player_name") if "customfm_custom_player_name" in TRANSLATIONS else "Player",
                icon="msg_photo_text_framed3",
                default=self.get_setting("fm_custom_player_name", "Custom Player"),
                subtext=tr("customfm_custom_player_name_sub") if "customfm_custom_player_name_sub" in TRANSLATIONS else "Custom player name for FM"
            ))

        return options

    def create_advanced_options_subfragment(self):
        return [
            Divider(text=tr("thumbnail_cache_section")),  
            # Cache de Thumbnails
            Switch(
                key="enable_youtube_thumbnail_cache",
                text=tr("youtube_cache"),
                subtext=tr("youtube_cache_sub"),
                default=False,
                icon="msg_data"
            ),
            Switch(
                key="enable_soundcloud_thumbnail_cache",
                text=tr("soundcloud_cache"),
                subtext=tr("soundcloud_cache_sub"),
                default=False,
                icon="msg_data"
            ),
            
            Divider(text=tr("quality_options_section")),
            # Opções de Qualidade
            Switch(
                key="enable_quality_fallback",
                text=tr("quality_fallback"),
                subtext=tr("quality_fallback_sub"),
                default=True,
                icon="msg_retry"
            ),
            Switch(
                key="enable_url_cache",
                text=tr("url_cache"),
                subtext=tr("url_cache_sub"),
                default=True,
                icon="msg_link"
            ),
            Switch(
                key="enable_adaptive_compression",
                text=tr("adaptive_compression"),
                subtext=tr("adaptive_compression_sub"),
                default=False,
                icon="msg_premium_speed"
            )
        ]

    def create_spotify_credentials_subfragment(self):
        show_auth = self.get_setting("show_spotify_auth", True)
        items = [
            Divider(text=tr("spotify_auth_section")),
            Switch(
                key="show_spotify_auth",
                text=tr("spotify_auth_toggle") if "spotify_auth_toggle" in TRANSLATIONS else "Spotify Auth",
                subtext=tr("spotify_auth_toggle_sub") if "spotify_auth_toggle_sub" in TRANSLATIONS else "Expandir para configurar credenciais do Spotify",
                default=show_auth,
                icon="msg_filled_unlockedrecord",
                on_change=lambda v: self.reload_settings()
            )
        ]
        if show_auth:
            # Credenciais de Autenticação
            items.extend([
                Input(
                    key="client_id",
                    text=tr("client_id"),
                    default=self.get_setting("client_id", ""),
                    icon="trusted_mini",
                    subtext=tr("client_id_subtext")
                ),
                Input(
                    key="client_secret",
                    text=tr("client_secret"),
                    default=self.get_setting("client_secret", ""),
                    icon="trusted_mini",
                    subtext=tr("client_secret_subtext")
                ),
                Input(
                    key="refresh_token",
                    text=tr("refresh_token"),
                    default=self.get_setting("refresh_token", ""),
                    icon="trusted_mini",
                    subtext=tr("refresh_token_subtext")
                ),
            ])
        else:
            items.append(Text(text=tr("spotify_auth_hidden_notice"), icon="msg_info"))

        items.extend([
            Divider(text=tr("spotify_help_section")),
            # Ajuda e Informações
            Text(
                text=tr("credentials_info"),
                icon="msg2_help",
                accent=True,
                on_click=lambda view: self._show_credentials_info_dialog()
            ),
            Text(
                text=tr("spotify_control"),
                icon="live_stream",
                accent=True,
                on_click=lambda view: self._show_spotify_control_dialog()
            ),
        ])
        return items

    def create_lastfm_credentials_subfragment(self):
        visible = self.get_setting("lastfm_api_key_visible", True)
        items = [
            Divider(text=tr("lastfm_auth_section")),          
            # Credenciais Last.FM
            Input(
                key="lastfm_username",
                text=tr("lastfm_username"),
                icon="menu_username_change",
                default=self.get_setting("lastfm_username", ""),
                subtext=tr("lastfm_user_subtext")
            ),
            Switch(
                key="lastfm_api_key_visible",
                text=tr("lastfm_key_visibility"),
                subtext=tr("lastfm_key_visibility_sub"),
                default=self.get_setting("lastfm_api_key_visible", True),
                icon="msg_permissions_solar"
            ),
        ]
        if visible:
            items.append(
                Input(
                    key="lastfm_api_key",
                    text=tr("lastfm_api_key"),
                    icon="filled_access_fingerprint",
                    default=self.get_setting("lastfm_api_key", ""),
                    subtext=tr("lastfm_api_key_subtext")
                )
            )
        items += [
            Divider(text=tr("lastfm_help_section")),        
            # Ajuda e Testes
            Text(
                text=tr("test_lastfm_account"),
                icon="msg_limit_accounts",
                accent=True,
                on_click=lambda view: self._test_lastfm_account()
            ),
            Text(
                text=tr("lastfm_title"),
                icon="msg2_help",
                accent=True,
                on_click=lambda view: self._show_lastfm_api_dialog()
            ),
        ]
        return items

    def create_statsfm_credentials_subfragment(self):
        return [
            Input(
                key="statsfm_username",
                text=tr("statsfm_username"),
                icon="menu_username_change",
                default=self.get_setting("statsfm_username", ""),
                subtext=tr("statsfm_username_sub")
            ),
        ]
    
    # Atualiza traduções para o bloco "How to Use" do NowCast
    TRANSLATIONS.update({
        "nowcast_how_to_use_title": {
            "pt": "Como usar o NowCast",
            "en": "How to Use NowCast",
            "es": "Cómo usar NowCast",
            "fr": "Comment utiliser NowCast",
            "ru": "Как использовать NowCast"
        },
        "nowcast_how_to_use": {
            "pt": "COMO USAR O NOWCAST\n\nATIVAÇÃO:\n• Use o comando .bot para ativar e iniciar o NowCast.\n\nFUNCIONAMENTO:\n• Após alguns segundos, uma notificação (bulletin) aparecerá exibindo a música atual.\n• Em seguida, dentro de mais alguns segundos, o bot realizará o primeiro post no canal configurado.\n\nDESATIVAÇÃO AUTOMÁTICA:\n• Se a música ficar em pausa/inativa por mais de 10 minutos, o NowCast será desativado automaticamente.\n\nCOMPATIBILIDADE:\n• NowCast é exclusivo para Spotify (API).",
            "en": "HOW TO USE NOWCAST\n\nACTIVATION:\n• Use the .bot command to activate and start NowCast.\n\nOPERATION:\n• After a few seconds, a bulletin notification will appear showing the current song.\n• Then, within a few more seconds, the bot will make the first post in the configured channel.\n\nAUTO DISABLE:\n• If music is paused/inactive for more than 10 minutes, NowCast will automatically disable.\n\nCOMPATIBILITY:\n• NowCast is exclusive to Spotify (API).",
            "es": "CÓMO USAR NOWCAST\n\nACTIVACIÓN:\n• Usa el comando .bot para activar e iniciar NowCast.\n\nFUNCIONAMIENTO:\n• Tras unos segundos, aparecerá una notificación (bulletin) mostrando la canción actual.\n• Luego, en unos segundos más, el bot realizará la primera publicación en el canal configurado.\n\nDESACTIVACIÓN AUTOMÁTICA:\n• Si la música está en pausa/inactiva por más de 10 minutos, NowCast se desactivará automáticamente.\n\nCOMPATIBILIDAD:\n• NowCast es exclusivo para Spotify (API).",
            "fr": "COMMENT UTILISER NOWCAST\n\nACTIVATION:\n• Utilisez la commande .bot pour activer et démarrer NowCast.\n\nFONCTIONNEMENT:\n• Après quelques secondes, une notification (bulletin) apparaîtra affichant la chanson en cours.\n• Ensuite, en quelques secondes, le bot effectuera la première publication dans le canal configuré.\n\nDÉSACTIVATION AUTOMATIQUE:\n• Si la musique est en pause/inactive pendant plus de 10 minutes, NowCast sera désactivé automatiquement.\n\nCOMPATIBILITÉ:\n• NowCast est exclusif à Spotify (API).",
            "ru": "КАК ИСПОЛЬЗОВАТЬ NOWCAST\n\nАКТИВАЦИЯ:\n• Используйте команду .bot, чтобы активировать и запустить NowCast.\n\nРАБОТА:\n• Через несколько секунд появится уведомление (bulletin), показывающее текущую песню.\n• Затем, ещё через несколько секунд, бот выполнит первую публикацию в настроенном канале.\n\nАВТООТКЛЮЧЕНИЕ:\n• Если музыка поставлена на паузу/неактивна более 10 минут, NowCast будет автоматически отключён.\n\nСОВМЕСТИМОСТЬ:\n• NowCast работает только со Spotify (API)."
        }
    })

    # Dynamic Island translations
    TRANSLATIONS.update({
        "dynamic_island_label": {
            "pt": "Ativar Floatify",
            "en": "Enable Floatify",
            "es": "Activar Floatify",
            "fr": "Activer Floatify",
            "ru": "Включить Floatify"
        },
        "dynamic_island_sub": {
            "pt": "Mostra um painel interativo com a música atual e controles de reprodução",
            "en": "Displays an interactive panel with the current track and playback controls",
            "es": "Muestra un panel interactivo con la pista actual y los controles de reproducción",
            "fr": "Affiche un panneau interactif avec le morceau actuel et les commandes de lecture",
            "ru": "Отображает интерактивную панель с текущей песней и элементами управления воспроизведением"
        },
        "dynamic_island_started": {
            "pt": "Floatify iniciado",
            "en": "Floatify started",
            "es": "Floatify iniciado",
            "fr": "Floatify démarré",
            "ru": "Floatify запущен"
        },
        "mini_control_label": {
            "pt": "Mini Control",
            "en": "Mini Control",
            "es": "Mini Control",
            "fr": "Mini Contrôle",
            "ru": "Мини-контроль"
        },
        "mini_control_sub": {
            "pt": "Controles básicos abaixo da ilha (anterior, reproduzir/pausar, próxima)",
            "en": "Basic controls below the island (prev, play/pause, next)",
            "es": "Controles básicos debajo de la isla (anterior, reproducir/pausar, siguiente)",
            "fr": "Contrôles basiques sous l’île (préc., lecture/pause, suiv.)",
            "ru": "Базовые элементы под островом (пред., восп./пауза, след.)"
        },
    })

    # Floatify welcome divider translation
    TRANSLATIONS.update({
        "floatify_welcome_brief": {
            "pt": "Bem-vindo(a), {name}! O Floatify está pronto para você.",
            "en": "Welcome, {name}! Floatify is ready for you.",
            "es": "¡Bienvenido(a), {name}! Floatify está listo para ti.",
            "fr": "Bienvenue, {name} ! Floatify est prêt pour vous.",
            "ru": "Добро пожаловать, {name}! Floatify готов для вас."
        }
    })

    # Overlay bulletin messages for Pop Island gating
    TRANSLATIONS.update({
        "overlay_pop_island_activated_title": {
            "pt": "Floatify ativado",
            "en": "Floatify activated",
            "es": "Floatify activado",
            "fr": "Floatify activée",
            "ru": "Floatify активирован"
        },
        "overlay_spotify_only_subtitle": {
            "pt": "Mas é exclusivo para Spotify (API)",
            "en": "But it’s exclusive to Spotify (API)",
            "es": "Pero es exclusivo de Spotify (API)",
            "fr": "Mais c’est exclusif à Spotify (API)",
            "ru": "Но это эксклюзивно для Spotify (API)"
        },
        "pop_island_title": {
            "pt": "Floatify",
            "en": "Floatify",
            "es": "Floatify",
            "fr": "Floatify",
            "ru": "Floatify"
        },
        "overlay_enable_bulletin_action": {
            "pt": "Show now",
            "en": "Show now",
            "es": "Mostrar ahora",
            "fr": "Afficher maintenant",
            "ru": "Показать сейчас"
        },
        "dynamic_island_auto_disabled_subtitle": {
            "pt": "Disabled due to inactivity",
            "en": "Disabled due to inactivity",
            "es": "Desactivada por inactividad",
            "fr": "Désactivée pour inactivité",
            "ru": "Отключено из-за неактивности"
        },
        "overlay_island_prompt_subtitle": {
            "pt": "Ilha ativada, mas não iniciada",
            "en": "Island enabled but not started",
            "es": "Isla activada pero no iniciada",
            "fr": "Île activée mais non démarrée",
            "ru": "Остров включён, но не запущен"
        }
    })

    TRANSLATIONS.update({
        "overlay_activation_bulletin_label": {
            "pt": "Activation bulletin",
            "en": "Activation bulletin",
            "es": "Activation bulletin",
            "fr": "Activation bulletin",
            "ru": "Activation bulletin"
        },
        "overlay_activation_bulletin_sub": {
            "pt": "Show a notice with button when enabling Island",
            "en": "Show a notice with button when enabling Island",
            "es": "Show a notice with button when enabling Island",
            "fr": "Show a notice with button when enabling Island",
            "ru": "Show a notice with button when enabling Island"
        },
        "overlay_auto_disable_inactivity_label": {
            "pt": "Auto-disable on inactivity",
            "en": "Auto-disable on inactivity",
            "es": "Auto-disable on inactivity",
            "fr": "Auto-disable on inactivity",
            "ru": "Auto-disable on inactivity"
        },
        "overlay_auto_disable_inactivity_sub": {
            "pt": "Disable when no music and no interaction",
            "en": "Disable when no music and no interaction",
            "es": "Disable when no music and no interaction",
            "fr": "Disable when no music and no interaction",
            "ru": "Disable when no music and no interaction"
        },
        "overlay_inactivity_timeout_label": {
            "pt": "Inactivity timeout",
            "en": "Inactivity timeout",
            "es": "Inactivity timeout",
            "fr": "Inactivity timeout",
            "ru": "Inactivity timeout"
        },
        "mods_section": {
            "pt": "MODS",
            "en": "MODS",
            "es": "MODS",
            "fr": "MODS",
            "ru": "MODS"
        },
        "mods_section_sub": {
            "pt": "Funcionalidades experimentais e avançadas",
            "en": "Experimental and advanced features",
            "es": "Funciones experimentales y avanzadas",
            "fr": "Fonctionnalités expérimentales et avancées",
            "ru": "Экспериментальные и расширенные функции"
        }
    })

    # Overlay activation confirmation after card sent
    TRANSLATIONS.update({
        "overlay_island_started_title": {
            "pt": "Floatify iniciado",
            "en": "Floatify started",
            "es": "Floatify iniciado",
            "fr": "Floatify démarré",
            "ru": "Floatify запущен"
        },
        "overlay_island_started_subtitle": {
            "pt": "Agora ativo após enviar o card",
            "en": "Now active after sending the card",
            "es": "Ahora activo tras enviar la tarjeta",
            "fr": "Actif après l’envoi de la carte",
            "ru": "Активирован после отправки карточки"
        }
    })

    # Pop Style selector and Nowfy drawer translations
    TRANSLATIONS.update({
        "pop_style_label": {
            "pt": "Estilo Pop",
            "en": "Pop Style",
            "es": "Estilo Pop",
            "fr": "Style Pop",
            "ru": "Стиль Pop"
        },
        "pop_style_rounded": {
            "pt": "Arredondado",
            "en": "Rounded",
            "es": "Redondeado",
            "fr": "Arrondi",
            "ru": "Скруглённый"
        },
        "pop_style_circular": {
            "pt": "Circular",
            "en": "Circular",
            "es": "Circular",
            "fr": "Circulaire",
            "ru": "Круглый"
        },
        "nowfy_drawer_label": {
            "pt": "Nowfy no menu lateral",
            "en": "Nowfy in side menu",
            "es": "Nowfy en el menú lateral",
            "fr": "Nowfy dans le menu latéral",
            "ru": "Nowfy в боковом меню"
        },
        "nowfy_drawer_sub": {
            "pt": "Adiciona atalho do Nowfy na gaveta (lateral)",
            "en": "Adds a Nowfy shortcut to the drawer",
            "es": "Añade un acceso directo de Nowfy al menú",
            "fr": "Ajoute un raccourci Nowfy au tiroir",
            "ru": "Добавляет ярлык Nowfy в меню"
        },
        "nowfy_drawer": {
            "pt": "Nowfy",
            "en": "Nowfy",
            "es": "Nowfy",
            "fr": "Nowfy",
            "ru": "Nowfy"
        },
    })

    # Pop Island subfragment titles and options
    TRANSLATIONS.update({
        "pop_island_settings_title": {
            "pt": "Floatify",
            "en": "Floatify",
            "es": "Floatify",
            "fr": "Floatify",
            "ru": "Floatify"
        },
        "pop_island_options_section": {
            "pt": "Opções",
            "en": "Options",
            "es": "Opciones",
            "fr": "Options",
            "ru": "Опции"
        },
        "pop_island_controls_section": {
            "pt": "Controles",
            "en": "Controls",
            "es": "Controles",
            "fr": "Contrôles",
            "ru": "Элементы управления"
        },
        "pop_island_actions_section": {
            "pt": "Ações",
            "en": "Actions",
            "es": "Acciones",
            "fr": "Actions",
            "ru": "Действия"
        },
        "send_button_sub": {
            "pt": "Mostrar botão Enviar nos Mini Controles",
            "en": "Show Send button in Mini Controls",
            "es": "Mostrar botón Enviar en los Mini Controles",
            "fr": "Afficher le bouton Envoyer dans les Mini Contrôles",
            "ru": "Показывать кнопку Отправить в мини-управлении"
        },
        "search_button_label": {
            "pt": "Pesquisar",
            "en": "Search",
            "es": "Buscar",
            "fr": "Rechercher",
            "ru": "Поиск"
        },
        "search_button_sub": {
            "pt": "Mostrar botão Pesquisar nos Mini Controles (Spotify API)",
            "en": "Show Search button in Mini Controls (Spotify API)",
            "es": "Mostrar botón Buscar en los Mini Controles (Spotify API)",
            "fr": "Afficher le bouton Rechercher dans les Mini Contrôles (Spotify API)",
            "ru": "Показать кнопку Поиск в мини-элементах управления (Spotify API)"
        },
        "di_haptic_sub": {
            "pt": "Vibração ao tocar botões do Floatify",
            "en": "Vibration on Floatify button taps",
            "es": "Vibración al tocar botones de Floatify",
            "fr": "Vibration lors des appuis sur les boutons Floatify",
            "ru": "Вибрация при нажатии кнопок Floatify"
        },
        "di_haptic_label": {
            "pt": "Feedback tátil",
            "en": "Haptic feedback",
            "es": "Retroalimentación háptica",
            "fr": "Retour haptique",
            "ru": "Тактильная отдача"
        },
        "pop_size_label": {
            "pt": "Tamanho da Pop",
            "en": "Pop Size",
            "es": "Tamaño de Pop",
            "fr": "Taille du Pop",
            "ru": "Размер Pop"
        },
        "island_styles_label": {
            "pt": "Island Styles",
            "en": "Island Styles",
            "es": "Estilos de Isla",
            "fr": "Styles d'Île",
            "ru": "Стили Острова"
        },
        "island_style_default": {
            "pt": "Padrão",
            "en": "Default",
            "es": "Predeterminado",
            "fr": "Par défaut",
            "ru": "По умолчанию"
        },
        "island_style_bg_cover": {
            "pt": "BG Cover",
            "en": "BG Cover",
            "es": "BG Cover",
            "fr": "BG Cover",
            "ru": "BG Cover"
        },
        "island_style_pure": {
            "pt": "Pure",
            "en": "Pure",
            "es": "Pure",
            "fr": "Pure",
            "ru": "Pure"
        },
        "island_style_no_blur": {
            "pt": "No Blur",
            "en": "No Blur",
            "es": "No Blur",
            "fr": "No Blur",
            "ru": "No Blur"
        },

        "pop_size_small": {
            "pt": "Pequeno",
            "en": "Small",
            "es": "Pequeño",
            "fr": "Petit",
            "ru": "Маленький"
        },
        "pop_size_medium": {
            "pt": "Médio",
            "en": "Medium",
            "es": "Mediano",
            "fr": "Moyen",
            "ru": "Средний"
        },
        "pop_size_large": {
            "pt": "Grande",
            "en": "Large",
            "es": "Grande",
            "fr": "Grand",
            "ru": "Большой"
        }
    })

    # Resource download messages
    TRANSLATIONS.update({
        "resources_downloading": {
            "pt": "Baixando recursos...",
            "en": "Downloading resources...",
            "es": "Descargando recursos...",
            "fr": "Téléchargement des ressources...",
            "ru": "Загрузка ресурсов..."
        },
        "resources_downloaded": {
            "pt": "Recursos baixados",
            "en": "Resources downloaded",
            "es": "Recursos descargados",
            "fr": "Ressources téléchargées",
            "ru": "Ресурсы загружены"
        },
        "resources_download_failed": {
            "pt": "Falha no download. Tente novamente",
            "en": "Download failed. Try again",
            "es": "Error de descarga. Intente otra vez",
            "fr": "Échec du chargement. Réessayez",
            "ru": "Ошибка загрузки. Попробуйте снова"
        },
        "resources_already_downloaded": {
            "pt": "Recursos já estavam baixados",
            "en": "Resources were already downloaded",
            "es": "Los recursos ya estaban descargados",
            "fr": "Les ressources étaient déjà téléchargées",
            "ru": "Ресурсы уже были загружены"
        },
    })

    TRANSLATIONS.update({
        "control_style_label": {
            "pt": "Estilo dos Controles",
            "en": "Control Styles",
            "es": "Estilos de Controles",
            "fr": "Styles des contrôles",
            "ru": "Стиль элементов управления"
        },
        "control_style_classic": {
            "pt": "Clássico",
            "en": "Classic",
            "es": "Clásico",
            "fr": "Classique",
            "ru": "Классический"
        },
        "control_style_modern": {
            "pt": "Moderno",
            "en": "Modern",
            "es": "Moderno",
            "fr": "Moderne",
            "ru": "Современный"
        },
        "control_style_gradient": {
            "pt": "Gradient",
            "en": "Gradient",
            "es": "Gradient",
            "fr": "Gradient",
            "ru": "Градиент"
        },
        "control_style_silver": {
            "pt": "Prateado",
            "en": "Silver",
            "es": "Plateado",
            "fr": "Argent",
            "ru": "Серебристый"
        }
    })

    TRANSLATIONS.update({
        "on_notch_label": {
            "pt": "Always on Top",
            "en": "Always on Top",
            "es": "Siempre Arriba",
            "fr": "Toujours en Haut",
            "ru": "Всегда Сверху"
        },
        "on_notch_sub": {
            "pt": "Define o topo centralizado como posição inicial padrão ao abrir a ilha",
            "en": "Sets top-center as the default initial position when opening the island",
            "es": "Establece el centro superior como posición inicial predeterminada al abrir la isla",
            "fr": "Définit le centre-haut comme position initiale par défaut lors de l'ouverture de l'île",
            "ru": "Устанавливает верх-центр как начальную позицию по умолчанию при открытии острова"
        }
    })

    TRANSLATIONS.update({
        "pop_size_tiny": {
            "pt": "Tiny",
            "en": "Tiny", 
            "es": "Diminuto",
            "fr": "Minuscule",
            "ru": "Крошечный"
        }
    })

    def create_nowcast_subfragment(self):
        """Cria o subfragment para configurações do NowCast"""
        return [
            Switch(
                key="nowcast_enabled",
                text=tr("nowcast_enable"),
                subtext=tr("nowcast_enable_sub"),
                icon="input_bot1",
                default=False
            ),
            Input(
                key="nowcast_bot_token",
                text=tr("nowcast_bot_token"),
                icon="menu_bots_add",
                default=""
            ),
            Input(
                key="nowcast_channel_id",
                text=tr("nowcast_channel_id"),
                icon="msg_channel",
                default="",
                subtext="Ex: -1001234567890"
            ),
            Input(
                key="bot_caption_text",
                text=tr("bot_caption"),
                default="",
                icon="msg_photo_text_framed3",
                subtext=tr("bot_caption_sub")
            ),
            Selector(
                key="nowcast_link_option",
                text=tr("nowcast_link_option"),
                icon="filled_link_remix",
                default=0,
                items=[tr("nowcast_link_none"), tr("nowcast_link_spotify"), tr("nowcast_link_songlink")]
            ),
            Divider(),
            Text(
                text=tr("test_nowcast_connection") if "test_nowcast_connection" in TRANSLATIONS else "Test NowCast Connection",
                icon="msg_send_remix",
                accent=True,
                on_click=lambda view: self._test_nowcast_connection()
            ),
            Text(
                text=tr("clear_nowcast_history") if "clear_nowcast_history" in TRANSLATIONS else "Clear NowCast History",
                icon="menu_clear_recent",
                red=True,
                on_click=lambda view: self._clear_nowcast_history()
            ),
            Text(
                text=tr("nowcast_info_warning_title") if "nowcast_info_warning_title" in TRANSLATIONS else "Important Information About NowCast",
                icon="filled_premium_bots",
                create_sub_fragment=self.create_nowcast_info_warning
            ),
            Text(
                text=tr("nowcast_how_to_use_title") if "nowcast_how_to_use_title" in TRANSLATIONS else "How to Use NowCast",
                icon="msg_info_remix",
                create_sub_fragment=self.create_nowcast_how_to_use
            )
        ]

    def create_pop_island_subfragment(self):
        """Cria o subfragment para funcionalidades do Pop Island"""
        from org.telegram.messenger import LocaleController, R, UserConfig
        # Obtém nome real do usuário (primeiro nome), com fallback para a string do título
        try:
            fragment = get_last_fragment()
            current_account = fragment.getCurrentAccount() if fragment and hasattr(fragment, 'getCurrentAccount') else 0
        except Exception:
            current_account = 0
        try:
            uc = UserConfig.getInstance(current_account)
            user = uc.getCurrentUser()
            user_name = str(getattr(user, 'first_name', None) or getattr(user, 'username', None) or "")
            if not user_name:
                user_name = str(LocaleController.getString("ActionBarTitleName", R.string.ActionBarTitleName))
        except Exception:
            user_name = str(LocaleController.getString("ActionBarTitleName", R.string.ActionBarTitleName))
        settings = [
            Divider(
                text=(tr("floatify_welcome_brief") if "floatify_welcome_brief" in TRANSLATIONS else "Bem-vindo(a), {name}!").format(
                    name=user_name
                )
            ),
            Switch(
                key="dynamic_island_overlay",
                text=(tr("dynamic_island_label") if "dynamic_island_label" in TRANSLATIONS else "Enable Island"),
                subtext=tr("dynamic_island_sub"),
                default=self.get_setting("dynamic_island_overlay", False),
                icon="msg_tone_on",
                on_change=lambda v: (
                    self._toggle_dynamic_island_overlay(v),
                    self.reload_settings()
                )
            ),

        ] + [
            # Removido: seletor de Notch Height (não é mais necessário)

            Text(
                text=(tr("pop_island_preview") if "pop_island_preview" in TRANSLATIONS else "Preview Floatify"),
                icon="msg_view_file",
                accent=True,
                on_click=lambda v: self._show_dynamic_island_preview_dialog()
            ),
            Divider(text=(tr("pop_island_options_section") if "pop_island_options_section" in TRANSLATIONS else "Opções")),

            Selector(
                key="pop_style_selector",
                text=(tr("pop_style_label") if "pop_style_label" in TRANSLATIONS else "Pop Style"),
                default=self.get_setting("pop_style_selector", 0),
                items=[
                    tr("pop_style_rounded") if "pop_style_rounded" in TRANSLATIONS else "Rounded",
                    tr("pop_style_circular") if "pop_style_circular" in TRANSLATIONS else "Circular",
                ],
                icon="msg_theme",
                on_change=lambda v: (
                    self.set_setting("pop_style_selector", v),
                    self._apply_pop_style_to_overlay()
                )
            ),
            Selector(
                key="pop_size_selector",
                text=(tr("pop_size_label") if "pop_size_label" in TRANSLATIONS else "Pop Size"),
                default=self.get_setting("pop_size_selector", 2),  # Ajustar padrão para Medium (índice 2)
                items=[
                    (tr("pop_size_tiny") if "pop_size_tiny" in TRANSLATIONS else "Tiny"),
                    tr("pop_size_small") if "pop_size_small" in TRANSLATIONS else "Small",
                    tr("pop_size_medium") if "pop_size_medium" in TRANSLATIONS else "Medium",
                    tr("pop_size_large") if "pop_size_large" in TRANSLATIONS else "Large",
                ],
                icon="msg_call_minimize",
                on_change=lambda v: (
                    self.set_setting("pop_size_selector", v),
                    self._apply_pop_style_to_overlay()
                )
            ),
            Selector(
                key="island_styles_selector",
                text=(tr("island_styles_label") if "island_styles_label" in TRANSLATIONS else "Island Styles"),
                default=self.get_setting("island_styles_selector", 0),
                items=[
                    tr("island_style_default") if "island_style_default" in TRANSLATIONS else "Default",
                    tr("island_style_bg_cover") if "island_style_bg_cover" in TRANSLATIONS else "BG Cover",
                    tr("island_style_pure") if "island_style_pure" in TRANSLATIONS else "Pure",
                    tr("island_style_no_blur") if "island_style_no_blur" in TRANSLATIONS else "No Blur",
                ],
                icon="msg_background",
                on_change=lambda v: (
                    self.set_setting("island_styles_selector", v),
                    self._apply_island_style_to_overlay()
                )
            ),
            Divider(text=(tr("pop_island_controls_section") if "pop_island_controls_section" in TRANSLATIONS else "Controles")),
            Switch(
                key="mini_control_enabled",
                text=tr("mini_control_label"),
                subtext=tr("mini_control_sub"),
                default=self.get_setting("mini_control_enabled", False),
                icon="msg_mini_customize_solar",
                on_change=lambda v: (
                    self._toggle_mini_control(v),
                    self.reload_settings()
                )
            ),
            Selector(
                key="control_style_selector",
                text=(tr("control_style_label") if "control_style_label" in TRANSLATIONS else "Control Styles"),
                default=self.get_setting("control_style_selector", 0),
                items=[
                    tr("control_style_classic") if "control_style_classic" in TRANSLATIONS else "Classic",
                    tr("control_style_modern") if "control_style_modern" in TRANSLATIONS else "Modern",
                    tr("control_style_gradient") if "control_style_gradient" in TRANSLATIONS else "Gradient",
                    (tr("control_style_silver") if "control_style_silver" in TRANSLATIONS else "Silver"),
                ],
                icon="ic_send_solar",
                on_change=lambda v: (
                    self.set_setting("control_style_selector", v),
                    self._apply_control_style_to_overlay()
                )
            ),
            Switch(
                key="send_button_enabled",
                text=(tr("send_button_label") if "send_button_label" in TRANSLATIONS else "Send"),
                subtext=(tr("send_button_sub") if "send_button_sub" in TRANSLATIONS else "Show Send button in Mini Controls"),
                default=self.get_setting("send_button_enabled", False),
                icon="msg_forward",
                on_change=lambda v: (
                    self._toggle_send_button(v),
                    self.reload_settings()
                )
            ),
            Switch(
                key="search_button_enabled",
                text=(tr("search_button_label") if "search_button_label" in TRANSLATIONS else "Search"),
                subtext=(tr("search_button_sub") if "search_button_sub" in TRANSLATIONS else "Show Search button in Mini Controls (Spotify API)"),
                default=self.get_setting("search_button_enabled", False),
                icon="msg_search",
                on_change=lambda v: (
                    self._toggle_search_button(v),
                    self.reload_settings()
                )
            ),


            # MODS Section - Funcionalidades experimentais e avançadas
            Text(
                text=(tr("mods_section") if "mods_section" in TRANSLATIONS else "MODS"),
                icon="msg_customize",
                accent=True,
                create_sub_fragment=self.create_mods_subfragment
            ),
            Text(
                text=(tr("resources_button") if "resources_button" in TRANSLATIONS else "Resources"),
                icon="msg_saved_ny_remix",
                accent=True,
                on_click=lambda v: self._download_pop_island_resources()
            ),
        ]
        return settings

    def create_mods_subfragment(self):
        """Cria o subfragment MODS com funcionalidades experimentais e avançadas"""
        return [
            Header(text=(tr("mods_section") if "mods_section" in TRANSLATIONS else "MODS")),
            
# Always on Top
            Switch(
                key="on_notch_enabled",
                text=(tr("on_notch_label") if "on_notch_label" in TRANSLATIONS else "Always on Top"),
                subtext=(tr("on_notch_sub") if "on_notch_sub" in TRANSLATIONS else "Keeps the island always fixed at the top of the screen, centered"),
                default=self.get_setting("on_notch_enabled", False),
                icon="msg_go_up",
                on_change=lambda v: (
                    self.set_setting("on_notch_enabled", v),
                    self._reposition_dynamic_island_to_notch(),
                    self.reload_settings()
                )
            ),
            
            Divider(),
            
            # Activation bulletin
            Switch(
                key="overlay_activation_bulletin_enabled",
                text=(tr("overlay_activation_bulletin_label") if "overlay_activation_bulletin_label" in TRANSLATIONS else "Activation bulletin"),
                subtext=(tr("overlay_activation_bulletin_sub") if "overlay_activation_bulletin_sub" in TRANSLATIONS else "Show a notice with button when enabling Island"),
                default=self.get_setting("overlay_activation_bulletin_enabled", False),
                icon="msg_notspam",
                on_change=lambda v: self.set_setting("overlay_activation_bulletin_enabled", v)
            ),
            
            Divider(),
            
            # Auto-disable on inactivity
            Switch(
                key="overlay_auto_disable_inactivity",
                text=(tr("overlay_auto_disable_inactivity_label") if "overlay_auto_disable_inactivity_label" in TRANSLATIONS else "Auto-disable on inactivity"),
                subtext=(tr("overlay_auto_disable_inactivity_sub") if "overlay_auto_disable_inactivity_sub" in TRANSLATIONS else "Disable when no music and no interaction"),
                default=self.get_setting("overlay_auto_disable_inactivity", False),
                icon="msg2_night_auto",
                on_change=lambda v: self.set_setting("overlay_auto_disable_inactivity", v)
            ),
            
            # Inactivity timeout
            Selector(
                key="overlay_inactivity_timeout_minutes",
                text=(tr("overlay_inactivity_timeout_label") if "overlay_inactivity_timeout_label" in TRANSLATIONS else "Inactivity timeout"),
                default=([5,10,15,30,60,1].index(self.get_setting("overlay_inactivity_timeout_minutes", 10)) if self.get_setting("overlay_inactivity_timeout_minutes", 10) in [5,10,15,30,60,1] else 1),
                items=["5 min","10 min","15 min","30 min","60 min","1 min"],
                icon="msg_stories_timer",
                on_change=lambda v: self.set_setting("overlay_inactivity_timeout_minutes", [5,10,15,30,60,1][v])
            ),
            
            Divider(),
            
            # Haptic feedback
            Switch(
                key="di_haptic_enabled",
                text=(tr("di_haptic_label") if "di_haptic_label" in TRANSLATIONS else "Haptic feedback"),
                subtext=(tr("di_haptic_sub") if "di_haptic_sub" in TRANSLATIONS else "Vibration on Floatify button taps"),
                default=self.get_setting("di_haptic_enabled", False),
                icon="msg2_sticker",
                on_change=lambda v: self.reload_settings()
            ),
        ]

    # ===== NOWCAST FUNCTIONS =====
    def _send_nowcast_card(self):
        """Envia card do NowCast adaptado ao tema selecionado"""
        print("[NowCast DEBUG] Iniciando envio de card...")
        if not self.get_setting("nowcast_enabled", False):
            print("[NowCast DEBUG] NowCast não está habilitado")
            return False
            
        token = self.get_setting("nowcast_bot_token", "")
        channel_id = self.get_setting("nowcast_channel_id", "")
        print(f"[NowCast DEBUG] Credenciais bot: token={bool(token)}, channel_id={bool(channel_id)}")
        
        if not token or not channel_id:
            print("[NowCast] Token ou Channel ID não configurado")
            return False
            
        try:
            # Tentar obter música do Stats.fm primeiro (se configurado)
            statsfm_username = self.get_setting("statsfm_username", "")
            track_data = None
            data_source = "spotify"  # padrão
            
            if statsfm_username:
                print("[NowCast DEBUG] Tentando Stats.fm...")
                track_data = self._get_statsfm_current_track(statsfm_username)
                if track_data:
                    data_source = "statsfm"
                    print(f"[NowCast DEBUG] Música obtida via Stats.fm: {track_data.get('title', '')} - {track_data.get('artist', '')}")
                    
                    # Adaptar dados do Stats.fm para formato compatível
                    track = {
                        'name': track_data.get('title', ''),
                        'artists': [{'name': artist.strip()} for artist in track_data.get('artist', '').split(',')],
                        'album': {
                            'name': track_data.get('album', ''),
                            'images': [{'url': track_data.get('image_url', '')}] if track_data.get('image_url') else []
                        },
                        'duration_ms': track_data.get('duration_ms', 0)
                    }
                    progress_ms = track_data.get('progress_ms', 0)
                    is_playing = True
            
            # Se não conseguiu do Stats.fm, usar Spotify (comportamento original)
            if not track_data:
                print("[NowCast DEBUG] Usando Spotify (padrão)...")
                # Verificar credenciais do Spotify
                client_id = self.get_setting("client_id", "")
                client_secret = self.get_setting("client_secret", "")
                refresh_token = self.get_setting("refresh_token", "")
                print(f"[NowCast DEBUG] Credenciais Spotify: {bool(client_id and client_secret and refresh_token)}")
                
                if not (client_id and client_secret and refresh_token):
                    print("[NowCast] Credenciais do Spotify incompletas")
                    return False
                
                # Obter token de acesso
                print("[NowCast DEBUG] Obtendo token de acesso...")
                access_token = self._get_access_token(show_error_bulletin=False)
                print(f"[NowCast DEBUG] Token obtido: {bool(access_token)}")
                if not access_token:
                    print("[NowCast] Erro ao obter token de acesso")
                    return False
                
                # Obter música atual do Spotify
                print("[NowCast DEBUG] Consultando API do Spotify...")
                import requests
                resp = requests.get(
                    "https://api.spotify.com/v1/me/player/currently-playing",
                    headers={"Authorization": f"Bearer {access_token}"},
                    timeout=5
                )
                print(f"[NowCast DEBUG] Resposta Spotify: {resp.status_code}, tem conteúdo: {bool(resp.content)}")
                
                if resp.status_code != 200 or not resp.content:
                    print("[NowCast] Nenhuma música tocando")
                    return False
                
                data = resp.json()
                track = data.get("item")
                progress_ms = data.get("progress_ms", 0)
                is_playing = data.get('is_playing')
                print(f"[NowCast DEBUG] Track: {bool(track)}, is_playing: {is_playing}, progress_ms: {progress_ms}")
                
                if not track or not track.get("name") or not is_playing:
                    print("[NowCast] Música não está tocando")
                    return False
            
            # Preparar dados da música com links para o seletor
            track_title = track.get('name', '')
            track_artists = ', '.join([artist.get('name', '') for artist in track.get('artists', [])])
            spotify_url = track.get('external_urls', {}).get('spotify', '')
            song_link_url = ''
            
            # Gerar song.link se houver URL do Spotify
            if spotify_url:
                song_link_url = self._get_song_link(spotify_url)
            
            # Armazenar dados da música atual para o seletor de links
            self._current_nowcast_track = {
                'title': track_title,
                'artist': track_artists,
                'album': track.get('album', {}).get('name', ''),
                'spotify_url': spotify_url,
                'song_link_url': song_link_url
            }
            print(f"[NowCast DEBUG] Dados armazenados - Spotify: {bool(spotify_url)}, song.link: {bool(song_link_url)}")
            
            # SISTEMA ANTI-DUPLICATAS: Verificar se já foi postado
            if self._is_duplicate_post(self._current_nowcast_track):
                print("[NowCast DEBUG] Post duplicado detectado - cancelando envio")
                return False
            
            print("[NowCast DEBUG] Verificação anti-duplicatas passou - prosseguindo")
            
            # Detectar tema selecionado
            theme = self.get_setting("theme_selector", 0)
            external_themes = self._get_external_themes()
            # CORREÇÃO: Usar a mesma lógica de cálculo da função _generate_card
            # Apple = 0, Temas externos = 1 até len(external_themes)
            # Spotlight = 1 + len(external_themes)
            # Vinify = 2 + len(external_themes) 
            # CustomFM = 3 + len(external_themes)
            # Minimal = 4 + len(external_themes)
            spotlight_index = 1 + len(external_themes)
            vinni_index = 2 + len(external_themes)
            nowv_index = 3 + len(external_themes)
            customfm_index = 4 + len(external_themes)
            minimal_index = 5 + len(external_themes)
            
            print(f"[NowCast DEBUG] Tema selecionado: {theme}, Spotlight index: {spotlight_index}, Vinify index: {vinni_index}, Nowv index: {nowv_index}, CustomFM index: {customfm_index}, Minimal index: {minimal_index}")
            
            # Verificar se é tema Minimal
            if theme == minimal_index:
                print("[NowCast DEBUG] Tema Minimal detectado - usando função existente")
                return self._send_nowcast_minimal_via_existing_function(track, token, channel_id)
            
            # Para CustomFM e outros temas, gerar card visual
            print("[NowCast DEBUG] Gerando card visual...")
            image_path = self._generate_nowcast_visual_card(track, token, channel_id, progress_ms)
            
            if image_path:
                print(f"[NowCast DEBUG] Card gerado: {image_path}")
                # Enviar imagem via bot
                success = self._send_nowcast_image_via_bot(image_path, "")
                if success:
                    print("[NowCast DEBUG] Card enviado com sucesso")
                    # Atualizar histórico anti-duplicatas
                    self._update_post_history(self._current_nowcast_track)
                    print("[NowCast DEBUG] Histórico anti-duplicatas atualizado")
                    return True
                else:
                    print("[NowCast DEBUG] Falha ao enviar card")
                    return False
            else:
                print("[NowCast DEBUG] Falha ao gerar card")
                return False
                
        except Exception as e:
            print(f"[NowCast] Erro ao enviar card: {e}")
            return False
    
    def _send_nowcast_minimal_via_existing_function(self, track, bot_token, channel_id):
        """Envia texto do tema Minimal usando a função existente _generate_minimal_card"""
        try:
            import requests
            from java.util import ArrayList
            
            # Criar parâmetros simulados para capturar a mensagem
            class MockParams:
                def __init__(self):
                    self.message = None
                    self.entities = ArrayList()
                    self.peer = type('obj', (object,), {'id': int(channel_id)})()
                    
            mock_params = MockParams()
            
            # Salvar configurações originais para o modo NowCast
            self._nowcast_bot_token = bot_token
            self._nowcast_channel_id = channel_id
            self._nowcast_mode = True
            
            # Usar a função existente do tema Minimal
            self._generate_minimal_card(track, mock_params)
            
            # Limpar configurações temporárias
            self._nowcast_mode = False
            
            # Verificar se a mensagem foi gerada
            if not mock_params.message:
                print("[NowCast] Mensagem não foi gerada pela função Minimal")
                return False
            
            # Enviar via bot API
            url = f"https://api.telegram.org/bot{bot_token}/sendMessage"
            data = {
                'chat_id': channel_id,
                'text': mock_params.message,
                'parse_mode': 'MarkdownV2',
                'disable_web_page_preview': False
            }
            
            response = requests.post(url, data=data, timeout=30)
            
            if response.status_code == 200:
                print("[NowCast] Texto Minimal enviado com sucesso")
                try:
                    run_on_ui_thread(self._trigger_send_ripple)
                except Exception:
                    pass
                # Atualizar histórico anti-duplicatas
                self._update_post_history(self._current_nowcast_track)
                print("[NowCast DEBUG] Histórico anti-duplicatas atualizado (Minimal)")
                return True
            else:
                print(f"[NowCast] Erro ao enviar texto: {response.status_code} - {response.text}")
                return False
                
        except Exception as e:
            print(f"[NowCast] Erro ao enviar texto Minimal: {e}")
            return False
    
    def _generate_nowcast_visual_card(self, track_data, bot_token, channel_id, progress_ms=0):
        """Gera card visual do NowCast usando a mesma lógica dos comandos .now/.fm"""
        try:
            # Detectar tema selecionado
            theme = self.get_setting("theme_selector", 0)
            external_themes = self._get_external_themes()
            # CORREÇÃO: Usar a mesma lógica de cálculo da função _generate_card
            # Apple = 0, Temas externos = 1 até len(external_themes)
            # Spotlight = 1 + len(external_themes)
            # Vinify = 2 + len(external_themes) 
            # CustomFM = 3 + len(external_themes)
            # Minimal = 4 + len(external_themes)
            spotlight_index = 1 + len(external_themes)
            vinni_index = 2 + len(external_themes)
            nowv_index = 3 + len(external_themes)
            customfm_index = 4 + len(external_themes)
            minimal_index = 5 + len(external_themes)
            
            print(f"[NowCast DEBUG] Tema detectado: {theme}, Spotlight index: {spotlight_index}, Vinify index: {vinni_index}, Nowv index: {nowv_index}, CustomFM index: {customfm_index}, Minimal index: {minimal_index}")
            
            # Criar parâmetros simulados
            from java.util import ArrayList
            
            class MockParams:
                def __init__(self, channel_id):
                    self.message = ".now"
                    self.entities = ArrayList()
                    self.peer = type('obj', (object,), {'id': int(channel_id)})()
                    
            mock_params = MockParams(channel_id)
            
            # Salvar configurações originais para o modo NowCast
            self._nowcast_bot_token = bot_token
            self._nowcast_channel_id = channel_id
            self._nowcast_mode = True
            
            # Se for tema CustomFM, usar função específica
            if theme == customfm_index:
                print("[NowCast DEBUG] Usando função CustomFM específica")
                title = track_data["name"]
                artists = ", ".join([a["name"] for a in track_data["artists"]])
                album = track_data.get("album", {}).get("name", "")
                image_url = None
                if track_data.get("album", {}).get("images"):
                    image_url = track_data["album"]["images"][0]["url"]
                
                # Chamar função CustomFM diretamente
                image_path = self._get_current_track_lastfm_customfm(
                    title, artists, album, image_url, mock_params,
                    progress_dialog=None, player="Spotify", 
                    youtube_url=track_data["external_urls"]["spotify"]
                )
            else:
                # Para outros temas, usar função padrão
                print(f"[NowCast DEBUG] Usando função padrão para tema {theme}")
                image_path = self._generate_card(track_data, mock_params, progress_ms)
            
            # Limpar configurações temporárias
            self._nowcast_mode = False
            if hasattr(self, '_nowcast_caption'):
                delattr(self, '_nowcast_caption')
            
            return image_path
            
        except Exception as e:
            print(f"[NowCast] Erro ao gerar card visual: {e}")
            return None
    
    def _send_nowcast_image_via_bot(self, image_path, caption):
        """Envia imagem via API do bot para o NowCast"""
        try:
            import requests
            
            bot_token = getattr(self, '_nowcast_bot_token', None)
            channel_id = getattr(self, '_nowcast_channel_id', None)
            
            if not bot_token or not channel_id:
                print("[NowCast] Token ou Channel ID não configurados")
                return False
            
            # Usar caption do CustomFM se disponível, senão usar bot_caption
            customfm_caption = getattr(self, '_nowcast_caption', None)
            if customfm_caption:
                caption = customfm_caption
                print(f"[NowCast DEBUG] Usando caption do CustomFM: {caption}")
            else:
                # Usar bot_caption se não houver caption do CustomFM
                bot_caption = self.get_setting("bot_caption_text", "")
                if bot_caption:
                    # Processar placeholders {track}, {artist} e {album} no bot_caption
                    track_data = getattr(self, '_current_nowcast_track', None)
                    if track_data and ("{track}" in bot_caption or "{artist}" in bot_caption or "{album}" in bot_caption):
                        processed_caption = bot_caption.replace("{track}", track_data.get('title', 'Unknown Track'))
                        processed_caption = processed_caption.replace("{artist}", track_data.get('artist', 'Unknown Artist'))
                        processed_caption = processed_caption.replace("{album}", track_data.get('album', 'Unknown Album'))
                        caption = processed_caption
                    else:
                        caption = bot_caption
                    print(f"[NowCast DEBUG] Usando bot caption: {caption}")
                else:
                    print(f"[NowCast DEBUG] Usando caption padrão: {caption}")
            
            # Processar seletor de links do NowCast
            nowcast_link_option = self.get_setting("nowcast_link_option", 0)
            if nowcast_link_option > 0:  # Se não for "None"
                # Obter dados da música atual
                track_data = getattr(self, '_current_nowcast_track', None)
                if track_data:
                    link_text = ""
                    if nowcast_link_option == 1:  # Spotify
                        spotify_url = track_data.get('spotify_url', '')
                        if spotify_url:
                            link_text = f"[{tr('nowcast_link_spotify')}]({spotify_url})"
                    elif nowcast_link_option == 2:  # song.link
                        song_link_url = track_data.get('song_link_url', '')
                        if song_link_url:
                            link_text = f"[{tr('nowcast_link_platforms')}]({song_link_url})"
                        elif track_data.get('spotify_url', ''):  # Fallback para Spotify se song.link não disponível
                            link_text = f"[{tr('nowcast_link_spotify')}]({track_data.get('spotify_url', '')})"
                    
                    if link_text:
                        caption = (caption or "") + link_text
                        print(f"[NowCast DEBUG] Link adicionado à legenda: {link_text.strip()}")
            
            url = f"https://api.telegram.org/bot{bot_token}/sendPhoto"
            
            with open(image_path, 'rb') as photo:
                files = {'photo': photo}
                data = {
                    'chat_id': channel_id,
                    'caption': caption,
                    'parse_mode': 'Markdown'
                }
                
                response = requests.post(url, files=files, data=data, timeout=30)
                
                if response.status_code == 200:
                    print("[NowCast] Card visual enviado com sucesso")
                    try:
                        run_on_ui_thread(self._trigger_send_ripple)
                    except Exception:
                        pass
                    return True
                else:
                    print(f"[NowCast] Erro ao enviar: {response.status_code} - {response.text}")
                    return False
                    
        except Exception as e:
            print(f"[NowCast] Erro ao enviar via bot: {e}")
            return False
    
    def _get_statsfm_current_track(self, username):
        """Obtém dados da música atual do Stats.fm"""
        try:
            import requests
            url = f"https://api.stats.fm/api/v1/users/{username}/streams/current"
            headers = {
                "Accept": "application/json",
                "User-Agent": "NowfyPlugin/1.0"
            }
            
            resp = requests.get(url, headers=headers, timeout=5)
            if resp.status_code == 200:
                data = resp.json()
                item = data.get("item")
                if item and item.get("isPlaying"):
                    track_info = item.get("track", {})
                    artists = [artist.get("name", "") for artist in track_info.get("artists", [])]
                    album = track_info.get("albums", [{}])[0]
                    
                    return {
                        'title': track_info.get("name", ""),
                        'artist': ", ".join(artists),
                        'album': album.get("name", ""),
                        'image_url': album.get("image", ""),
                        'duration_ms': track_info.get("durationMs", 0),
                        'progress_ms': item.get("progressMs", 0)
                    }
            return None
        except Exception as e:
            log(f"[NowCast] Stats.fm error: {str(e)}")
            return None
    
    def _get_lastfm_current_track(self, username, api_key):
        """Obtém dados da música atual do Last.fm"""
        try:
            import requests
            url = "http://ws.audioscrobbler.com/2.0/"
            params = {
                'method': 'user.getrecenttracks',
                'user': username,
                'api_key': api_key,
                'format': 'json',
                'limit': 1
            }
            
            resp = requests.get(url, params=params, timeout=5)
            if resp.status_code == 200:
                data = resp.json()
                tracks = data.get('recenttracks', {}).get('track', [])
                if tracks and isinstance(tracks, list) and len(tracks) > 0:
                    track = tracks[0]
                    # Sempre considerar a música mais recente como "tocando agora"
                    # Last.fm pode não incluir @attr.nowplaying quando está scrobblando
                    # Vamos assumir que a música mais recente está tocando
                    if True:
                        artist = track.get('artist', {}).get('#text', '') if isinstance(track.get('artist'), dict) else str(track.get('artist', ''))
                        album = track.get('album', {}).get('#text', '') if isinstance(track.get('album'), dict) else str(track.get('album', ''))
                        images = track.get('image', [])
                        image_url = ''
                        if images:
                            # Prefer the largest available Last.fm image
                            size_priority = ['mega', 'extralarge', 'large']
                            size_map = {img.get('size'): img.get('#text', '') for img in images if img.get('#text')}
                            for s in size_priority:
                                if size_map.get(s):
                                    image_url = size_map[s]
                                    break
                            if not image_url:
                                # Fallback to last non-empty image URL
                                for img in reversed(images):
                                    if img.get('#text'):
                                        image_url = img.get('#text', '')
                                        break
                        
                        return {
                            'title': track.get('name', ''),
                            'artist': artist,
                            'album': album,
                            'image_url': image_url,
                            'duration_ms': 0,
                            'progress_ms': 0
                        }
            return None
        except Exception as e:
            log(f"[NowCast] Last.fm error: {str(e)}")
            return None
    
    def _get_current_track_for_nowcast(self):
        """Obtém dados da música atual para o NowCast"""
        try:
            # Tentar Stats.fm primeiro
            statsfm_username = self.get_setting("statsfm_username", "")
            if statsfm_username:
                track_data = self._get_statsfm_current_track(statsfm_username)
                if track_data:
                    track_data['source'] = 'statsfm'
                    return track_data
            
            # Tentar Last.fm
            lastfm_username = self.get_setting("lastfm_user", "")
            lastfm_api_key = self.get_setting("lastfm_api_key", "")
            if lastfm_username and lastfm_api_key:
                track_data = self._get_lastfm_current_track(lastfm_username, lastfm_api_key)
                if track_data:
                    track_data['source'] = 'lastfm'
                    return track_data
            
            # Tentar Spotify
            client_id = self.get_setting("client_id", "")
            client_secret = self.get_setting("client_secret", "")
            refresh_token = self.get_setting("refresh_token", "")
            
            if client_id and client_secret and refresh_token:
                token = self._get_access_token(show_error_bulletin=False)
                if token:
                    import requests
                    resp = requests.get(
                        "https://api.spotify.com/v1/me/player/currently-playing",
                        headers={"Authorization": f"Bearer {token}"},
                        timeout=5
                    )
                    
                    if resp.status_code == 200 and resp.content:
                        data = resp.json()
                        track = data.get("item")
                        if track and track.get("name") and track.get("artists") and data.get('is_playing'):
                            artists = [a['name'] for a in track['artists']]
                            album = track.get('album', {})
                            images = album.get('images', [])
                            image_url = images[0]['url'] if images else ''
                            
                            track_data = {
                                'title': track['name'],
                                'artist': ', '.join(artists),
                                'album': album.get('name', ''),
                                'image_url': image_url,
                                'duration_ms': track.get('duration_ms', 0),
                                'progress_ms': data.get('progress_ms', 0),
                                'source': 'spotify'
                            }
                            return track_data
            
            return None
            
        except Exception as e:
            print(f"[NowCast] Erro ao obter música atual: {e}")
            return None
        
    def _send_nowcast_test_message(self, message_text):
        """Envia mensagem de teste via bot do Telegram para o NowCast"""
        if not self.get_setting("nowcast_enabled", False):
            print("[NowCast] NowCast não está habilitado")
            return False
            
        token = self.get_setting("nowcast_bot_token", "")
        channel_id = self.get_setting("nowcast_channel_id", "")
        
        if not token or not channel_id:
            print("[NowCast] Token ou Channel ID ausente")
            return False
            
        try:
            print("[NowCast] Iniciando teste de conexão...")
            
            url = f"https://api.telegram.org/bot{token}/sendMessage"
            
            payload = {
                "chat_id": channel_id,
                "text": message_text,
                "parse_mode": "HTML",
                "disable_web_page_preview": True
            }
            
            print("[NowCast] Enviando requisição para API do Telegram...")
            print(f"[NowCast] URL: {url}")
            print(f"[NowCast] Payload: chat_id={channel_id}, text_length={len(message_text)}")
            
            import time
            start_time = time.time()
            
            # Aumentar timeout para evitar travamentos
            response = requests.post(url, data=payload, timeout=15)
            
            elapsed_time = time.time() - start_time
            print(f"[NowCast] Tempo de resposta: {elapsed_time:.2f}s")
            print(f"[NowCast] Status da resposta: {response.status_code}")
            
            if response.status_code == 200:
                data = response.json()
                if data.get("ok"):
                    print("[NowCast] Mensagem de teste enviada com sucesso")
                    return True
                else:
                    print(f"[NowCast] Erro na API: {data}")
                    return False
            else:
                print(f"[NowCast] Erro HTTP: {response.status_code}")
                return False
                
        except requests.exceptions.Timeout as e:
            print(f"[NowCast] Timeout na conexão com a API do Telegram: {e}")
            return False
        except requests.exceptions.ConnectionError as e:
            print(f"[NowCast] Erro de conexão com a API do Telegram: {e}")
            return False
        except ImportError as e:
            print(f"[NowCast] Erro ao importar requests: {e}")
            return False
        except Exception as e:
            print(f"[NowCast] Erro inesperado: {e}")
            import traceback
            print(f"[NowCast] Traceback: {traceback.format_exc()[:300]}")
            return False
    
    def _test_nowcast_connection(self):
        """Testa a conexão do NowCast"""
        print("[NowCast] Iniciando teste de conexão...")
        
        # Parar temporariamente o worker para evitar conflitos
        worker_was_running = getattr(self, '_nowcast_worker_running', False)
        if worker_was_running:
            print("[NowCast] Parando worker temporariamente para teste...")
            self._nowcast_worker_running = False
            time.sleep(1)  # Aguardar worker parar
        
        try:
            test_message = "NowCast - Powered by Nowfy"
            result = self._send_nowcast_test_message(test_message)
            
            # Restaurar worker se estava rodando
            if worker_was_running:
                print("[NowCast] Restaurando worker...")
                self._nowcast_worker_running = True
            
            return result
            
        except Exception as e:
            print(f"[NowCast] Erro no teste de conexão: {e}")
            
            # Restaurar worker se estava rodando
            if worker_was_running:
                print("[NowCast] Restaurando worker após erro...")
                self._nowcast_worker_running = True
            
            return False
    
    def _has_any_credentials(self):
        """Verifica se há credenciais configuradas - APENAS Spotify e StatsFM"""
        statsfm_username = self.get_setting("statsfm_username", "")
        client_id = self.get_setting("client_id", "")
        client_secret = self.get_setting("client_secret", "")
        refresh_token = self.get_setting("refresh_token", "")
        
        return (statsfm_username or 
                (client_id and client_secret and refresh_token))
    
    def _verify_nowcast_setup(self):
        """Verifica se o NowCast está configurado corretamente"""
        print("[DEBUG] _verify_nowcast_setup iniciado")
        
        # Verificar credenciais
        has_credentials = self._has_any_credentials()
        print(f"[DEBUG] _has_any_credentials retornou: {has_credentials}")
        print(f"[NowCast] Credenciais configuradas: {has_credentials}")
        if not has_credentials:
            print("[DEBUG] Credenciais não encontradas, retornando False")
            return False
        
        # Verificar configurações do bot
        bot_token = self.get_setting("nowcast_bot_token", "")
        channel_id = self.get_setting("nowcast_channel_id", "")
        print(f"[DEBUG] Bot token obtido: {bool(bot_token)} (length: {len(bot_token) if bot_token else 0})")
        print(f"[DEBUG] Channel ID obtido: '{channel_id}'")
        print(f"[NowCast] Bot token configurado: {bool(bot_token)}")
        print(f"[NowCast] Channel ID configurado: {bool(channel_id)}")
        
        result = bool(bot_token and channel_id)
        print(f"[DEBUG] _verify_nowcast_setup retornando: {result}")
        return result
    
    def _handle_bot_command(self, params):
        """Manipula o comando .bot - ativa NowCast e faz check imediato"""
        try:
            print("[NowCast] Comando .bot executado")
            
            # Verificar se está configurado corretamente
            if not self._verify_nowcast_setup():
                self._send_msg(params, tr('nowcast_not_configured'))
                return
            
            # Ativar o NowCast
            self.set_setting("nowcast_enabled", True)
            print("[NowCast] Switch ativado via comando .bot")
            
            # Fazer check imediato
            current_track = self._get_current_track_info()
            if current_track:
                print(f"[NowCast] Música detectada: {current_track.get('name', 'N/A')} - {current_track.get('artist', 'N/A')}")
                
                # Verificar se não é duplicata antes de enviar card
                import hashlib
                track_data = f"{current_track.get('id', '')}-{current_track.get('name', '')}-{current_track.get('artist', '')}"
                current_track_hash = hashlib.sha256(track_data.encode('utf-8')).hexdigest()[:16]
                
                # Verificar se já foi postada recentemente usando o sistema anti-duplicatas
                if not self._is_duplicate_post(current_track):
                    try:
                        self._send_nowcast_card()
                        # Atualizar histórico anti-duplicatas
                        self._update_post_history(current_track)
                        self._send_msg(params, f"{tr('nowcast_activated_card_sent')}\n🎵 {current_track.get('name', 'N/A')} - {current_track.get('artist', 'N/A')}")
                        print("[NowCast] Card enviado via comando .bot")
                    except Exception as send_error:
                        print(f"[NowCast] Erro ao enviar card via .bot: {send_error}")
                        self._send_msg(params, f"{tr('nowcast_activated_card_error')}: {send_error}")
                else:
                    self._send_msg(params, f"{tr('nowcast_activated_duplicate')}\n🎵 {current_track.get('name', 'N/A')} - {current_track.get('artist', 'N/A')}")
                    print("[NowCast] Card não enviado via .bot - música duplicada detectada")
            else:
                self._send_msg(params, tr('nowcast_activated_waiting'))
                print("[NowCast] Ativado via .bot, mas nenhuma música detectada")
            
            # Iniciar worker se não estiver rodando
            if not self._nowcast_worker_running:
                print("[NowCast] Iniciando worker via comando .bot")
                threading.Thread(target=self._nowcast_worker, daemon=True).start()
            else:
                print("[NowCast] Worker já está rodando")
                
        except Exception as e:
            print(f"[NowCast] Erro no comando .bot: {e}")
            self._send_msg(params, f"{tr('nowcast_bot_command_error')}: {e}")
    
    def _check_music_playing(self):
        """Verifica se há música tocando - Last.fm, Spotify e Stats.fm"""
        print("[NowCast DEBUG] Iniciando verificação de música...")
        try:
            # Verificar Last.fm primeiro
            lastfm_username = self.get_setting("lastfm_username", "")
            lastfm_api_key = self.get_setting("lastfm_api_key", "")
            print(f"[NowCast DEBUG] Last.fm configurado: {bool(lastfm_username and lastfm_api_key)}")
            
            if lastfm_username and lastfm_api_key:
                url = "https://ws.audioscrobbler.com/2.0/"
                params = {
                    'method': 'user.getrecenttracks',
                    'user': lastfm_username,
                    'api_key': lastfm_api_key,
                    'format': 'json',
                    'limit': 1
                }
                response = requests.get(url, params=params, timeout=10)
                print(f"[NowCast DEBUG] Last.fm response: {response.status_code}")
                
                if response.status_code == 200:
                    data = response.json()
                    tracks = data.get('recenttracks', {}).get('track', [])
                    if tracks and isinstance(tracks, list) and len(tracks) > 0:
                        track = tracks[0]
                        # Verificar atributo nowplaying
                        is_now_playing = track.get('@attr', {}).get('nowplaying') == 'true'
                        if is_now_playing:
                            print("[NowCast DEBUG] Música detectada no Last.fm")
                            return True

            # Verificar Stats.fm
            statsfm_username = self.get_setting("statsfm_username", "")
            print(f"[NowCast DEBUG] Stats.fm username: {bool(statsfm_username)}")
            if statsfm_username:
                response = requests.get(f"https://api.stats.fm/api/v1/users/{statsfm_username}/streams/current", timeout=10)
                print(f"[NowCast DEBUG] Stats.fm response: {response.status_code}")
                if response.status_code == 200:
                    data = response.json()
                    if data.get("item"):
                        print("[NowCast DEBUG] Música detectada no Stats.fm")
                        return True
            
            # Verificar Spotify API
            access_token = self._get_access_token(show_error_bulletin=False)
            print(f"[NowCast DEBUG] Spotify access token: {bool(access_token)}")
            if access_token:
                headers = {"Authorization": f"Bearer {access_token}"}
                response = requests.get("https://api.spotify.com/v1/me/player/currently-playing", headers=headers, timeout=10)
                print(f"[NowCast DEBUG] Spotify response: {response.status_code}, has content: {bool(response.text)}")
                if response.status_code == 200 and response.text:
                    data = response.json()
                    is_playing = data.get("is_playing")
                    print(f"[NowCast DEBUG] Spotify is_playing: {is_playing}")
                    if is_playing:
                        print("[NowCast DEBUG] Música detectada no Spotify")
                        return True
            
            print("[NowCast DEBUG] Nenhuma música detectada")
            return False
        except Exception as e:
            print(f"[NowCast DEBUG] Erro na verificação: {e}")
            print(f"[NowCast] {NOWCAST_MESSAGES['error_check_music'].format(e)}")
            return False
    
    def _sanitize_track_title(self, title: str) -> str:
        """Remove conteúdo entre parênteses e qualquer sufixo de 'feat./ft./featuring'."""
        try:
            import re
            t = str(title or "")
            # Remover conteúdo entre parênteses, múltiplas ocorrências
            t = re.sub(r"\([^\)]*\)", "", t)
            # Remover sufixos de feat/ft/featuring e tudo depois disso
            t = re.sub(r"\b(feat(?:uring)?|ft)\b\.?\s*.*$", "", t, flags=re.IGNORECASE)
            # Limpar separadores residuais no fim
            t = re.sub(r"[\-–|•\/]+\s*$", "", t)
            # Normalizar espaços
            t = re.sub(r"\s+", " ", t).strip()
            return t
        except Exception:
            return str(title or "")

    def _get_current_track_info(self):
        """Obtém informações da música atual e tenta extrair URL da capa.
        Ordem de checagem: Stats.fm → Spotify → Last.fm.
        Retorna dict com chaves: id, name/title, artist, source, unique_key e cover_url (se encontrado).
        """
        try:
            # 1) Stats.fm (não requer token aqui, apenas username)
            try:
                statsfm_username = str(self.get_setting("statsfm_username", "")).strip()
            except Exception:
                statsfm_username = ""
            if statsfm_username:
                try:
                    resp = requests.get(
                        f"https://api.stats.fm/api/v1/users/{statsfm_username}/streams/current",
                        timeout=6,
                        headers={"Accept": "application/json", "User-Agent": "Nowfy/1.0"}
                    )
                    if resp.status_code == 200 and resp.content:
                        data = resp.json()
                        item = data.get("item") if isinstance(data, dict) else None
                        # Alguns retornos usam isPlaying; outros podem omitir
                        is_playing = bool(item.get("isPlaying", True)) if isinstance(item, dict) else False
                        if item and is_playing:
                            track = item.get("track", {})
                            name = track.get("name", "") or track.get("title", "")
                            # Artistas pode ser lista de objetos
                            artists_raw = track.get("artists", []) or []
                            artists = []
                            try:
                                artists = [a.get("name", "") for a in artists_raw]
                            except Exception:
                                artists = []
                            artist = ", ".join([s for s in artists if s][:2])
                            tid = track.get("id", "")

                            # Extrair possíveis URLs de capa em diferentes formatos do Stats.fm
                            cover_url = None
                            try:
                                album = track.get("album", {}) if isinstance(track, dict) else {}
                                # Tentativas comuns: album.images[], album.cover, album.cover.url
                                images = album.get("images", []) if isinstance(album, dict) else []
                                if isinstance(images, list) and images:
                                    # Escolhe a maior ou a primeira
                                    try:
                                        # Muitas APIs usam dict com width; pegar a de maior width
                                        best = sorted([img for img in images if isinstance(img, dict) and img.get("url")], key=lambda x: int(x.get("width", 0)), reverse=True)
                                        cover_url = (best[0].get("url") if best else None) or images[0].get("url")
                                    except Exception:
                                        cover_url = images[0].get("url")
                                if not cover_url:
                                    cov = album.get("cover")
                                    if isinstance(cov, dict):
                                        cover_url = cov.get("url") or cov.get("source")
                                    elif isinstance(cov, str):
                                        cover_url = cov
                                if not cover_url:
                                    # Alguns retornos trazem em track.images
                                    timgs = track.get("images", [])
                                    if isinstance(timgs, list) and timgs:
                                        cover_url = timgs[0].get("url") if isinstance(timgs[0], dict) else None
                            except Exception:
                                cover_url = None

                            info = {
                                "id": tid,
                                "name": name,
                                "artist": artist,
                                "source": "statsfm",
                                "unique_key": f"statsfm_{tid}_{name}_{artist}"
                            }
                            if cover_url:
                                info["cover_url"] = cover_url
                            return info
                except Exception:
                    pass

            # 2) Spotify (usa token via _get_access_token)
            try:
                access_token = self._get_access_token(show_error_bulletin=False)
            except Exception:
                access_token = None
            if access_token:
                try:
                    headers = {"Authorization": f"Bearer {access_token}"}
                    resp = requests.get(
                        "https://api.spotify.com/v1/me/player/currently-playing",
                        headers=headers,
                        timeout=6
                    )
                    if resp.status_code == 200 and resp.text:
                        data = resp.json()
                        if bool(data.get("is_playing", False)):
                            item = data.get("item", {})
                            name = item.get("name", "")
                            artists = ", ".join([a.get("name", "") for a in item.get("artists", [])])
                            tid = item.get("id", "")
                            # Extrair capa do álbum
                            cover_url = None
                            try:
                                album = item.get("album", {})
                                images = album.get("images", [])
                                if isinstance(images, list) and images:
                                    # Padrão Spotify: lista decrescente de tamanhos; pegar a primeira (maior)
                                    cover_url = (images[0] or {}).get("url") or None
                            except Exception:
                                cover_url = None
                            info = {
                                "id": tid,
                                "name": name,
                                "artist": artists,
                                "source": "spotify",
                                "unique_key": f"spotify_{tid}_{name}_{artists}"
                            }
                            if cover_url:
                                info["cover_url"] = cover_url
                            return info
                except Exception:
                    pass

                # Fallback: /v1/me/player (às vezes mais estável)
                try:
                    headers = {"Authorization": f"Bearer {access_token}"}
                    resp2 = requests.get(
                        "https://api.spotify.com/v1/me/player",
                        headers=headers,
                        timeout=6
                    )
                    if resp2.status_code == 200 and resp2.text:
                        data2 = resp2.json()
                        item2 = data2.get("item", {})
                        if item2:
                            name2 = item2.get("name", "")
                            artists2 = ", ".join([a.get("name", "") for a in item2.get("artists", [])])
                            tid2 = item2.get("id", "")
                            cover_url2 = None
                            try:
                                album2 = item2.get("album", {})
                                images2 = album2.get("images", [])
                                if isinstance(images2, list) and images2:
                                    cover_url2 = (images2[0] or {}).get("url") or None
                            except Exception:
                                cover_url2 = None
                            info2 = {
                                "id": tid2,
                                "name": name2,
                                "artist": artists2,
                                "source": "spotify",
                                "unique_key": f"spotify_{tid2}_{name2}_{artists2}"
                            }
                            if cover_url2:
                                info2["cover_url"] = cover_url2
                            return info2
                except Exception:
                    pass

            # 3) Last.fm (requer username e api_key)
            try:
                last_user = str(self.get_setting("lastfm_username", "")).strip()
                last_key = str(self.get_setting("lastfm_api_key", "")).strip()
            except Exception:
                last_user, last_key = "", ""
            if last_user and last_key:
                try:
                    url = (
                        "https://ws.audioscrobbler.com/2.0/?method=user.getrecenttracks"
                        f"&user={last_user}&api_key={last_key}&format=json&limit=1"
                    )
                    resp = requests.get(
                        url,
                        timeout=6,
                        headers={"Accept": "application/json", "User-Agent": "Nowfy/1.0"}
                    )
                    if resp.status_code == 200 and resp.content:
                        js = resp.json()
                        recent = js.get("recenttracks", {})
                        tracks = recent.get("track", [])
                        item = None
                        if isinstance(tracks, list):
                            item = tracks[0] if tracks else None
                        elif isinstance(tracks, dict):
                            item = tracks
                        if item:
                            attrs = item.get("@attr", {})
                            is_playing = bool(attrs.get("nowplaying", False))
                            if is_playing:
                                name = str(item.get("name", ""))
                                artist_obj = item.get("artist", {})
                                artist_name = ""
                                try:
                                    artist_name = str(artist_obj.get("#text", "")) or str(artist_obj.get("name", ""))
                                except Exception:
                                    artist_name = ""
                                artist = artist_name
                                # Extrair a melhor imagem disponível
                                cover_url = None
                                try:
                                    images = item.get("image", [])
                                    # Preferir 'mega' ou 'extralarge'; senão usar último com #text
                                    if isinstance(images, list) and images:
                                        size_order = {"mega": 4, "extralarge": 3, "large": 2, "medium": 1, "small": 0}
                                        best = sorted(
                                            [i for i in images if isinstance(i, dict) and i.get("#text")],
                                            key=lambda x: size_order.get(x.get("size", ""), -1),
                                            reverse=True
                                        )
                                        cover_url = (best[0].get("#text") if best else None) or images[-1].get("#text")
                                except Exception:
                                    cover_url = None
                                # Fallback: usar thumbnail do YouTube quando a imagem do Last.fm for vazia/placeholder e "Show Cover" estiver ativo
                                try:
                                    if self.get_setting("chat_list_show_cover", False):
                                        if self._is_lastfm_placeholder_image(cover_url):
                                            yt_thumb = self._get_youtube_thumbnail_forced(self._sanitize_track_title(name), artist)
                                            if yt_thumb:
                                                cover_url = yt_thumb
                                except Exception:
                                    pass
                                info = {
                                    "id": f"{name}-{artist}",
                                    "name": name,
                                    "artist": artist,
                                    "source": "lastfm",
                                    "unique_key": f"lastfm_{name}_{artist}"
                                }
                                if cover_url:
                                    info["cover_url"] = cover_url
                                return info
                except Exception:
                    pass

            return None
        except Exception as e:
            print(f"[NowCast] Erro ao obter info da música: {e}")
            return None
    
    # --- Chat List Integration ---
    def _set_chat_list_title(self, title: str):
        try:
            fragment = get_last_fragment()
            if fragment and "DialogsActivity" in fragment.getClass().getName():
                action_bar = fragment.getActionBar()
                if action_bar:
                    run_on_ui_thread(lambda: action_bar.setTitle(title))
        except Exception as e:
            try:
                if not bool(self.get_setting("disable_logs", False)):
                    log(f"[Nowfy] Error setting chat list title: {e}")
            except Exception:
                pass

    def _restore_chat_list_title(self):
        try:
            # Parar marquee antes de restaurar
            try:
                self._stop_chat_list_marquee()
            except Exception:
                pass
            orig = self.get_setting("_chat_list_original_title", "")
            if not orig:
                orig = tr("chat_list_default_title") if "chat_list_default_title" in TRANSLATIONS else "Chats"
            self._set_chat_list_title(orig)
        except Exception as e:
            try:
                if not bool(self.get_setting("disable_logs", False)):
                    log(f"[Nowfy] Error restoring chat list title: {e}")
            except Exception:
                pass

    def _apply_or_restore_chat_list_banner_on_toggle(self, enabled: bool):
        try:
            if bool(enabled):
                self._apply_chat_list_cover_banner()
            else:
                self._restore_chat_list_banner()
        except Exception:
            pass

    def _apply_chat_list_cover_banner(self):
        try:
            # Método de banner para a Chat List (Beta)
            # Créditos: lógica inspirada em CustomBanner de @RnPlugins - @PluginIDE
            # Melhorias aplicadas com corte inteligente similar ao Floatify (ilha), priorizando a parte superior da capa.
            # Verificações básicas
            if not self.get_setting("chat_list_integration", False):
                return
            if not self.get_setting("chat_list_show_cover", False):
                return
            fragment = get_last_fragment()
            if not fragment or "DialogsActivity" not in fragment.getClass().getName():
                return
            action_bar = fragment.getActionBar()
            if not action_bar:
                return

            # Capturar fundo original e cor apenas uma vez
            try:
                if not hasattr(self, "_chat_list_original_actionbar_drawable") or self._chat_list_original_actionbar_drawable is None:
                    self._chat_list_original_actionbar_drawable = action_bar.getBackground()
            except Exception:
                pass
            try:
                if not hasattr(self, "_chat_list_original_actionbar_color") or self._chat_list_original_actionbar_color is None:
                    try:
                        from org.telegram.ui.ActionBar import Theme
                        self._chat_list_original_actionbar_color = Theme.getColor(Theme.key_actionBarDefault)
                    except Exception:
                        from android.graphics import Color
                        self._chat_list_original_actionbar_color = getattr(Color, "TRANSPARENT", 0)
            except Exception:
                pass

            # Obter URL da capa mais recente
            image_url = None
            try:
                image_url = getattr(self, "_di_last_cover_url", None)
            except Exception:
                image_url = None
            if not image_url:
                return

            # Baixar a imagem via cache otimizado
            data = None
            try:
                data = self._get_cached_image_enhanced(image_url, cache_key=f"chatlist_banner_{hash(image_url)}")
            except Exception:
                data = None
            if not data:
                return

            # Decodificar para Bitmap
            bmp = None
            try:
                BitmapFactory = find_class("android.graphics.BitmapFactory")
                if BitmapFactory is not None:
                    bmp = BitmapFactory.decodeByteArray(data, 0, len(data))
            except Exception:
                bmp = None
            if not bmp:
                return
            # Guardar bitmap para animação dinâmica, se necessário
            try:
                self._chat_list_banner_bmp = bmp
            except Exception:
                pass

            # Top-biased crop para o tamanho do ActionBar (foco no topo da capa)
            try:
                ab_w = int(action_bar.getWidth())
                ab_h = int(action_bar.getHeight())
            except Exception:
                ab_w, ab_h = 0, 0

            cropped_drawable = None
            try:
                Bitmap = find_class("android.graphics.Bitmap")
                Canvas = find_class("android.graphics.Canvas")
                Paint = find_class("android.graphics.Paint")
                Matrix = find_class("android.graphics.Matrix")
                if bmp and Bitmap and Canvas and Paint and Matrix and ab_w > 0 and ab_h > 0:
                    ARGB_8888 = getattr(getattr(Bitmap, "Config", None), "ARGB_8888", None)
                    target_bitmap = Bitmap.createBitmap(ab_w, ab_h, ARGB_8888 or bmp.getConfig())
                    canvas = Canvas(target_bitmap)
                    paint = Paint()
                    try:
                        paint.setFilterBitmap(True)
                        paint.setAntiAlias(True)
                    except Exception:
                        pass
                    bw = int(bmp.getWidth())
                    bh = int(bmp.getHeight())
                    sx = float(ab_w) / float(bw) if bw > 0 else 1.0
                    sy = float(ab_h) / float(bh) if bh > 0 else 1.0
                    # Escala máxima para garantir que a imagem cubra toda a área
                    s = sx if sx > sy else sy
                    scaled_bw = float(bw) * s
                    scaled_bh = float(bh) * s

                    # Centralizar horizontalmente
                    dx = (float(ab_w) - scaled_bw) / 2.0

                    # Viés para o topo: usa uma porcentagem do excesso vertical para focar a parte superior
                    top_bias_ratio = 0.18  # ~18% do excesso vertical
                    excess_h = scaled_bh - float(ab_h)
                    if excess_h > 0:
                        dy = -(excess_h * top_bias_ratio)
                    else:
                        dy = (float(ab_h) - scaled_bh) / 2.0
                    matrix = Matrix()
                    matrix.setScale(s, s)
                    matrix.postTranslate(dx, dy)
                    try:
                        canvas.drawBitmap(bmp, matrix, paint)
                    except Exception:
                        pass
                    BitmapDrawable = find_class("android.graphics.drawable.BitmapDrawable")
                    Gravity = find_class("android.view.Gravity")
                    parent_activity = fragment.getParentActivity()
                    if BitmapDrawable and parent_activity:
                        resources = parent_activity.getResources()
                        cropped_drawable = BitmapDrawable(resources, target_bitmap)
                        try:
                            if Gravity and hasattr(cropped_drawable, "setGravity"):
                                cropped_drawable.setGravity(getattr(Gravity, "FILL", None) or 119)
                        except Exception:
                            pass
            except Exception:
                cropped_drawable = None

            # Fallback simples: usar BitmapDrawable direto
            if not cropped_drawable:
                try:
                    BitmapDrawable = find_class("android.graphics.drawable.BitmapDrawable")
                    Gravity = find_class("android.view.Gravity")
                    parent_activity = fragment.getParentActivity()
                    if BitmapDrawable and parent_activity:
                        resources = parent_activity.getResources()
                        cropped_drawable = BitmapDrawable(resources, bmp)
                        try:
                            if Gravity and hasattr(cropped_drawable, "setGravity"):
                                cropped_drawable.setGravity(getattr(Gravity, "FILL", None) or 119)
                        except Exception:
                            pass
                except Exception:
                    cropped_drawable = None
            if not cropped_drawable:
                return

            # Adicionar scrim e gradiente de topo para integração visual
            try:
                Color = find_class("android.graphics.Color")
                GradientDrawable = find_class("android.graphics.drawable.GradientDrawable")
                ColorDrawable = find_class("android.graphics.drawable.ColorDrawable")
                LayerDrawable = find_class("android.graphics.drawable.LayerDrawable")

                scrim_color = 0x33000000  # ~20% preto (com leve sombra)
                scrim_drawable = ColorDrawable(scrim_color) if ColorDrawable else None

                gradient = None
                try:
                    if GradientDrawable and Color:
                        colors = [
                            getattr(Color, "TRANSPARENT", 0),
                            int(getattr(self, "_chat_list_original_actionbar_color", 0) or 0)
                        ]
                        orientation = None
                        try:
                            orientation = getattr(getattr(GradientDrawable, "Orientation", None), "TOP_BOTTOM", None)
                        except Exception:
                            orientation = None
                        gradient = GradientDrawable(orientation, colors)
                except Exception:
                    gradient = None

                # Construir camada final
                try:
                    layers = [cropped_drawable]
                    if scrim_drawable:
                        layers.append(scrim_drawable)
                    if gradient:
                        layers.append(gradient)
                    if LayerDrawable:
                        custom_drawable = LayerDrawable(layers)
                    else:
                        custom_drawable = cropped_drawable
                except Exception:
                    custom_drawable = cropped_drawable

                def apply_background_task():
                    try:
                        # Tornar o fundo transparente e aplicar drawable composto
                        try:
                            if Color and hasattr(Color, "TRANSPARENT"):
                                action_bar.setBackgroundColor(Color.TRANSPARENT)
                        except Exception:
                            pass
                        action_bar.setBackgroundDrawable(custom_drawable)
                    except Exception:
                        pass

                run_on_ui_thread(apply_background_task, delay=50)
            except Exception:
                pass

        except Exception as e:
            try:
                if not bool(self.get_setting("disable_logs", False)):
                    log(f"[Nowfy] Error applying chat list banner: {e}")
            except Exception:
                pass

        # Iniciar animação de capa caso o modo seja animado (apenas Moving)
        try:
            mode = int(self.get_setting("chat_list_cover_animation_selector", 0))
            if mode > 0 and self.get_setting("chat_list_show_cover", False) and self.get_setting("chat_list_integration", False):
                self._start_chat_list_cover_animation()
            else:
                self._stop_chat_list_cover_animation()
        except Exception:
            pass


    def _restore_chat_list_banner(self):
        try:
            # Parar animação ao restaurar
            try:
                self._stop_chat_list_cover_animation()
            except Exception:
                pass
            fragment = get_last_fragment()
            if not fragment or "DialogsActivity" not in fragment.getClass().getName():
                return
            action_bar = fragment.getActionBar()
            if not action_bar:
                return
            orig_drawable = getattr(self, "_chat_list_original_actionbar_drawable", None)
            orig_color = getattr(self, "_chat_list_original_actionbar_color", None)
            def restore():
                try:
                    if orig_drawable:
                        action_bar.setBackgroundDrawable(orig_drawable)
                    if orig_color is not None:
                        action_bar.setBackgroundColor(orig_color)
                    else:
                        try:
                            from org.telegram.ui.ActionBar import Theme
                            action_bar.setBackgroundColor(Theme.getColor(Theme.key_actionBarDefault))
                        except Exception:
                            pass
                except Exception:
                    pass
            run_on_ui_thread(restore)
        except Exception as e:
            try:
                if not bool(self.get_setting("disable_logs", False)):
                    log(f"[Nowfy] Error restoring chat list banner: {e}")
            except Exception:
                pass

    def _start_chat_list_cover_animation(self):
        try:
            # Verificações básicas
            if not self.get_setting("chat_list_integration", False):
                return
            if not self.get_setting("chat_list_show_cover", False):
                return
            # Apenas inicia se um modo animado estiver selecionado (> 0)
            if int(self.get_setting("chat_list_cover_animation_selector", 0)) <= 0:
                return

            fragment = get_last_fragment()
            if not fragment or "DialogsActivity" not in fragment.getClass().getName():
                return
            action_bar = fragment.getActionBar()
            if not action_bar:
                return
            bmp = getattr(self, "_chat_list_banner_bmp", None)

            import threading, time, math, random

            # Se já existe um thread de animação ativo, não reiniciar; manter contínuo
            existing_t = getattr(self, "_chat_list_cover_anim_thread", None)
            if existing_t and hasattr(existing_t, "is_alive") and existing_t.is_alive():
                return

            stop_event = threading.Event()
            self._chat_list_cover_anim_stop = stop_event

            # Parâmetros base para modos
            # Moving (vertical bias)
            top_ratio = 0.22
            center_ratio = 0.10
            mid = (top_ratio + center_ratio) / 2.0
            amp = (top_ratio - center_ratio) / 2.0
            speed_mode = int(self.get_setting("chat_list_cover_anim_speed", 1))
            if speed_mode == 0:
                period_move = 8.0  # Slow
            elif speed_mode == 2:
                period_move = 3.0  # Fast
            else:
                period_move = 6.0  # Normal
            omega_move = 2.0 * math.pi / max(period_move, 0.1)
            # Modos adicionais removidos (ZoomInOut, Random Smooth)

            def _apply_frame(top_bias_ratio: float):
                try:
                    if not bmp:
                        return
                    # Recalcular dimensões
                    try:
                        ab_w = int(action_bar.getWidth())
                        ab_h = int(action_bar.getHeight())
                    except Exception:
                        ab_w, ab_h = 0, 0
                    if ab_w <= 0 or ab_h <= 0:
                        return
                    Bitmap = find_class("android.graphics.Bitmap")
                    Canvas = find_class("android.graphics.Canvas")
                    Paint = find_class("android.graphics.Paint")
                    Matrix = find_class("android.graphics.Matrix")
                    BitmapDrawable = find_class("android.graphics.drawable.BitmapDrawable")
                    LayerDrawable = find_class("android.graphics.drawable.LayerDrawable")
                    ColorDrawable = find_class("android.graphics.drawable.ColorDrawable")
                    GradientDrawable = find_class("android.graphics.drawable.GradientDrawable")
                    Color = find_class("android.graphics.Color")
                    Gravity = find_class("android.view.Gravity")
                    parent_activity = fragment.getParentActivity()
                    if not (Bitmap and Canvas and Paint and Matrix and BitmapDrawable and parent_activity):
                        return
                    ARGB_8888 = getattr(getattr(Bitmap, "Config", None), "ARGB_8888", None)
                    target_bitmap = Bitmap.createBitmap(ab_w, ab_h, ARGB_8888 or bmp.getConfig())
                    canvas = Canvas(target_bitmap)
                    paint = Paint()
                    try:
                        paint.setFilterBitmap(True)
                        paint.setAntiAlias(True)
                    except Exception:
                        pass
                    bw = int(bmp.getWidth())
                    bh = int(bmp.getHeight())
                    sx = float(ab_w) / float(bw) if bw > 0 else 1.0
                    sy = float(ab_h) / float(bh) if bh > 0 else 1.0
                    s = sx if sx > sy else sy
                    scaled_bw = float(bw) * s
                    scaled_bh = float(bh) * s
                    dx = (float(ab_w) - scaled_bw) / 2.0
                    excess_h = scaled_bh - float(ab_h)
                    if excess_h > 0:
                        dy = -(excess_h * float(top_bias_ratio))
                    else:
                        dy = (float(ab_h) - scaled_bh) / 2.0
                    matrix = Matrix()
                    matrix.setScale(s, s)
                    matrix.postTranslate(dx, dy)
                    try:
                        canvas.drawBitmap(bmp, matrix, paint)
                    except Exception:
                        pass
                    resources = parent_activity.getResources()
                    cropped_drawable = BitmapDrawable(resources, target_bitmap)
                    try:
                        if Gravity and hasattr(cropped_drawable, "setGravity"):
                            cropped_drawable.setGravity(getattr(Gravity, "FILL", None) or 119)
                    except Exception:
                        pass
                    # Camadas: imagem + scrim + gradiente
                    try:
                        scrim_color = 0x33000000
                        scrim_drawable = ColorDrawable(scrim_color) if ColorDrawable else None
                    except Exception:
                        scrim_drawable = None
                    gradient = None
                    try:
                        if GradientDrawable and Color:
                            colors = [getattr(Color, "TRANSPARENT", 0), int(getattr(self, "_chat_list_original_actionbar_color", 0) or 0)]
                            orientation = getattr(getattr(GradientDrawable, "Orientation", None), "TOP_BOTTOM", None)
                            gradient = GradientDrawable(orientation, colors)
                    except Exception:
                        gradient = None
                    try:
                        layers = [cropped_drawable]
                        if scrim_drawable:
                            layers.append(scrim_drawable)
                        if gradient:
                            layers.append(gradient)
                        custom_drawable = LayerDrawable(layers) if LayerDrawable else cropped_drawable
                    except Exception:
                        custom_drawable = cropped_drawable
                    def apply_bg():
                        try:
                            action_bar.setBackgroundDrawable(custom_drawable)
                        except Exception:
                            pass
                    run_on_ui_thread(apply_bg)
                except Exception:
                    pass

            # _apply_frame_zoom e _apply_frame_random removidos (não usados)

            t0 = time.time()
            last_url_checked_at = 0.0
            last_bmp_url = None
            try:
                last_bmp_url = getattr(self, "_di_last_cover_url", None)
            except Exception:
                last_bmp_url = None

            def _run():
                try:
                    nonlocal bmp
                    nonlocal last_url_checked_at, last_bmp_url
                    while not stop_event.is_set():
                        # Atualizar bitmap se a URL da capa mudar (p.ex., ao trocar de música)
                        try:
                            now = time.time()
                            if now - last_url_checked_at >= 1.0:
                                last_url_checked_at = now
                                current_url = None
                                try:
                                    current_url = getattr(self, "_di_last_cover_url", None)
                                except Exception:
                                    current_url = None
                                if current_url and current_url != last_bmp_url:
                                    try:
                                        data = self._get_cached_image_enhanced(current_url, cache_key=f"chatlist_banner_{hash(current_url)}")
                                    except Exception:
                                        data = None
                                    if data:
                                        try:
                                            BitmapFactory = find_class("android.graphics.BitmapFactory")
                                            if BitmapFactory is not None:
                                                new_bmp = BitmapFactory.decodeByteArray(data, 0, len(data))
                                                if new_bmp:
                                                    bmp = new_bmp
                                                    self._chat_list_banner_bmp = new_bmp
                                                    last_bmp_url = current_url
                                        except Exception:
                                            pass
                        except Exception:
                            pass
                        # Selecionar modo atual e aplicar frame
                        t_now = time.time() - t0
                        current_mode = int(self.get_setting("chat_list_cover_animation_selector", 0))
                        if current_mode == 1:
                            # Moving: posição vertical suave
                            top_bias = mid + amp * math.sin(omega_move * t_now)
                            _apply_frame(top_bias)
                        else:
                            # Default: sem animação
                            stop_event.set()
                            break
                        # Intervalo para fluidez e baixo custo (~30 FPS)
                        time.sleep(0.033)
                except Exception:
                    pass

            t = threading.Thread(target=_run, name="NowfyChatListCoverAnim", daemon=True)
            self._chat_list_cover_anim_thread = t
            try:
                t.start()
            except Exception:
                pass
        except Exception:
            pass

    def _stop_chat_list_cover_animation(self):
        try:
            ev = getattr(self, "_chat_list_cover_anim_stop", None)
            if ev:
                try:
                    ev.set()
                except Exception:
                    pass
            self._chat_list_cover_anim_stop = None
            self._chat_list_cover_anim_thread = None
        except Exception:
            pass

    def _get_chat_list_title_view(self):
        try:
            fragment = get_last_fragment()
            if fragment and "DialogsActivity" in fragment.getClass().getName():
                action_bar = fragment.getActionBar()
                if action_bar:
                    try:
                        return action_bar.getTitleTextView()
                    except Exception:
                        return None
            return None
        except Exception:
            return None

    # Logs de Chat List obedecendo Disable logs
    def _chat_list_log(self, message: str):
        try:
            if not bool(self.get_setting("disable_logs", False)):
                log(str(message))
        except Exception:
            pass

    # Força atualizar o banner da Chat List ao reabrir o app, se estiver tocando
    def _force_update_chat_list_banner_if_playing_on_resume(self):
        try:
            if not self.get_setting("chat_list_integration", False):
                return
            if not self.get_setting("chat_list_show_cover", False):
                return

            import threading, time

            def worker():
                try:
                    deadline = time.time() + 15.0
                    applied = False
                    while time.time() < deadline and not applied:
                        # Verificação silenciosa se há música (retorna dict caso sim)
                        info = None
                        try:
                            info = self._get_current_track_info()
                        except Exception:
                            info = None
                        if info:
                            try:
                                self._apply_chat_list_cover_banner()
                                applied = True
                                # Se Moving estiver selecionado, garantir que a animação comece
                                try:
                                    if int(self.get_setting("chat_list_cover_animation_selector", 0)) > 0:
                                        self._stop_chat_list_cover_animation()
                                        # pequeno atraso para garantir medidas do ActionBar
                                        time.sleep(0.2)
                                        self._start_chat_list_cover_animation()
                                except Exception:
                                    pass
                            except Exception:
                                pass
                        if applied:
                            break
                        time.sleep(0.5)
                except Exception:
                    pass

            threading.Thread(target=worker, name="NowfyChatListResumeApply", daemon=True).start()
        except Exception:
            pass

    def _set_chat_list_status(self, status_key: str):
        try:
            if not self.get_setting("chat_list_integration", False):
                return
            try:
                self._stop_chat_list_marquee()
            except Exception:
                pass
            try:
                status = tr(status_key) if status_key in TRANSLATIONS else status_key
            except Exception:
                status = status_key
            self._set_chat_list_title(status)
            # Não limpar _chat_list_last_display aqui, para permitir reaplicar marquee após o status
        except Exception:
            pass

    def _trigger_chat_list_refresh(self):
        try:
            if not self.get_setting("chat_list_integration", False):
                return
            info = None
            try:
                info = self._get_spotify_current_track_simple()
            except Exception:
                info = None
            if not info:
                try:
                    info = self._get_current_track_info()
                except Exception:
                    info = None
            if info:
                self._update_chat_list_title_from_track(info)
            else:
                try:
                    last = self.get_setting("_chat_list_last_display", "")
                    if last:
                        self._start_chat_list_marquee(last)
                except Exception:
                    pass
        except Exception:
            pass

    def _start_chat_list_marquee(self, base_text: str, speed_ms: int = 300, direction: int = 1):
        try:
            # Encerrar qualquer efeito anterior
            try:
                self._stop_chat_list_marquee()
            except Exception:
                pass

            want_left = True  # sempre da direita para a esquerda

            # Tentar usar marquee nativo do TextView (suave) somente para esquerda
            used_native = False
            if want_left:
                try:
                    tv = self._get_chat_list_title_view()
                    if tv:
                        def apply():
                            try:
                                from android.text import TextUtils
                            except Exception:
                                TextUtils = None
                            try:
                                tv.setSingleLine(True)
                            except Exception:
                                pass
                            try:
                                if TextUtils:
                                    tv.setEllipsize(TextUtils.TruncateAt.MARQUEE)
                            except Exception:
                                pass
                            try:
                                tv.setMarqueeRepeatLimit(-1)
                            except Exception:
                                pass
                            try:
                                tv.setHorizontallyScrolling(True)
                            except Exception:
                                pass
                            try:
                                tv.setSelected(True)
                            except Exception:
                                pass
                            try:
                                # Alguns ambientes usam setText no title view
                                tv.setText(base_text)
                            except Exception:
                                # fallback para setTitle diretamente
                                fragment = get_last_fragment()
                                if fragment:
                                    ab = fragment.getActionBar()
                                    if ab:
                                        ab.setTitle(base_text)
                        run_on_ui_thread(apply)
                        used_native = True
                except Exception:
                    used_native = False

            if used_native:
                # Marquee nativo ativo
                try:
                    self._chat_list_native_marquee = True
                except Exception:
                    pass
                return  # com marquee nativo não precisamos de thread

            # Fallback: rolagem manual (melhorada com passo menor)
            import threading, time
            self._chat_list_native_marquee = False
            self._chat_list_marquee_base = str(base_text or "")
            # diminuir intervalo para sensação mais suave (~42 FPS)
            self._chat_list_marquee_speed = int(speed_ms) if speed_ms and speed_ms > 0 else 24
            stop_event = threading.Event()
            self._chat_list_marquee_stop = stop_event
            padding = "     "  # espaçamento visual entre ciclos
            scroll = (self._chat_list_marquee_base + padding)

            def _run():
                try:
                    i = 0
                    n = len(scroll) if scroll else 0
                    if n <= 1:
                        return
                    while not stop_event.is_set():
                        try:
                            if want_left:
                                # deslocamento para a esquerda (padrão)
                                s = scroll[i:] + scroll[:i]
                            else:
                                # deslocamento para a direita
                                s = scroll[-i:] + scroll[:-i]
                            self._set_chat_list_title(s)
                        except Exception:
                            pass
                        # passos menores para suavidade
                        i = (i + 1) % n
                        time.sleep(self._chat_list_marquee_speed / 1000.0)
                except Exception:
                    pass

            t = threading.Thread(target=_run, name="NowfyChatListMarquee", daemon=True)
            self._chat_list_marquee_thread = t
            try:
                t.start()
            except Exception:
                pass
        except Exception as e:
            log(f"[Nowfy] Error starting marquee: {e}")

    def _start_chat_list_credits(self, track_info: dict, display: str):
        try:
            # Encerrar qualquer efeito anterior
            try:
                self._stop_chat_list_marquee()
            except Exception:
                pass
            import threading, time
            stop_event = threading.Event()
            self._chat_list_marquee_stop = stop_event

            prefix = tr("chat_list_now_playing_prefix") if "chat_list_now_playing_prefix" in TRANSLATIONS else "Now Playing:"
            song = track_info.get("name", "") if track_info else ""
            artist = track_info.get("artist", "") if track_info else ""
            sequence = [prefix, song or display, artist or display]

            def _fade_set(text):
                try:
                    tv = self._get_chat_list_title_view()
                    # define texto
                    self._set_chat_list_title(text)
                    if not tv:
                        time.sleep(1.6)
                        return
                    # animação: fade-in, segurar, fade-out
                    steps = 12
                    dur = 0.04
                    # iniciar transparente
                    try:
                        run_on_ui_thread(lambda: tv.setAlpha(0.0))
                    except Exception:
                        pass
                    # fade-in
                    for k in range(steps):
                        if stop_event.is_set():
                            return
                        a = (k + 1) / float(steps)
                        try:
                            run_on_ui_thread(lambda: tv.setAlpha(a))
                        except Exception:
                            pass
                        time.sleep(dur)
                    # segurar
                    hold = 1.0
                    elapsed = 0.0
                    while elapsed < hold and not stop_event.is_set():
                        time.sleep(0.04)
                        elapsed += 0.04
                    # fade-out
                    for k in range(steps):
                        if stop_event.is_set():
                            return
                        a = 1.0 - ((k + 1) / float(steps))
                        try:
                            run_on_ui_thread(lambda: tv.setAlpha(a))
                        except Exception:
                            pass
                        time.sleep(dur)
                except Exception:
                    time.sleep(1.6)

            def _run():
                try:
                    while not stop_event.is_set():
                        for txt in sequence:
                            if stop_event.is_set():
                                break
                            _fade_set(txt)
                except Exception:
                    pass

            t = threading.Thread(target=_run, name="NowfyChatListCredits", daemon=True)
            self._chat_list_marquee_thread = t
            try:
                t.start()
            except Exception:
                pass
        except Exception as e:
            log(f"[Nowfy] Error starting credits effect: {e}")


    def _stop_chat_list_marquee(self):
        try:
            ev = getattr(self, "_chat_list_marquee_stop", None)
            if ev:
                try:
                    ev.set()
                except Exception:
                    pass
            self._chat_list_marquee_stop = None
            self._chat_list_marquee_thread = None
            try:
                self._chat_list_native_marquee = False
            except Exception:
                pass
            # Desabilita configurações de marquee nativo, se possível
            try:
                tv = self._get_chat_list_title_view()
                if tv:
                    def disable():
                        try:
                            from android.text import TextUtils
                        except Exception:
                            TextUtils = None
                        try:
                            if TextUtils:
                                tv.setEllipsize(TextUtils.TruncateAt.END)
                        except Exception:
                            pass
                        try:
                            tv.setSelected(False)
                        except Exception:
                            pass
                        try:
                            tv.setHorizontallyScrolling(False)
                        except Exception:
                            pass
                        try:
                            tv.setAlpha(1.0)
                        except Exception:
                            pass
                    run_on_ui_thread(disable)
            except Exception:
                pass
        except Exception:
            pass

    def _start_chat_list_refresh_worker(self, interval_sec: int = 50):
        try:
            # Encerrar worker anterior, se houver
            try:
                self._stop_chat_list_refresh_worker()
            except Exception:
                pass
            import threading, time
            stop_event = threading.Event()
            self._chat_list_refresh_stop = stop_event

            def _run():
                try:
                    while not stop_event.is_set():
                        info = None
                        try:
                            info = self._get_spotify_current_track_simple()
                        except Exception:
                            info = None
                        if not info:
                            try:
                                info = self._get_current_track_info()
                            except Exception:
                                info = None
                        if info:
                            self._update_chat_list_title_from_track(info)
                        else:
                            try:
                                last = self.get_setting("_chat_list_last_display", "")
                                if last:
                                    self._start_chat_list_marquee(last)
                            except Exception:
                                pass
                        try:
                            total = int(interval_sec) if interval_sec and interval_sec > 0 else 50
                            for _ in range(total):
                                if stop_event.is_set():
                                    break
                                time.sleep(1)
                        except Exception:
                            time.sleep(50)
                except Exception:
                    pass

            t = threading.Thread(target=_run, name="NowfyChatListRefresh", daemon=True)
            self._chat_list_refresh_thread = t
            try:
                t.start()
            except Exception:
                pass
        except Exception:
            pass

    def _stop_chat_list_refresh_worker(self):
        try:
            ev = getattr(self, "_chat_list_refresh_stop", None)
            if ev:
                try:
                    ev.set()
                except Exception:
                    pass
            self._chat_list_refresh_stop = None
            self._chat_list_refresh_thread = None
        except Exception:
            pass

    def _get_spotify_current_track_simple(self):
        try:
            token = self._get_access_token(show_error_bulletin=False)
            if not token:
                return None
            import requests
            headers = {"Authorization": f"Bearer {token}"}
            # Primeiro tenta o endpoint currently-playing
            try:
                resp = requests.get(
                    "https://api.spotify.com/v1/me/player/currently-playing",
                    headers=headers,
                    timeout=5
                )
                if resp.status_code == 200 and resp.content:
                    data = resp.json()
                    track = data.get("item")
                    if track:
                        name = track.get("name", "")
                        artists = ", ".join([a.get("name", "") for a in track.get("artists", [])])
                        tid = track.get("id", "")
                        # Extrair capa do álbum para banner
                        cover_url = None
                        try:
                            album = track.get("album") or {}
                            images = album.get("images") or []
                            cover_url = next((img.get("url") for img in images if img and img.get("url")), None)
                        except Exception:
                            cover_url = None
                        return {"id": tid, "name": name, "artist": artists, "source": "spotify", "unique_key": f"spotify_{tid}_{name}_{artists}", "cover_url": cover_url}
            except Exception:
                pass
            # Fallback: endpoint do player (retorna item atual)
            try:
                resp2 = requests.get(
                    "https://api.spotify.com/v1/me/player",
                    headers=headers,
                    timeout=5
                )
                if resp2.status_code == 200 and resp2.text:
                    data2 = resp2.json()
                    track2 = data2.get("item")
                    if track2:
                        name2 = track2.get("name", "")
                        artists2 = ", ".join([a.get("name", "") for a in track2.get("artists", [])])
                        tid2 = track2.get("id", "")
                        cover_url2 = None
                        try:
                            album2 = track2.get("album") or {}
                            images2 = album2.get("images") or []
                            cover_url2 = next((img.get("url") for img in images2 if img and img.get("url")), None)
                        except Exception:
                            cover_url2 = None
                        return {"id": tid2, "name": name2, "artist": artists2, "source": "spotify", "unique_key": f"spotify_{tid2}_{name2}_{artists2}", "cover_url": cover_url2}
            except Exception:
                pass
            return None
        except Exception:
            return None

    def _enable_chat_list_title_tap_refresh(self):
        try:
            tv = self._get_chat_list_title_view()
            if not tv:
                return
            def _on_click(v):
                try:
                    if not self.get_setting("chat_list_integration", False):
                        return
                    self._trigger_chat_list_refresh()
                except Exception:
                    pass
            try:
                listener = OnClickListener(_on_click)
            except Exception:
                try:
                    ViewOnClickListener = find_class("android.view.View$OnClickListener")
                    class _TapRefreshListener(dynamic_proxy(ViewOnClickListener)):
                        def onClick(self, v):
                            try:
                                _on_click(v)
                            except Exception:
                                pass
                    listener = _TapRefreshListener()
                except Exception:
                    listener = None
            def apply():
                try:
                    tv.setClickable(True)
                except Exception:
                    pass
                try:
                    if listener:
                        tv.setOnClickListener(listener)
                except Exception:
                    pass
            run_on_ui_thread(apply)
        except Exception:
            pass

    def _update_chat_list_title_from_track(self, track_info: dict):
        try:
            if not track_info:
                return
            if not self.get_setting("chat_list_integration", False):
                return
            song = track_info.get("name", "") or track_info.get("title", "")
            artist = track_info.get("artist", "")
            
            # Sanitizar título usando regras do ChatList Customizer
            song = self._sanitize_track_title(song)
            
            # Atualizar última capa conhecida para o banner, se disponível
            try:
                cover_url = track_info.get("cover_url")
                if cover_url:
                    self._di_last_cover_url = cover_url
            except Exception:
                pass

            # que alterna entre música e artista
            try:
                toggle_state = getattr(self, "_np_toggle_state", 0)
                display = song if toggle_state == 0 else artist
                # Alternar estado para próxima atualização
                self._np_toggle_state = 1 if toggle_state == 0 else 0
            except Exception:
                # Fallback para display padrão em caso de erro
                display = f"{song} • {artist}" if song and artist else (song or artist)
            if display:
                prev = self.get_setting("_chat_list_last_display", "")
                if prev == display:
                    # Reaplicar último título para sair do estado de status
                    try:
                        self._start_chat_list_marquee(prev)
                    except Exception:
                        pass
                    return
                # Aplicar novo título somente quando houver mudança, sem status intermediário
                try:
                    self.set_setting("_chat_list_last_display", display)
                except Exception:
                    pass
                self._start_chat_list_marquee(display)
                # Aplicar banner quando atualizar o título, se habilitado
                try:
                    if self.get_setting("chat_list_show_cover", False):
                        self._apply_chat_list_cover_banner()
                except Exception:
                    pass
        except Exception as e:
            log(f"[Nowfy] Error updating chat list title: {e}")

    def _toggle_chat_list_integration(self, enabled: bool):
        try:
            # Persistir o estado imediatamente
            try:
                self.set_setting("chat_list_integration", bool(enabled))
            except Exception:
                pass
            # Capturar título original uma vez quando habilitar
            if enabled:
                try:
                    fragment = get_last_fragment()
                    if fragment and "DialogsActivity" in fragment.getClass().getName():
                        action_bar = fragment.getActionBar()
                        if action_bar and not self.get_setting("_chat_list_original_title"):
                            try:
                                current_title = None
                                try:
                                    current_title = str(action_bar.getTitle())
                                except Exception:
                                    current_title = None
                                if current_title:
                                    self.set_setting("_chat_list_original_title", current_title)
                            except Exception:
                                pass
                except Exception:
                    pass
                info = None
                try:
                    info = self._get_spotify_current_track_simple()
                except Exception:
                    info = None
                if not info:
                    info = self._get_current_track_info()
                if info:
                    self._update_chat_list_title_from_track(info)
                else:
                    try:
                        last = self.get_setting("_chat_list_last_display", "")
                        if last:
                            self._start_chat_list_marquee(last)
                        else:
                            self._set_chat_list_title(tr("chat_list_default_title") if "chat_list_default_title" in TRANSLATIONS else "Chats")
                    except Exception:
                        self._set_chat_list_title(tr("chat_list_default_title") if "chat_list_default_title" in TRANSLATIONS else "Chats")
                # Iniciar worker de refresh periódico (15s)
                try:
                    self._start_chat_list_refresh_worker(15)
                except Exception:
                    pass
                # Habilitar toque no título para refresh manual
                try:
                    self._enable_chat_list_title_tap_refresh()
                except Exception:
                    pass
                # Aplicar banner se o recurso estiver ativado
                try:
                    if self.get_setting("chat_list_show_cover", False):
                        self._apply_chat_list_cover_banner()
                except Exception:
                    pass
            else:
                try:
                    self._stop_chat_list_marquee()
                except Exception:
                    pass
                try:
                    self._stop_chat_list_refresh_worker()
                except Exception:
                    pass
                try:
                    self.set_setting("_chat_list_last_display", "")
                except Exception:
                    pass
                try:
                    # Restaurar banner quando desativar integração
                    self._restore_chat_list_banner()
                except Exception:
                    pass
                self._restore_chat_list_title()
        except Exception as e:
            log(f"[Nowfy] Error toggling Chat List: {e}")
    def _nowcast_worker(self):
        """Worker thread robusto para o NowCast - Sistema anti-falhas com auto-desligamento"""
        # Verificar se já existe um worker rodando
        if hasattr(self, '_nowcast_worker_running') and self._nowcast_worker_running:
            print("[NowCast] ⚠️ Worker já está rodando - ignorando nova instância")
            return
        
        # Marcar worker como ativo
        self._nowcast_worker_running = True
        
        try:
            # Usar variáveis de instância para permitir limpeza via _clear_nowcast_history
            if not hasattr(self, '_nowcast_last_track_hash'):
                self._nowcast_last_track_hash = None
            if not hasattr(self, '_nowcast_post_history'):
                self._nowcast_post_history = []
            if not hasattr(self, '_nowcast_cooldown_time'):
                self._nowcast_cooldown_time = 0
            consecutive_errors = 0
            last_successful_check = time.time()
            last_activity_time = time.time()  # Para controle de inatividade
            last_cache_clear = time.time()  # Para limpeza preventiva de cache
            posting_lock = False  # Lock para evitar posts simultâneos
            min_post_interval = 60  # Aumentado para 60 segundos
            inactivity_timeout = 600  # 10 minutos em segundos
            cache_clear_interval = 3600  # 1 hora em segundos
            print("[NowCast] 🎵 Worker iniciado - Sistema robusto ativo com auto-desligamento!")
            
            while self.get_setting("nowcast_enabled", False):
                cycle_start = time.time()
                try:
                    print(f"[NowCast DEBUG] Ciclo iniciado - Erros consecutivos: {consecutive_errors}")
                    
                    # Verificar credenciais
                    if not self._has_any_credentials():
                        print("[NowCast] ⚠️ Nenhuma credencial configurada, aguardando...")
                        time.sleep(30)
                        continue
                    
                    # Obter música atual com timeout
                    print("[NowCast DEBUG] Obtendo informações da música atual...")
                    current_track = None
                    try:
                        current_track = self._get_current_track_info()
                        print(f"[NowCast DEBUG] Música atual: {current_track or 'Nenhuma'}")
                    except Exception as track_error:
                        print(f"[NowCast] ⚠️ Erro ao obter música: {track_error}")
                        current_track = None
                    
                    current_time = time.time()
                    
                    if current_track:
                        last_successful_check = current_time
                        last_activity_time = current_time  # Atualizar tempo de atividade
                        
                        # Criar hash SHA-256 único e robusto da música atual
                        import hashlib
                        track_data = f"{current_track.get('id', '')}-{current_track.get('name', '')}-{current_track.get('artist', '')}-{current_track.get('source', '')}"
                        current_track_hash = hashlib.sha256(track_data.encode('utf-8')).hexdigest()[:16]  # Usar apenas 16 caracteres
                        
                        # Verificar se é uma música diferente usando o sistema anti-duplicatas
                        should_post = not self._is_duplicate_post(current_track)
                        if should_post:
                            print(f"[NowCast] 🎵 Nova música detectada: {current_track.get('name', 'N/A')} - {current_track.get('artist', 'N/A')}")
                            print(f"[NowCast DEBUG] Hash: {current_track_hash} (novo)")
                        else:
                            print(f"[NowCast DEBUG] Música já postada ou muito próxima: {current_track.get('name', 'N/A')} - {current_track.get('artist', 'N/A')}")
                            print(f"[NowCast DEBUG] Hash: {current_track_hash} (duplicata detectada)")
                        
                        # Atualizar título da Chat List sempre que houver música
                        try:
                            if self.get_setting("chat_list_integration", False):
                                self._update_chat_list_title_from_track(current_track)
                        except Exception:
                            pass
                        
                        # Postar apenas se for uma música nova e não houver lock
                        if should_post and not posting_lock:
                            posting_lock = True  # Ativar lock
                            print(f"[NowCast] 📤 Enviando card para nova música...")
                            try:
                                self._send_nowcast_card()
                                # Atualizar histórico usando o sistema centralizado
                                self._update_post_history(current_track)
                                consecutive_errors = 0  # Reset contador de erros
                                print(f"[NowCast] Card enviado com sucesso às {time.strftime('%H:%M:%S')}")
                                print(f"[NowCast DEBUG] Hash {current_track_hash} adicionado ao histórico ({len(self._nowcast_post_history)} total)")
                            except Exception as send_error:
                                print(f"[NowCast] Erro ao enviar card: {send_error}")
                                consecutive_errors += 1
                            finally:
                                posting_lock = False  # Liberar lock
                        elif should_post and posting_lock:
                            print("[NowCast DEBUG] Post bloqueado - já há um envio em andamento")
                    
                    else:
                        # Sem música tocando - verificar inatividade
                        time_inactive = current_time - last_activity_time
                        
                        if self._nowcast_last_track_hash:
                            print("[NowCast] ⏹️ Música parou - Resetando estado")
                            self._nowcast_last_track_hash = None
                            self._nowcast_cooldown_time = 0
                        
                        # Restaurar título padrão e parar efeitos quando Chat List ativo e sem música
                        try:
                            if self.get_setting("chat_list_integration", False):
                                # parar quaisquer efeitos e restaurar 'Chats'
                                try:
                                    self._stop_chat_list_marquee()
                                except Exception:
                                    pass
                                try:
                                    self.set_setting("_chat_list_last_display", "")
                                except Exception:
                                    pass
                                try:
                                    self._restore_chat_list_title()
                                except Exception:
                                    pass
                        except Exception:
                            pass
                        
                        # Auto-desligamento após 10 minutos de inatividade
                        if time_inactive >= inactivity_timeout:
                            print(f"[NowCast] Auto-desligamento: {time_inactive:.0f}s sem atividade (limite: {inactivity_timeout}s)")
                            self.set_setting("nowcast_enabled", False)
                            # Também desligar integração da Chat List para evitar título preso
                            try:
                                if self.get_setting("chat_list_integration", False):
                                    self.set_setting("chat_list_integration", False)
                                    self._toggle_chat_list_integration(False)
                            except Exception:
                                pass
                            try:
                                BulletinHelper.show_bulletin(
                                    "NowCast Auto-Desligado",
                                    tr('nowcast_auto_disabled')
                                )
                            except:
                                pass
                            break
                        
                        # Verificar se há muito tempo sem música (possível problema)
                        time_without_music = current_time - last_successful_check
                        if time_without_music > 300:  # 5 minutos sem música
                            print(f"[NowCast] ⚠️ Sem música há {time_without_music:.0f}s - Verificando conexões...")
                            last_successful_check = current_time  # Reset para evitar spam
                        
                        # Mostrar contagem regressiva para auto-desligamento
                        remaining_inactivity = inactivity_timeout - time_inactive
                        if remaining_inactivity <= 300:  # Últimos 5 minutos
                            print(f"[NowCast DEBUG] Auto-desligamento em {remaining_inactivity:.0f}s por inatividade")
                    
                    # Limpeza preventiva de cache a cada hora
                    time_since_cache_clear = current_time - last_cache_clear
                    if time_since_cache_clear >= cache_clear_interval:
                        print("[NowCast] 🧹 Limpeza preventiva de cache (1 hora de funcionamento)")
                        try:
                            self._clear_cache()
                            last_cache_clear = current_time
                            print("[NowCast] Cache limpo preventivamente")
                        except Exception as cache_error:
                            print(f"[NowCast] Erro na limpeza preventiva: {cache_error}")
                    
                    # Reset contador de erros em ciclo bem-sucedido
                    if current_track:  # Só resetar se detectou música
                        consecutive_errors = 0
                    
                    # Aguardar antes do próximo ciclo (aumentado para evitar posts múltiplos)
                    sleep_time = min(45 + (consecutive_errors * 15), 90)  # Min 45s, Max 90s
                    # Acelerar refresh quando a integração de Chat List está ativa
                    try:
                        if self.get_setting("chat_list_integration", False):
                            sleep_time = min(sleep_time, 10)  # até 10s para atualização mais rápida do título
                    except Exception:
                        pass
                    print(f"[NowCast DEBUG] Ciclo concluído em {time.time() - cycle_start:.1f}s - Aguardando {sleep_time}s")
                    time.sleep(sleep_time)
                
                except Exception as e:
                    consecutive_errors += 1
                    error_msg = f"[NowCast] Erro no worker (#{consecutive_errors}): {e}"
                    print(error_msg)
                    
                    # Aguardar mais tempo em caso de erros consecutivos
                    error_sleep = min(30 + (consecutive_errors * 15), 120)  # Max 2 minutos
                    print(f"[NowCast] Recuperando em {error_sleep}s...")
                    time.sleep(error_sleep)
                    
                    # Se muitos erros consecutivos, tentar reset completo com limpeza de cache
                    if consecutive_errors >= 5:
                        print("[NowCast] Muitos erros - Resetando estado completo e limpando cache...")
                        
                        # Limpeza automática de cache para resolver problemas de funcionamento
                        try:
                            self._clear_cache()
                            print("[NowCast] Cache limpo automaticamente para resolver problemas")
                        except Exception as cache_error:
                            print(f"[NowCast] Erro ao limpar cache: {cache_error}")
                        
                        last_track_posted = None
                        last_post_time = 0
                        consecutive_errors = 0
                        last_successful_check = time.time()
                        last_activity_time = time.time()
                        last_cache_clear = time.time()
                        posting_lock = False  # Reset do lock também
        
        finally:
            # Resetar flag do worker
            self._nowcast_worker_running = False
            print("[NowCast] Worker finalizado - NowCast desabilitado")

    


    def _get_song_link(self, spotify_url):
        """Gera song.link URL para o track do Spotify"""
        try:
            # song.link API para gerar link universal
            song_link_url = f"https://song.link/s/{spotify_url.split('/')[-1]}"
            return song_link_url
        except Exception as e:
            log(f"[exteraFy] Error generating song.link: {e}")
            return spotify_url
    
    def _generate_track_hash(self, track_data):
        """Gera hash único para identificar uma música"""
        try:
            if not track_data:
                return None
            
            # Criar string única baseada nos dados da música
            track_string = f"{track_data.get('title', '')}-{track_data.get('artist', '')}-{track_data.get('album', '')}"
            
            # Gerar hash MD5
            import hashlib
            return hashlib.md5(track_string.encode('utf-8')).hexdigest()
        except Exception as e:
            return None
    
    def _is_duplicate_post(self, track_data):
        """Verifica se a música já foi postada recentemente"""
        try:
            import time
            
            current_time = time.time()
            
            # Verificar intervalo mínimo entre posts
            if current_time - self._nowcast_cooldown_time < self._nowcast_min_interval:
                return True
            
            # Gerar hash da música atual
            current_hash = self._generate_track_hash(track_data)
            if not current_hash:
                return False
            
            # Verificar se é a mesma música do último post
            if current_hash == self._nowcast_last_track_hash:
                return True
            
            # Verificar histórico dos últimos posts
            if current_hash in self._nowcast_post_history:
                return True
            
            return False
        except Exception as e:
            return False
    
    def _update_post_history(self, track_data):
        """Atualiza o histórico de posts"""
        try:
            import time
            
            current_hash = self._generate_track_hash(track_data)
            if not current_hash:
                return
            
            # Atualizar último hash
            self._nowcast_last_track_hash = current_hash
            
            # Adicionar ao histórico
            self._nowcast_post_history.append(current_hash)
            
            # Manter apenas os últimos 10 posts no histórico
            if len(self._nowcast_post_history) > 10:
                self._nowcast_post_history.pop(0)
            
            # Atualizar timestamp do último post
            self._nowcast_cooldown_time = time.time()
        except Exception as e:
            pass

    # --- AUTOBIO ---
    def _capture_original_bio(self):
        """Captura a bio original do usuário na primeira execução"""
        try:
            # Verificar se já foi registrado
            if self.get_setting("original_bio_captured", False):
                return
            
            user_full = get_messages_controller().getUserFull(get_user_config().getClientUserId())
            if user_full and user_full.about:
                # Capturar a bio original (experimental)
                self.set_setting("original_bio", user_full.about)
                self.set_setting("original_bio_captured", True)
                # Definir automaticamente o restore_bio_text com a bio original se estiver vazio
                current_restore_text = self.get_setting("restore_bio_text", "").strip()
                if not current_restore_text:
                    self.set_setting("restore_bio_text", user_full.about)
                    log(f"[NowFy] Auto-set restore_bio_text to original bio: {user_full.about}")
                
                log(f"[NowFy] Original bio captured: {user_full.about}")
        except Exception as e:
            log(f"[NowFy] Error capturing original bio: {e}")

    def _update_bio(self, text, show_bulletin=False, is_restore=False):
        try:
            user_full = get_messages_controller().getUserFull(get_user_config().getClientUserId())
            max_len = 140 if get_user_config().isPremium() else 70
            # Sempre atualizar a bio (remover cache do etg)
            req = TL_account.updateProfile()
            req.flags = 4
            req.about = text[:max_len]
            send_request(req, (lambda _res: None))
            # Só mostrar bulletin se show_bulletin=True ou se for auto-refresh com notificação ativada
            if show_bulletin:
                BulletinHelper.show_success(tr("bio_restored"))
            elif self.get_setting("show_bio_notification", True) and self.get_setting("enable_auto_bio_update", True):
                # Para auto-refresh, mostrar mensagem específica baseada no contexto
                if is_restore:
                    # Não mostrar notificação para restauração automática (sem música)
                    pass
                else:
                    # Mostrar notificação apenas quando há música tocando
                    BulletinHelper.show_info(tr("bio_updated_short"))
        except Exception as e:
            log(f"[exteraFy] Error updating bio: {e}")
            if show_bulletin or self.get_setting("show_bio_notification", True):
                BulletinHelper.show_with_button(tr("bio_error"), R.raw.error, "OK", None)

    # --- CACHE ---
    def _start_cache_system(self):
        self._cache_enabled = self.get_setting("enable_cache", True)
        if self._cache_enabled and not self._cache_running:
            self._cache_running = True
            self._cache_thread = threading.Thread(target=self._cache_worker, daemon=True)
            self._cache_thread.start()
        else:
            self._cache_running = False

    def _toggle_cache_system(self, enabled):
        self._cache_enabled = enabled
        if enabled:
            self._start_cache_system()
        else:
            self._cache_running = False
            with self._cache_lock:
                self._image_cache.clear()

    def _cache_worker(self):
        while self._cache_running:
            try:
                if not self._cache_enabled:
                    time.sleep(2)
                    continue
                # Ajustar intervalo baseado no modo de performance
                performance_mode = self.get_setting("performance_mode", 1)
                sleep_interval = 2 if performance_mode == 0 else (3 if performance_mode == 1 else 4)
                
                token = self._get_access_token(show_error_bulletin=False)
                if not token:
                    time.sleep(5)
                    continue
                # Usar timeout baseado no modo de performance
                timeout = 3 if performance_mode == 0 else (5 if performance_mode == 1 else 7)
                
                resp = requests.get(
                    "https://api.spotify.com/v1/me/player/currently-playing",
                    headers={"Authorization": f"Bearer {token}"},
                    timeout=timeout
                )
                if resp.status_code == 200 and resp.content:
                    data = resp.json()
                    track = data.get("item")
                    if track:
                        track_id = track["id"]
                        if track_id != self._last_track_id:
                            self._last_track_id = track_id
                            # Atualizar ID da faixa atual para o sistema de pré-carregamento
                            self._update_current_track_id(track_id)
                            self._pre_render_current_track(track)
                            
                            # Pré-carregar próxima faixa se habilitado
                            if self.get_setting("enable_preload", False):
                                self._preload_next_track_cover()
                            
                            # Limpar cache antigo
                            self._cleanup_preload_cache()
                
                time.sleep(sleep_interval)
            except Exception:
                time.sleep(5)

    def _pre_render_current_track(self, track):
        # Gera card baseado no tema selecionado
        self._generate_card(track, is_fm_command=False)

    def _bio_update_worker(self):
        """Worker para atualizar/restaurar a bio automaticamente"""
        self._nlog("[exteraFy] Bio update worker started")
        self._last_no_track_time = None
        self._restore_done = False
        while not self._stop_bio_update:
            try:
                if self.get_setting("enable_auto_bio_update", False):
                    self._nlog("[exteraFy] Auto bio update is enabled")
                    userFull = get_messages_controller().getUserFull(get_user_config().getClientUserId())
                    if not userFull:
                        self._nlog("[exteraFy] Failed to get userFull")
                        time.sleep(5)
                        continue
                    max_len = 140 if get_user_config().isPremium() else 70
                    token = self._get_access_token(show_error_bulletin=False)
                    if not token:
                        self._nlog("[exteraFy] No access token available")
                        time.sleep(5)
                        continue
                    self._nlog("[exteraFy] Fetching current track for bio update")
                    resp = requests.get(
                        "https://api.spotify.com/v1/me/player/currently-playing",
                        headers={"Authorization": f"Bearer {token}"},
                        timeout=5
                    )
                    if resp.status_code == 200 and resp.content:
                        data = resp.json()
                        track = data.get("item")
                        if track:
                            self._nlog(f"[exteraFy] Found track for bio update: {track['name']}")
                            # Atualizar ID da faixa atual para o sistema de pré-carregamento
                            self._update_current_track_id(track.get('id'))
                            autobio_text = self.get_setting("autobio_text", "Now Playing: {track} by {artist}")
                            bio = autobio_text.format(track=track["name"], artist=", ".join([a["name"] for a in track["artists"]]))
                            if userFull.about != bio[:max_len]:
                                try:
                                    req = TL_account.updateProfile()
                                    req.flags = 4
                                    req.about = bio[:max_len]
                                    send_request(req, (lambda _res: None))
                                    self._nlog("[exteraFy] Successfully updated bio automatically")
                                except Exception as e:
                                    log(f"[exteraFy] Error updating bio automatically: {e}")
                                    time.sleep(5)
                            self._last_no_track_time = None
                            self._restore_done = False
                        else:
                            self._nlog("[exteraFy] No track playing for bio update")
                            if self._last_no_track_time is None:
                                self._last_no_track_time = time.time()
                                self._restore_done = False
                            elif not self._restore_done and time.time() - self._last_no_track_time >= 600:
                                # Capturar bio atual do perfil em vez de usar bio antiga
                                try:
                                    current_bio = userFull.about if userFull else ""
                                    restore_bio_text = self.get_setting("restore_bio_text", "").strip()
                                    
                                    if current_bio and current_bio.strip():
                                        default_bio = current_bio
                                    elif restore_bio_text:
                                        default_bio = restore_bio_text
                                    else:
                                        default_bio = "I'm using nowFy!"
                                except:
                                    restore_bio_text = self.get_setting("restore_bio_text", "").strip()
                                    if restore_bio_text:
                                        default_bio = restore_bio_text
                                    else:
                                        default_bio = "I'm using nowFy!"
                                if userFull.about != default_bio[:max_len]:
                                    try:
                                        req = TL_account.updateProfile()
                                        req.flags = 4
                                        req.about = default_bio[:max_len]
                                        send_request(req, (lambda _res: None))
                                        self._nlog("[exteraFy] Restored bio after inactivity")
                                        # Não mostrar bulletin aqui, pois é auto-refresh (restauração)
                                    except Exception as e:
                                        log(f"[exteraFy] Error restoring bio after inactivity: {e}")
                                self._restore_done = True
                    else:
                        self._nlog("[exteraFy] Failed to get current track for bio update")
                        if self._last_no_track_time is None:
                            self._last_no_track_time = time.time()
                            self._restore_done = False
                        elif not self._restore_done and time.time() - self._last_no_track_time >= 600:
                            # Capturar bio atual do perfil em vez de usar bio antiga
                            try:
                                current_bio = userFull.about if userFull else ""
                                restore_bio_text = self.get_setting("restore_bio_text", "").strip()
                                
                                if current_bio and current_bio.strip():
                                    default_bio = current_bio
                                elif restore_bio_text:
                                    default_bio = restore_bio_text
                                else:
                                    default_bio = "I'm using nowFy!"
                            except:
                                restore_bio_text = self.get_setting("restore_bio_text", "").strip()
                                if restore_bio_text:
                                    default_bio = restore_bio_text
                                else:
                                    default_bio = "I'm using nowFy!"
                            if userFull.about != default_bio[:max_len]:
                                try:
                                    req = TL_account.updateProfile()
                                    req.flags = 4
                                    req.about = default_bio[:max_len]
                                    send_request(req, (lambda _res: None))
                                    self._nlog("[exteraFy] Restored bio after inactivity (no track)")
                                    # Não mostrar bulletin aqui, pois é auto-refresh (restauração)
                                except Exception as e:
                                    log(f"[exteraFy] Error restoring bio after inactivity (no track): {e}")
                            self._restore_done = True
                    time.sleep(120)
                else:
                    time.sleep(5)
            except Exception as e:
                self._nlog(f"[exteraFy] Bio update worker error: {e}")
                time.sleep(10)

    def _clear_cache(self):
        with self._cache_lock:
            # Limpar cache original
            self._image_cache.clear()
            self._cache_timestamps.clear()
            # Limpar cache otimizado
            if hasattr(self, '_enhanced_image_cache'):
                self._enhanced_image_cache.clear()
            if hasattr(self, '_base_theme_cache'):
                self._base_theme_cache.clear()
            # Limpar cache do Apple UI
            if hasattr(self, '_apple_cache'):
                self._apple_cache.clear()
                log("[RADIUS DEBUG] Apple cache cleared during general cache clear")
        # Limpar cache em disco
        try:
            for file in self._disk_cache_dir.listFiles():
                if file.getName().endswith('.cache'):
                    file.delete()
        except Exception:
            pass
        
        # Mostrar estatísticas de cache limpo
        performance_mode = self.get_setting("performance_mode", 1)
        mode_names = ["Turbo", "Balanceado", "Qualidade"]
        mode_name = mode_names[performance_mode] if 0 <= performance_mode <= 2 else "Desconhecido"
        
        BulletinHelper.show_success(tr("cache_cleared"))
    
    def _clear_nowcast_history(self):
        """Limpa completamente o histórico do NowCast para resolver problemas de postagem"""
        try:
            print("[NowCast] Limpando histórico completo do NowCast...")
            
            # Parar worker temporariamente se estiver rodando
            worker_was_running = getattr(self, '_nowcast_worker_running', False)
            if worker_was_running:
                print("[NowCast] Parando worker para limpeza...")
                self._nowcast_worker_running = False
                time.sleep(2)
            
            # Resetar todas as variáveis de controle do sistema anti-duplicatas
            self._nowcast_last_track_hash = None
            self._nowcast_post_history = []
            self._nowcast_cooldown_time = 0
            
            # Limpar cache também
            self._clear_cache()
            
            # Restaurar worker se estava rodando
            if worker_was_running:
                print("[NowCast] Restaurando worker após limpeza...")
                self._nowcast_worker_running = True
            
            print("[NowCast] Histórico do NowCast limpo completamente")
            
            try:
                BulletinHelper.show_bulletin(
                    "NowCast Reset",
                    "Histórico e cache do NowCast foram limpos. O bot deve voltar a funcionar normalmente."
                )
            except:
                pass
            
            return True
            
        except Exception as e:
            print(f"[NowCast] Erro ao limpar histórico: {e}")
            return False

    # === PERFORMANCE DO NOWFY ===

    
    def _get_cached_image_enhanced(self, url, cache_key=None, force_size=None):
        """Cache inteligente de imagens com otimizações de performance"""
        if not self.get_setting("enhanced_cache", True):
            return self._get_cached_image_original(url)
        
        if not cache_key:
            cache_key = url
        # Verificar cache em memória primeiro
        with self._cache_lock:
            if cache_key in self._enhanced_image_cache:
                cached_data = self._enhanced_image_cache[cache_key]
                if time.time() - cached_data['timestamp'] < self._cache_ttl:
                    return cached_data['image']
                else:
                    del self._enhanced_image_cache[cache_key]
        # Verificar cache em disco
        disk_cache_file = File(self._disk_cache_dir, f"{hash(cache_key) % 100000}.cache")
        if disk_cache_file.exists():
            try:
                with open(disk_cache_file.getAbsolutePath(), 'rb') as f:
                    cached_image = f.read()
                    # Adicionar de volta ao cache em memória
                    with self._cache_lock:
                        self._enhanced_image_cache[cache_key] = {
                            'image': cached_image,
                            'timestamp': time.time()
                        }
                    return cached_image
            except Exception:
                pass
        # Download e processamento da imagem
        try:
            performance_mode = self.get_setting("performance_mode", 1)
            timeout = 5 if performance_mode == 0 else (10 if performance_mode == 1 else 15)
            
            response = requests.get(url, timeout=timeout)
            if response.status_code == 200:
                image_data = response.content             
                # Optimize only if compression is enabled AND a target size was provided
                if self.get_setting("enable_compression", False) and not self._is_theme_base_image(url):
                    if force_size:
                        image_data = self._optimize_image(image_data, force_size)
                    else:
                        # Preserve original resolution/format when no force_size
                        pass
                # Salvar no cache em memória
                with self._cache_lock:
                    self._enhanced_image_cache[cache_key] = {
                        'image': image_data,
                        'timestamp': time.time()
                    }                   
                    # Limitar tamanho do cache em memória
                    if len(self._enhanced_image_cache) > self._cache_max_size:
                        oldest_key = min(self._enhanced_image_cache.keys(), 
                                        key=lambda k: self._enhanced_image_cache[k]['timestamp'])
                        del self._enhanced_image_cache[oldest_key]                
                # Salvar no cache em disco (assíncrono)
                try:
                    with open(disk_cache_file.getAbsolutePath(), 'wb') as f:
                        f.write(image_data)
                except Exception:
                    pass
                
                return image_data
        except Exception as e:
            log(f"[exteraFy] Error downloading image {url}: {e}")
        
        return None
    
    def _is_theme_base_image(self, url):
        """Verifica se a URL é de uma imagem base dos temas Apple"""
        theme_base_urls = [
            "https://i.postimg.cc/7L9Hf5Pd/applelight.png",
            "https://i.postimg.cc/d10qdJL1/appledark.png", 
            "https://i.postimg.cc/269phvZb/applered.png",
            "https://i.postimg.cc/5N8J5ZST/applelightsoundcloud.png",
            "https://i.postimg.cc/qv0T1jmR/appledarksoundcloud.png",
            "https://i.postimg.cc/rFPT53z2/appleredyoutubelight.png",
            "https://i.postimg.cc/0yKsnnJM/appleredyoutubedark.png",
            "https://i.postimg.cc/Wz7HXFsH/applelightytmusic.png",
            "https://i.postimg.cc/C502GHp8/appledarkytmusic.png",
            "https://i.postimg.cc/qvtSs7Cp/etglight.png",
            "https://i.postimg.cc/cJwzz5mj/etgdark.png",
            "https://i.postimg.cc/2yR4VrBj/ayulight.png",
            "https://i.postimg.cc/ryx170vD/ayudark.png",
            "https://i.postimg.cc/8cRLv9hR/ayured.png",
            "https://i.postimg.cc/HxxBVMzT/applelightapplelight.png",
            "https://i.postimg.cc/hvQs0qNw/appledarkapple.png",
            "https://i.postimg.cc/Jn2KJhYZ/appleredapple.png"
        ]
        return url in theme_base_urls

    def _optimize_image(self, image_data, target_size=None):
        """Optimize image preserving quality and save as PNG (lossless)."""
        try:
            from PIL import Image, ImageOps
            import io
            
            # Open image
            img = Image.open(io.BytesIO(image_data))
            # Resize to target if provided, preserving aspect
            if target_size and img.size != target_size:
                img = ImageOps.fit(img, target_size, method=Image.LANCZOS, centering=(0.5, 0.5))
            
            # PNG compression level based on performance mode (0-9)
            performance_mode = self.get_setting("performance_mode", 1)
            compress_level = 1 if performance_mode == 0 else (4 if performance_mode == 1 else 6)
            
            output = io.BytesIO()
            img.save(output, format='PNG', optimize=True, compress_level=compress_level)
            return output.getvalue()
            
        except Exception as e:
            log(f"[exteraFy] Error optimizing image: {e}")
            return image_data
    
    def _preload_next_track_cover(self):
        """Pré-carrega as próximas 5 faixas se o pré-carregamento estiver ativado"""
        if not self.get_setting("enable_preload", False):
            return
        
        try:
            # Executar pré-carregamento em thread separada para não bloquear
            threading.Thread(target=self._preload_worker, daemon=True).start()
        except Exception as e:
            log(f"[exteraFy] Error starting preload worker: {e}")
    
    def _preload_worker(self):
        """Worker thread para pré-carregamento de faixas"""
        try:
            account = self._get_account()
            if not account:
                return
            
            token = self._get_spotify_token(account)
            if not token:
                return
            
            # Obter informações da fila de reprodução atual
            queue_data = self._get_spotify_queue(token)
            if not queue_data:
                return
            
            # Pré-carregar próximas 5 faixas
            next_tracks = queue_data.get('queue', [])[:5]
            
            for i, track in enumerate(next_tracks):
                try:
                    self._preload_track_card(track, i + 1)
                    # Pequeno delay entre pré-carregamentos para não sobrecarregar
                    time.sleep(0.5)
                except Exception as e:
                    log(f"[exteraFy] Error preloading track {i+1}: {e}")
                    
        except Exception as e:
            log(f"[exteraFy] Error in preload worker: {e}")
    
    def _get_spotify_queue(self, token):
        """Obtém a fila de reprodução atual do Spotify"""
        try:
            # Primeiro, tentar obter a fila de reprodução
            resp = requests.get(
                "https://api.spotify.com/v1/me/player/queue",
                headers={"Authorization": f"Bearer {token}"},
                timeout=5
            )
            
            if resp.status_code == 200:
                return resp.json()
            
            # Se não conseguir a fila, usar faixas recentes como fallback
            resp = requests.get(
                "https://api.spotify.com/v1/me/player/recently-played?limit=10",
                headers={"Authorization": f"Bearer {token}"},
                timeout=5
            )
            
            if resp.status_code == 200:
                recent_data = resp.json()
                # Simular uma fila baseada nas faixas recentes
                return {
                    'queue': [item['track'] for item in recent_data.get('items', [])]
                }
            
            return None
            
        except Exception as e:
            log(f"[exteraFy] Error getting Spotify queue: {e}")
            return None
    
    def _preload_track_card(self, track, position):
        """Pré-carrega o card de uma faixa específica"""
        try:
            if not track or not track.get('id'):
                return
            
            track_id = track['id']
            track_name = track.get('name', 'Unknown')
            artists = [artist['name'] for artist in track.get('artists', [])]
            artist_name = ', '.join(artists) if artists else 'Unknown'
            album_name = track.get('album', {}).get('name', 'Unknown')
            
            # Criar chave de cache para esta faixa
            cache_key = f"preload_{track_id}_{position}"
            
            # Verificar se já está em cache
            if hasattr(self, '_preload_cache') and cache_key in self._preload_cache:
                cached_data = self._preload_cache[cache_key]
                if time.time() - cached_data['timestamp'] < 1800:  # Cache por 30 minutos
                    return
            
            # Obter URL da capa do álbum
            album_images = track.get('album', {}).get('images', [])
            image_url = ''
            if album_images:
                # Usar a imagem de maior qualidade disponível
                image_url = album_images[0]['url']
            
            # Pré-carregar a imagem da capa
            if image_url:
                cover_cache_key = f"preload_cover_{track_id}"
                cover_data = self._get_cached_image_enhanced(
                    image_url, 
                    cache_key=cover_cache_key,
                    force_size=298
                )
            
            # Gerar card pré-renderizado baseado no tema atual
            theme_mode = self.get_setting("theme_mode", 0)
            card_data = None
            
            if theme_mode in [0, 1, 2]:  # Temas Apple
                card_data = self._prerender_apple_card(track, image_url, theme_mode)
            elif theme_mode == 3:  # Tema CustomFM
                card_data = self._prerender_customfm_card(track, image_url)
            elif theme_mode == 4:  # Tema Default
                card_data = self._prerender_default_card(track, image_url)
            
            # Armazenar no cache de pré-carregamento
            if not hasattr(self, '_preload_cache'):
                self._preload_cache = {}
            
            self._preload_cache[cache_key] = {
                'track_data': {
                    'id': track_id,
                    'name': track_name,
                    'artist': artist_name,
                    'album': album_name,
                    'image_url': image_url
                },
                'card_data': card_data,
                'timestamp': time.time(),
                'position': position
            }
            
            # Limitar tamanho do cache de pré-carregamento
            if len(self._preload_cache) > 20:
                oldest_key = min(self._preload_cache.keys(),
                               key=lambda k: self._preload_cache[k]['timestamp'])
                del self._preload_cache[oldest_key]
            
            log(f"[exteraFy] Preloaded track {position}: {track_name} by {artist_name}")
            
        except Exception as e:
            log(f"[exteraFy] Error preloading track card: {e}")
    
    def _prerender_apple_card(self, track, image_url, theme_mode):
        """Pré-renderiza card no estilo Apple"""
        try:
            # Implementação simplificada - pode ser expandida
            return {
                'type': 'apple',
                'theme_mode': theme_mode,
                'track': track,
                'image_url': image_url,
                'rendered': True
            }
        except Exception as e:
            log(f"[exteraFy] Error prerendering Apple card: {e}")
            return None
    
    def _prerender_customfm_card(self, track, image_url):
        """Pré-renderiza card no estilo CustomFM"""
        try:
            return {
                'type': 'customfm',
                'track': track,
                'image_url': image_url,
                'rendered': True
            }
        except Exception as e:
            log(f"[exteraFy] Error prerendering CustomFM card: {e}")
            return None
    
    def _prerender_default_card(self, track, image_url):
        """Pré-renderiza card no estilo Default"""
        try:
            return {
                'type': 'default',
                'track': track,
                'image_url': image_url,
                'rendered': True
            }
        except Exception as e:
            log(f"[exteraFy] Error prerendering Default card: {e}")
            return None
    
    def get_preloaded_track(self, track_id):
        """Obtém uma faixa pré-carregada do cache"""
        try:
            if not hasattr(self, '_preload_cache'):
                return None
            
            for cache_key, cached_data in self._preload_cache.items():
                if cached_data['track_data']['id'] == track_id:
                    # Verificar se o cache ainda é válido
                    if time.time() - cached_data['timestamp'] < 1800:  # 30 minutos
                        return cached_data
                    else:
                        # Cache expirado, remover
                        del self._preload_cache[cache_key]
                        break
            
            return None
            
        except Exception as e:
             log(f"[exteraFy] Error getting preloaded track: {e}")
             return None
    
    def _is_preloaded_card_compatible(self, preloaded_card, current_theme):
        """Verifica se o card pré-carregado é compatível com o tema atual"""
        try:
            if not preloaded_card or not preloaded_card.get('type'):
                return False
            
            card_type = preloaded_card['type']
            
            # Verificar compatibilidade baseada no tipo de card e tema atual
            if card_type == 'apple' and current_theme in [0, 1, 2]:
                # Card Apple é compatível com temas Apple (0, 1, 2)
                return preloaded_card.get('theme_mode') == current_theme
            elif card_type == 'customfm' and current_theme == 3:
                # Card CustomFM é compatível com tema CustomFM (3)
                return True
            elif card_type == 'default' and current_theme == 4:
                # Card Default é compatível com tema Default (4)
                return True
            
            return False
            
        except Exception as e:
            log(f"[exteraFy] Error checking preloaded card compatibility: {e}")
            return False
    
    def _process_preloaded_card(self, preloaded_card, params, progress_ms, is_fm_command):
        """Processa um card pré-carregado rapidamente"""
        try:
            if not preloaded_card or not preloaded_card.get('track'):
                return
            
            track = preloaded_card['track']
            image_url = preloaded_card.get('image_url', '')
            card_type = preloaded_card.get('type', 'default')
            
            # Processar baseado no tipo de card
            if card_type == 'apple':
                theme_mode = preloaded_card.get('theme_mode', 0)
                self._process_preloaded_apple_card(track, image_url, theme_mode, params, progress_ms, is_fm_command)
            elif card_type == 'customfm':
                self._process_preloaded_customfm_card(track, image_url, params, progress_ms, is_fm_command)
            elif card_type == 'default':
                self._process_preloaded_default_card(track, image_url, params, progress_ms, is_fm_command)
            
        except Exception as e:
            log(f"[exteraFy] Error processing preloaded card: {e}")
    
    def _process_preloaded_apple_card(self, track, image_url, theme_mode, params, progress_ms, is_fm_command):
        """Processa card Apple pré-carregado"""
        try:
            # Usar dados pré-carregados para gerar card Apple rapidamente
            title = track.get('name', 'Unknown')
            artists = [artist['name'] for artist in track.get('artists', [])] if track.get('artists') else ['Unknown']
            artist = ', '.join(artists)
            album = track.get('album', {}).get('name', 'Unknown') if track.get('album') else 'Unknown'
            
            # Chamar função de geração Apple com dados pré-carregados
            self._get_current_track_lastfm_customfm(
                title, artist, album, image_url, params, 
                progress_dialog=None, player="Spotify", 
                youtube_url=None, etg_cover_image=None
            )
            
        except Exception as e:
            log(f"[exteraFy] Error processing preloaded Apple card: {e}")
    
    def _process_preloaded_customfm_card(self, track, image_url, params, progress_ms, is_fm_command):
        """Processa card CustomFM pré-carregado"""
        try:
            title = track.get('name', 'Unknown')
            artists = [artist['name'] for artist in track.get('artists', [])] if track.get('artists') else ['Unknown']
            artist = ', '.join(artists)
            album = track.get('album', {}).get('name', 'Unknown') if track.get('album') else 'Unknown'
            
            # Chamar função de geração CustomFM com dados pré-carregados
            self._get_current_track_lastfm_customfm(
                title, artist, album, image_url, params,
                progress_dialog=None, player="Spotify",
                youtube_url=None, etg_cover_image=None
            )
            
        except Exception as e:
            log(f"[exteraFy] Error processing preloaded CustomFM card: {e}")
    
    def _process_preloaded_default_card(self, track, image_url, params, progress_ms, is_fm_command):
        """Processa card Default pré-carregado"""
        try:
            title = track.get('name', 'Unknown')
            artists = [artist['name'] for artist in track.get('artists', [])] if track.get('artists') else ['Unknown']
            artist = ', '.join(artists)
            album = track.get('album', {}).get('name', 'Unknown') if track.get('album') else 'Unknown'
            
            # Chamar função de geração Default com dados pré-carregados
            self._get_current_track_lastfm_default(
                title, artist, album, image_url, params,
                progress_dialog=None, player="Spotify",
                youtube_url=None, etg_cover_image=None
            )
            
        except Exception as e:
            log(f"[exteraFy] Error processing preloaded Default card: {e}")
    
    def _cleanup_preload_cache(self):
        """Limpa o cache de pré-carregamento de faixas antigas"""
        try:
            if not hasattr(self, '_preload_cache'):
                return
            
            current_time = time.time()
            cache_ttl = 300  # 5 minutos
            
            # Remover entradas antigas do cache
            expired_keys = []
            for track_id, data in self._preload_cache.items():
                if current_time - data.get('timestamp', 0) > cache_ttl:
                    expired_keys.append(track_id)
            
            for key in expired_keys:
                del self._preload_cache[key]
            
            # Limitar tamanho do cache (máximo 10 faixas)
            if len(self._preload_cache) > 10:
                # Remover as mais antigas
                sorted_items = sorted(self._preload_cache.items(), 
                                    key=lambda x: x[1].get('timestamp', 0))
                for track_id, _ in sorted_items[:-10]:
                    del self._preload_cache[track_id]
            
            log(f"[exteraFy] Preload cache cleaned. Current size: {len(self._preload_cache)}")
            
        except Exception as e:
            log(f"[exteraFy] Error cleaning preload cache: {e}")
    
    def _is_track_currently_playing(self, track_id):
        """Verifica se a faixa está atualmente sendo reproduzida"""
        try:
            if not hasattr(self, '_current_track_id'):
                return False
            return self._current_track_id == track_id
        except Exception as e:
            log(f"[exteraFy] Error checking current track: {e}")
            return False
    
    def _update_current_track_id(self, track_id):
        """Atualiza o ID da faixa atual"""
        try:
            self._current_track_id = track_id
        except Exception as e:
            log(f"[exteraFy] Error updating current track ID: {e}")
    
    def _get_cached_customfm_image(self, cache_key, temp_dir):
        """Verifica se existe uma imagem CustomFM em cache"""
        try:
            cache_file = File(temp_dir, f"customfm_{cache_key}.png")
            if cache_file.exists():
                # Verificar se o arquivo não é muito antigo (cache por 1 hora)
                file_time = cache_file.lastModified()
                current_time = System.currentTimeMillis()
                if (current_time - file_time) < 3600000:  # 1 hora em millisegundos
                    return cache_file.getAbsolutePath()
                else:
                    # Cache expirado, deletar arquivo
                    cache_file.delete()
            return None
        except Exception as e:
            log(f"[Nowfy] Erro ao verificar cache CustomFM: {e}")
            return None

    def _get_cached_image_original(self, url):
        """Função original de cache para fallback"""
        cache_key = url
        current_time = time.time()
        
        with self._cache_lock:
            if cache_key in self._image_cache:
                if current_time - self._cache_timestamps.get(cache_key, 0) < self._cache_ttl:
                    return self._image_cache[cache_key]
                else:
                    del self._image_cache[cache_key]
                    if cache_key in self._cache_timestamps:
                        del self._cache_timestamps[cache_key]
        
        try:
            response = requests.get(url, timeout=10)
            if response.status_code == 200:
                image_data = response.content
                with self._cache_lock:
                    self._image_cache[cache_key] = image_data
                    self._cache_timestamps[cache_key] = current_time
                return image_data
        except Exception as e:
            log(f"[exteraFy] Error downloading image {url}: {e}")
        
        return None

    def _get_youtube_thumbnail_cached(self, video_id, quality='maxresdefault'):
        """Cache específico para thumbnails do YouTube com fallback de qualidade"""
        if not self.get_setting("enable_youtube_thumbnail_cache", False):
            return self._get_youtube_thumbnail_direct(video_id, quality)
        
        cache_key = f"yt_thumb_{video_id}_{quality}"      
        # Verificar cache em memória
        with self._cache_lock:
            if hasattr(self, '_youtube_thumbnail_cache') and cache_key in self._youtube_thumbnail_cache:
                cached_data = self._youtube_thumbnail_cache[cache_key]
                if time.time() - cached_data['timestamp'] < self._cache_ttl:
                    return cached_data['data']
                else:
                    del self._youtube_thumbnail_cache[cache_key]
        
        # Inicializar cache se não existir
        if not hasattr(self, '_youtube_thumbnail_cache'):
            self._youtube_thumbnail_cache = {}
        
        # Tentar obter thumbnail
        thumbnail_data = self._get_youtube_thumbnail_direct(video_id, quality)
        
        if thumbnail_data:
            # Armazenar no cache
            with self._cache_lock:
                self._youtube_thumbnail_cache[cache_key] = {
                    'data': thumbnail_data,
                    'timestamp': time.time()
                }
                
                # Limitar tamanho do cache
                if len(self._youtube_thumbnail_cache) > 50:
                    oldest_key = min(self._youtube_thumbnail_cache.keys(),
                                    key=lambda k: self._youtube_thumbnail_cache[k]['timestamp'])
                    del self._youtube_thumbnail_cache[oldest_key]
        
        return thumbnail_data
    
    def _get_youtube_thumbnail_direct(self, video_id, quality='maxresdefault'):
        """Obtém thumbnail do YouTube com fallback de qualidade e valida resolução."""
        # Tentar sempre as melhores opções primeiro
        qualities = ['maxresdefault', 'hq720', 'sddefault', 'hqdefault', 'mqdefault', 'default']
        
        # Respeitar configuração de fallback
        if self.get_setting("enable_quality_fallback", True):
            if quality in qualities:
                start_index = qualities.index(quality)
                qualities = qualities[start_index:] + qualities[:start_index]
        else:
            qualities = [quality]
        
        bases = ["https://img.youtube.com", "https://i.ytimg.com"]
        for q in qualities:
            for base in bases:
                try:
                    thumb_url = f"{base}/vi/{video_id}/{q}.jpg"
                    response = requests.get(thumb_url, timeout=10)
                    if response.status_code == 200 and self._is_high_quality_thumbnail(response.content):
                        return response.content
                except Exception as e:
                    log(f"[exteraFy] Error getting YouTube thumbnail {q} from {base}: {e}")
                    continue
        
        return None
    
    def _is_high_quality_thumbnail(self, response_content):
        """Valida se a thumbnail tem resolução útil (evita placeholders)."""
        try:
            from io import BytesIO
            from PIL import Image
            
            # Verificação mínima de conteúdo
            if not response_content or len(response_content) < 8000:
                return False
            # JPEG assinatura
            if not (b'JFIF' in response_content[:64] or b'\xff\xd8\xff' in response_content[:10]):
                return False
            
            # Abrir e verificar dimensões
            img = Image.open(BytesIO(response_content))
            w, h = img.size
            # Exigir pelo menos qualidade SD e evitar 120x90
            if w >= 640 and h >= 360:
                return True
            # Permitir hqdefault quando nada melhor está disponível
            return w >= 480 and h >= 270
        except Exception:
            return False
    
    def _get_soundcloud_thumbnail_cached(self, track_url):
        """Cache específico para thumbnails do SoundCloud"""
        if not self.get_setting("enable_soundcloud_thumbnail_cache", False):
            return self._get_soundcloud_thumbnail_direct(track_url)
        
        cache_key = f"sc_thumb_{hash(track_url)}"
        
        # Verificar cache em memória
        with self._cache_lock:
            if hasattr(self, '_soundcloud_thumbnail_cache') and cache_key in self._soundcloud_thumbnail_cache:
                cached_data = self._soundcloud_thumbnail_cache[cache_key]
                if time.time() - cached_data['timestamp'] < self._cache_ttl:
                    return cached_data['data']
                else:
                    del self._soundcloud_thumbnail_cache[cache_key]
        
        # Inicializar cache se não existir
        if not hasattr(self, '_soundcloud_thumbnail_cache'):
            self._soundcloud_thumbnail_cache = {}
        
        # Tentar obter thumbnail
        thumbnail_data = self._get_soundcloud_thumbnail_direct(track_url)
        
        if thumbnail_data:
            # Armazenar no cache
            with self._cache_lock:
                self._soundcloud_thumbnail_cache[cache_key] = {
                    'data': thumbnail_data,
                    'timestamp': time.time()
                }
                
                # Limitar tamanho do cache
                if len(self._soundcloud_thumbnail_cache) > 30:
                    oldest_key = min(self._soundcloud_thumbnail_cache.keys(),
                                    key=lambda k: self._soundcloud_thumbnail_cache[k]['timestamp'])
                    del self._soundcloud_thumbnail_cache[oldest_key]
        
        return thumbnail_data
    
    def _get_soundcloud_thumbnail_direct(self, track_url):
        """Obtém thumbnail do SoundCloud diretamente"""
        try:
            # Implementação básica - pode ser expandida conforme necessário
            response = requests.get(track_url, timeout=10)
            if response.status_code == 200:
                # Extrair URL da thumbnail do HTML (implementação simplificada)
                import re
                content = response.text
                thumbnail_match = re.search(r'"artwork_url":"([^"]+)"', content)
                if thumbnail_match:
                    thumbnail_url = thumbnail_match.group(1).replace('\\/', '/')
                    # Tentar obter thumbnail em alta resolução
                    thumbnail_url = thumbnail_url.replace('large.jpg', 't500x500.jpg')
                    
                    thumb_response = requests.get(thumbnail_url, timeout=10)
                    if thumb_response.status_code == 200:
                        return thumb_response.content
        except Exception as e:
            log(f"[exteraFy] Error getting SoundCloud thumbnail: {e}")
        
        return None
    
    def _get_valid_thumbnail_url_cached(self, url):
        """Cache de URLs de thumbnails válidas"""
        if not self.get_setting("enable_url_cache", True):
            return self._validate_thumbnail_url_direct(url)
        
        cache_key = f"url_valid_{hash(url)}"
        
        # Verificar cache em memória
        with self._cache_lock:
            if hasattr(self, '_url_validation_cache') and cache_key in self._url_validation_cache:
                cached_data = self._url_validation_cache[cache_key]
                if time.time() - cached_data['timestamp'] < (self._cache_ttl * 2):  # URLs válidas duram mais
                    return cached_data['data']
                else:
                    del self._url_validation_cache[cache_key]
        
        # Inicializar cache se não existir
        if not hasattr(self, '_url_validation_cache'):
            self._url_validation_cache = {}
        
        # Validar URL
        is_valid = self._validate_thumbnail_url_direct(url)
        
        # Armazenar no cache
        with self._cache_lock:
            self._url_validation_cache[cache_key] = {
                'data': is_valid,
                'timestamp': time.time()
            }
            
            # Limitar tamanho do cache
            if len(self._url_validation_cache) > 100:
                oldest_key = min(self._url_validation_cache.keys(),
                                key=lambda k: self._url_validation_cache[k]['timestamp'])
                del self._url_validation_cache[oldest_key]
        
        return is_valid
    
    def _validate_thumbnail_url_direct(self, url):
        """Valida se uma URL de thumbnail é válida"""
        try:
            response = requests.head(url, timeout=5)
            return response.status_code == 200 and 'image' in response.headers.get('content-type', '')
        except Exception:
            return False

    def _get_card_base_image_url(self, theme=0):
        # Para o tema Apple unificado (theme=0), usar o sistema de skin
        if theme == 0:  # Apple unificado
            current_player = self._detect_current_player()
            apple_skin_index = self._get_apple_skin_index_mapped()
            skin_names = ["Light", "Dark"]  # Red removido por problemas de compatibilidade
            skin = skin_names[apple_skin_index]
            
            # Usar o dicionário APPLE_BACKGROUNDS
            if current_player in APPLE_BACKGROUNDS and skin in APPLE_BACKGROUNDS[current_player]:
                return APPLE_BACKGROUNDS[current_player][skin]
            
            # Fallback para Spotify se player não encontrado
            return APPLE_BACKGROUNDS["Spotify"][skin]
        
        # Manter compatibilidade com temas externos (theme > 0)
        # Detectar se o player ativo é SoundCloud, YouTube, YouTube Music, exteraGram, AyuGram ou Apple Music
        current_player = self._detect_current_player()
        is_soundcloud = current_player == "SoundCloud"
        is_youtube = current_player == "YouTube"
        is_youtube_music = current_player == "YouTube Music"
        is_exteragram = current_player == "exteraGram"
        is_ayugram = current_player == "AyuGram"
        is_apple_music = current_player == "Apple Music"
        is_yandex_music = current_player == "Yandex Music"
        
        # Compatibilidade com temas antigos (será removido gradualmente)
        if theme == 2:  # Apple Red
            if is_soundcloud:
                return "https://i.postimg.cc/6p0NgnSh/appleredsoundcloud.png"
            elif is_youtube:
                return "https://i.postimg.cc/bvXjBnQ6/appleredyoutubered.png"
            elif is_youtube_music:
                return "https://i.postimg.cc/44vqJMpQ/appleredytmusic.png"
            elif is_exteragram:
                return "https://i.postimg.cc/6pDSYNdn/etgred.png"
            elif is_ayugram:
                return "https://i.postimg.cc/8cRLv9hR/ayured.png"
            elif is_apple_music:
                return "https://i.postimg.cc/Jn2KJhYZ/appleredapple.png"
            return "https://i.postimg.cc/269phvZb/applered.png"
        if theme == 1:  # Apple Dark
            if is_soundcloud:
                return "https://i.postimg.cc/qv0T1jmR/appledarksoundcloud.png"
            elif is_youtube:
                return "https://i.postimg.cc/0yKsnnJM/appleredyoutubedark.png"
            elif is_youtube_music:
                return "https://i.postimg.cc/C502GHp8/appledarkytmusic.png"
            elif is_exteragram:
                return "https://i.postimg.cc/cJwzz5mj/etgdark.png"
            elif is_ayugram:
                return "https://i.postimg.cc/ryx170vD/ayudark.png"
            elif is_apple_music:
                return "https://i.postimg.cc/hvQs0qNw/appledarkapple.png"
            elif is_yandex_music:
                return "https://raw.githubusercontent.com/soumaki/nowFy/refs/heads/main/plataform/yandex_swap.png"
            return "https://i.postimg.cc/d10qdJL1/appledark.png"
        
        # Fallback para Apple Light
        if is_soundcloud:
            return "https://i.postimg.cc/5N8J5ZST/applelightsoundcloud.png"
        elif is_youtube:
            return "https://i.postimg.cc/rFPT53z2/appleredyoutubelight.png"
        elif is_youtube_music:
            return "https://i.postimg.cc/Wz7HXFsH/applelightytmusic.png"
        elif is_exteragram:
            return "https://i.postimg.cc/qvtSs7Cp/etglight.png"
        elif is_ayugram:
            return "https://i.postimg.cc/2yR4VrBj/ayulight.png"
        elif is_apple_music:
            return "https://i.postimg.cc/HxxBVMzT/applelightapplelight.png"
        elif is_yandex_music:
            return "https://raw.githubusercontent.com/soumaki/nowFy/refs/heads/main/plataform/yandex.png"
        return "https://i.postimg.cc/7L9Hf5Pd/applelight.png"

    def _get_card_base_path(self, theme=0):
        temp_dir = File(ApplicationLoader.getFilesDirFixed(), "exteraFy/cards")
        if not temp_dir.exists():
            temp_dir.mkdirs()
        
        # Para o tema Apple unificado (theme=0), usar o sistema de skin
        if theme == 0:  # Apple unificado
            current_player = self._detect_current_player()
            apple_skin_index = self._get_apple_skin_index_mapped()
            skin_names = ["Light", "Dark", "Red"]
            skin = skin_names[apple_skin_index].lower()
            
            # Gerar nome do arquivo baseado no player e skin
            player_suffix = ""
            if current_player == "SoundCloud":
                player_suffix = "_soundcloud"
            elif current_player == "YouTube":
                player_suffix = "_youtube"
            elif current_player == "YouTube Music":
                player_suffix = "_ytmusic"
            elif current_player == "exteraGram":
                player_suffix = "_exteragram"
            elif current_player == "AyuGram":
                player_suffix = "_ayugram"
            elif current_player == "Apple Music":
                player_suffix = "_applemusic"
            
            filename = f"apple{skin}{player_suffix}.png"
            return File(temp_dir, filename).getAbsolutePath()
        
        # Manter compatibilidade com temas externos (theme > 0)
        # Detectar se o player ativo é SoundCloud, YouTube, YouTube Music, exteraGram, AyuGram ou Apple Music para usar caminhos diferentes
        current_player = self._detect_current_player()
        is_soundcloud = current_player == "SoundCloud"
        is_youtube = current_player == "YouTube"
        is_youtube_music = current_player == "YouTube Music"
        is_exteragram = current_player == "exteraGram"
        is_ayugram = current_player == "AyuGram"
        is_apple_music = current_player == "Apple Music"
        
        if theme == 2:  # Apple Red
            if is_soundcloud:
                return File(temp_dir, "applered_soundcloud.png").getAbsolutePath()
            elif is_youtube:
                return File(temp_dir, "applered_youtube.png").getAbsolutePath()
            elif is_youtube_music:
                return File(temp_dir, "applered_ytmusic.png").getAbsolutePath()
            elif is_exteragram:
                return File(temp_dir, "applered_exteragram.png").getAbsolutePath()
            elif is_ayugram:
                return File(temp_dir, "applered_ayugram.png").getAbsolutePath()
            elif is_apple_music:
                return File(temp_dir, "applered_applemusic.png").getAbsolutePath()
            elif is_yandex_music:
                return File(temp_dir, "yandex_swap.png").getAbsolutePath()
            return File(temp_dir, "applered.png").getAbsolutePath()
        if theme == 1:  # Apple Dark
            if is_soundcloud:
                return File(temp_dir, "appledark_soundcloud.png").getAbsolutePath()
            elif is_youtube:
                return File(temp_dir, "appledark_youtube.png").getAbsolutePath()
            elif is_youtube_music:
                return File(temp_dir, "appledark_ytmusic.png").getAbsolutePath()
            elif is_exteragram:
                return File(temp_dir, "appledark_exteragram.png").getAbsolutePath()
            elif is_ayugram:
                return File(temp_dir, "appledark_ayugram.png").getAbsolutePath()
            elif is_apple_music:
                return File(temp_dir, "appledark_applemusic.png").getAbsolutePath()
            elif is_yandex_music:
                return File(temp_dir, "yandex_swap.png").getAbsolutePath()
            return File(temp_dir, "appledark.png").getAbsolutePath()
        # Fallback para Apple Light
        if is_soundcloud:
            return File(temp_dir, "applelight_soundcloud.png").getAbsolutePath()
        elif is_youtube:
            return File(temp_dir, "applelight_youtube.png").getAbsolutePath()
        elif is_youtube_music:
            return File(temp_dir, "applelight_ytmusic.png").getAbsolutePath()
        elif is_exteragram:
            return File(temp_dir, "applelight_exteragram.png").getAbsolutePath()
        elif is_ayugram:
            return File(temp_dir, "applelight_ayugram.png").getAbsolutePath()
        elif is_apple_music:
            return File(temp_dir, "applelight_applemusic.png").getAbsolutePath()
        elif is_yandex_music:
            return File(temp_dir, "yandex.png").getAbsolutePath()
        return File(temp_dir, "applelight.png").getAbsolutePath()

    def _get_card_base_version_path(self, theme=0):
        temp_dir = File(ApplicationLoader.getFilesDirFixed(), "exteraFy/cards")
        if not temp_dir.exists():
            temp_dir.mkdirs()
        
        # Para o tema Apple unificado (theme=0), usar o sistema de skin
        if theme == 0:  # Apple unificado
            current_player = self._detect_current_player()
            apple_skin_index = self._get_apple_skin_index_mapped()
            skin_names = ["Dark", "Red"]
            skin = skin_names[apple_skin_index].lower()
            
            # Gerar nome do arquivo baseado no player e skin
            player_suffix = ""
            if current_player == "SoundCloud":
                player_suffix = "_soundcloud"
            elif current_player == "YouTube":
                player_suffix = "_youtube"
            elif current_player == "YouTube Music":
                player_suffix = "_ytmusic"
            elif current_player == "exteraGram":
                player_suffix = "_exteragram"
            elif current_player == "AyuGram":
                player_suffix = "_ayugram"
            elif current_player == "Apple Music":
                player_suffix = "_applemusic"
            
            filename = f"apple{skin}{player_suffix}_version.txt"
            return File(temp_dir, filename).getAbsolutePath()
        
        # Manter compatibilidade com temas externos (theme > 0)
        # Detectar se o player ativo é SoundCloud, YouTube, YouTube Music, exteraGram, AyuGram ou Apple Music para usar caminhos diferentes
        current_player = self._detect_current_player()
        is_soundcloud = current_player == "SoundCloud"
        is_youtube = current_player == "YouTube"
        is_youtube_music = current_player == "YouTube Music"
        is_exteragram = current_player == "exteraGram"
        is_ayugram = current_player == "AyuGram"
        is_apple_music = current_player == "Apple Music"
        is_yandex_music = current_player == "Yandex Music"
        
        if theme == 2:  # Apple Red
            if is_soundcloud:
                return File(temp_dir, "applered_soundcloud_version.txt").getAbsolutePath()
            elif is_youtube:
                return File(temp_dir, "applered_youtube_version.txt").getAbsolutePath()
            elif is_youtube_music:
                return File(temp_dir, "applered_ytmusic_version.txt").getAbsolutePath()
            elif is_exteragram:
                return File(temp_dir, "applered_exteragram_version.txt").getAbsolutePath()
            elif is_ayugram:
                return File(temp_dir, "applered_ayugram_version.txt").getAbsolutePath()
            elif is_apple_music:
                return File(temp_dir, "applered_applemusic_version.txt").getAbsolutePath()
            return File(temp_dir, "applered_version.txt").getAbsolutePath()
        if theme == 1:  # Apple Dark
            if is_soundcloud:
                return File(temp_dir, "appledark_soundcloud_version.txt").getAbsolutePath()
            elif is_youtube:
                return File(temp_dir, "appledark_youtube_version.txt").getAbsolutePath()
            elif is_youtube_music:
                return File(temp_dir, "appledark_ytmusic_version.txt").getAbsolutePath()
            elif is_exteragram:
                return File(temp_dir, "appledark_exteragram_version.txt").getAbsolutePath()
            elif is_ayugram:
                return File(temp_dir, "appledark_ayugram_version.txt").getAbsolutePath()
            elif is_apple_music:
                return File(temp_dir, "appledark_applemusic_version.txt").getAbsolutePath()
            return File(temp_dir, "appledark_version.txt").getAbsolutePath()
        # Fallback para Apple Light
        if is_soundcloud:
            return File(temp_dir, "applelight_soundcloud_version.txt").getAbsolutePath()
        elif is_youtube:
            return File(temp_dir, "applelight_youtube_version.txt").getAbsolutePath()
        elif is_youtube_music:
            return File(temp_dir, "applelight_ytmusic_version.txt").getAbsolutePath()
        elif is_exteragram:
            return File(temp_dir, "applelight_exteragram_version.txt").getAbsolutePath()
        elif is_ayugram:
            return File(temp_dir, "applelight_ayugram_version.txt").getAbsolutePath()
        elif is_apple_music:
            return File(temp_dir, "applelight_applemusic_version.txt").getAbsolutePath()
        return File(temp_dir, "applelight_version.txt").getAbsolutePath()

    def _ensure_card_base_image(self, force_update=False, theme=0):
        base_path = self._get_card_base_path(theme)
        version_path = self._get_card_base_version_path(theme)
        current_url = self._get_card_base_image_url(theme)
        should_download = force_update
        if not should_download:
            if not os.path.exists(base_path):
                should_download = True
                log("[exteraFy] Base image not found, downloading...")
            elif not os.path.exists(version_path):
                should_download = True
                log("[exteraFy] Version file not found, downloading...")
            else:
                try:
                    with open(version_path, "r") as f:
                        saved_url = f.read().strip()
                    if saved_url != current_url:
                        should_download = True
                        log(f"[exteraFy] URL changed from {saved_url} to {current_url}, downloading new image...")
                    else:
                        log("[exteraFy] Using cached base image")
                except Exception as e:
                    should_download = True
                    log(f"[exteraFy] Error reading version file: {e}, downloading...")
        if should_download:
            try:
                log(f"[exteraFy] Downloading new base image from: {current_url}")
                # Usar cache original para download da imagem base (sem otimização de tamanho)
                image_data = self._get_cached_image_original(current_url)
                if image_data:
                    os.makedirs(os.path.dirname(base_path), exist_ok=True)
                    with open(base_path, "wb") as f:
                        f.write(image_data)
                    with open(version_path, "w") as f:
                        f.write(current_url)
                    log(f"[exteraFy] New base image downloaded and saved successfully")
                else:
                    raise Exception("Failed to download base image from cache")
            except Exception as e:
                log(f"[exteraFy] Error downloading new base image: {e}")
                if not os.path.exists(base_path):
                    raise e
                else:
                    log("[exteraFy] Using existing image as fallback")
        return base_path

    def _get_external_themes(self):
        """Temas externos desativados temporariamente"""
        try:
            self._nlog("[NowFy] External themes disabled")
        except Exception:
            pass
        return {}

    def _generate_card(self, track, params=None, progress_ms=None, force_spotify=False, etg_cover_image=None, is_fm_command=False):
        """Gera o card baseado no tema selecionado ou aleatório"""
        log(f"[Nowfy] _generate_card called - Track: {track.get('name', 'Unknown') if track else 'None'}, Force Spotify: {force_spotify}, is_fm_command: {is_fm_command}")
        
        # Verificar se existe versão pré-carregada desta faixa
        if track and track.get('id') and self.get_setting("enable_preload", False):
            preloaded_data = self.get_preloaded_track(track['id'])
            if preloaded_data and preloaded_data.get('card_data'):
                log(f"[exteraFy] Using preloaded card for track: {track.get('name', 'Unknown')}")
                # Usar dados pré-carregados se disponíveis e compatíveis com o tema atual
                current_theme = self.get_setting("theme_mode", 0)
                preloaded_card = preloaded_data['card_data']
                
                # Verificar compatibilidade do tema
                if self._is_preloaded_card_compatible(preloaded_card, current_theme):
                    # Processar card pré-carregado rapidamente
                    self._process_preloaded_card(preloaded_card, params, progress_ms, is_fm_command)
                    return
        

        
        random_theme = self.get_setting("random_theme_mode", False)
        if random_theme:
            import random
            # Incluir temas externos no modo aleatório
            external_themes = self._get_external_themes()
            
            # Verificar se é Last.FM para excluir temas Apple
            media_source = self.get_setting("media_source", 0)
            is_lastfm = media_source == 1  # 1 = Last.FM
            
            # Incluir temas Apple para todas as fontes (Spotify, Stats.fm e Last.fm)
            theme_options = [0, 1, 2]  # Apple Light, Apple Dark, Apple Red
            
            if external_themes:
                # Adicionar índices dos temas externos (3+)
                theme_options.extend(range(3, 3 + len(external_themes)))
            # Adicionar índice do tema Vinni
            vinni_index = 3 + len(external_themes)
            theme_options.append(vinni_index)
            # Adicionar índice do CustomFM (penúltimo)
            customfm_index = vinni_index + 1
            theme_options.append(customfm_index)
            # Adicionar índice do tema Minimal (último)
            minimal_index = customfm_index + 1
            theme_options.append(minimal_index)
            theme = random.choice(theme_options)
            log(f"[NowFy] Random theme selected: {theme} (Last.FM: {is_lastfm})")
        else:
            theme = self.get_setting("theme_selector", 0)
            log(f"[NowFy] Using selected theme: {theme}")
        
        # Verificar se é Last.FM e bloquear temas Apple completamente
        media_source = self.get_setting("media_source", 0)
        is_lastfm = media_source == 1  # 1 = Last.FM
        
        # Temas Apple (0, 1, 2) e Minimal agora têm suporte ao Last.fm
        
        if is_fm_command:
            player = self._detect_current_player()
            log(f"[NowFy] FM command - Theme: {theme}, Player: {player}")
        
        # Obter temas externos
        external_themes = self._get_external_themes()
        
        # Debug: Calcular índices dos temas
        vinni_index = 3 + len(external_themes)
        customfm_index = vinni_index + 1
        minimal_index = customfm_index + 1
        log(f"[NowFy] Theme debug - Selected: {theme}, Vinni index: {vinni_index}, CustomFM index: {customfm_index}, Minimal index: {minimal_index}, External themes count: {len(external_themes)}")
        log(f"[NowFy] Available themes: Apple Light(0), Apple Dark(1), Apple Red(2), External themes(3-{2+len(external_themes)}), Vinni({vinni_index}), CustomFM({customfm_index}), Minimal({minimal_index})")
        
        # Verificar se há uma imagem de capa do ETG
        player = self._detect_current_player()
        if etg_cover_image is None and player in ["exteraGram", "AyuGram", "Telegram"]:
            # Tentar obter a capa do ETG se não foi fornecida
            try:
                from org.telegram.messenger import MediaController
                media_controller = MediaController.getInstance()
                playing_song = media_controller.getPlayingMessageObject()
                etg_cover_image = self.get_etg_cover(playing_song)
            except Exception as e:
                log(f"[NowFy] Error getting ETG cover: {e}")
                etg_cover_image = None
        
        # Verificar se é Spotify para temas Apple
        player = "Spotify" if force_spotify else self._detect_current_player()
        
        if theme == 0:  # Apple unificado
            # Permitir para Spotify, SoundCloud, exteraGram, AyuGram e Apple Music (exceto Last.FM)
            # Apple Light bloqueado para SoundCloud conforme solicitado
            apple_skin_index = self._get_apple_skin_index_mapped()
            current_player = self._detect_current_player()
            
            # Verificar se Apple Light está sendo usado com SoundCloud (bloqueado)
            if apple_skin_index == 0 and current_player == "SoundCloud":
                log(f"[NowFy] Apple Light blocked for SoundCloud as requested")
                title = track["name"]
                artists = ", ".join([a["name"] for a in track["artists"]])
                album = track["album"]["name"] if track.get("album") else ""
                images = track["album"].get("images", [])
                image_url = max(images, key=lambda i: i.get("width", 0))["url"] if images else None
                youtube_url = track["external_urls"].get("spotify")
                self._get_current_track_lastfm_customfm(title, artists, album, image_url, params, player=current_player, youtube_url=youtube_url)
                return
            
            # Verificar se o player é suportado (agora com suporte ao Last.fm)
            if player in ["Spotify", "SoundCloud", "exteraGram", "AyuGram", "Apple Music"] or force_spotify:
                self._generate_apple_unified_card(track, params, progress_ms, force_spotify, etg_cover_image)
            else:
                # Fallback para CustomFM apenas se player não suportado
                log(f"[NowFy] Apple theme fallback - Player: {player} not supported")
                title = track["name"]
                artists = ", ".join([a["name"] for a in track["artists"]])
                album = track["album"]["name"] if track.get("album") else ""
                images = track["album"].get("images", [])
                image_url = max(images, key=lambda i: i.get("width", 0))["url"] if images else None
                youtube_url = track["external_urls"].get("spotify")
                current_player = self._detect_current_player()
                self._get_current_track_lastfm_customfm(title, artists, album, image_url, params, player=current_player, youtube_url=youtube_url)
                return
        elif theme >= 1 and external_themes:  # Temas externos (índice 1+)
            # Calcular qual tema externo usar
            external_theme_index = theme - 1
            external_theme_ids = list(external_themes.keys())
            if external_theme_index < len(external_theme_ids):
                theme_id = external_theme_ids[external_theme_index]
                log(f"[NowFy] Using external theme: {theme_id} (index: {external_theme_index})")
                self._generate_external_theme_card(track, params, progress_ms, theme_id, external_themes[theme_id], force_spotify)
            else:
                # Se o índice for maior que o número de temas externos, verificar Vinni, Spotlight, CustomFM ou Minimal
                vinni_index = 1 + len(external_themes)
                spotlight_index = vinni_index + 1
                customfm_index = spotlight_index + 1
                minimal_index = customfm_index + 1
                log(f"[NowFy] Checking theme {theme} against Vinni index {vinni_index}, CustomFM index {customfm_index}")
                if theme == vinni_index:  # Vinify (anteriormente Vinni)
                    # Verificar se o player atual é suportado pelo tema Vinify
                    current_player = self._detect_current_player()
                    supported_players = ["Spotify", "Apple Music", "YouTube", "YouTube Music", "SoundCloud", "Yandex Music", "FM", "AyuGram", "exteraGram"]
                    
                    if current_player in supported_players:
                        # Para Spotify, Apple Music, YouTube, YouTube Music e SoundCloud, usar o tema Vinify
                        self._generate_vinni_card(track, params, progress_ms, force_spotify, etg_cover_image, is_fm_command)
                    else:
                        # Para outros players, fazer fallback para CustomFM
                        log(f"[NowFy] Player {current_player} não suportado pelo tema Vinify, usando CustomFM como fallback")
                        title = track["name"]
                        artists = ", ".join([a["name"] for a in track["artists"]])
                        album = track["album"]["name"] if track.get("album") else ""
                        images = track["album"].get("images", [])
                        image_url = max(images, key=lambda i: i.get("width", 0))["url"] if images else None
                        player = "Spotify" if force_spotify else current_player
                        youtube_url = track["external_urls"].get("spotify")
                        self._get_current_track_lastfm_customfm(title, artists, album, image_url, params, player=player, youtube_url=youtube_url)
                        return
                elif theme == spotlight_index:  # Spotlight
                    # Verificar se o player atual é suportado pelo tema Spotlight
                    current_player = self._detect_current_player()
                    supported_players = ["Spotify", "Apple Music", "FM"]
                    
                    if current_player in supported_players or (current_player and ".fm" in current_player.lower()):
                        # Para Spotify e Apple Music, usar o tema Spotlight
                        self._generate_spotlight_card(track, params, progress_ms, force_spotify, etg_cover_image)
                    else:
                        # Para outros players, fazer fallback para CustomFM
                        log(f"[NowFy] Player {current_player} não suportado pelo tema Spotlight, usando CustomFM como fallback")
                        title = track["name"]
                        artists = ", ".join([a["name"] for a in track["artists"]])
                        album = track["album"]["name"] if track.get("album") else ""
                        images = track["album"].get("images", [])
                        image_url = max(images, key=lambda i: i.get("width", 0))["url"] if images else None
                        player = "Spotify" if force_spotify else current_player
                        youtube_url = track["external_urls"].get("spotify")
                        self._get_current_track_lastfm_customfm(title, artists, album, image_url, params, player=player, youtube_url=youtube_url)
                        return
                elif theme == customfm_index:  # CustomFM
                    # Extrair informações da faixa
                    title = track["name"]
                    artists = ", ".join([a["name"] for a in track["artists"]])
                    album = track["album"]["name"] if track.get("album") else ""
                    images = track["album"].get("images", [])
                    image_url = max(images, key=lambda i: i.get("width", 0))["url"] if images else None
                    player = "Spotify" if force_spotify else self._detect_current_player()
                    youtube_url = track["external_urls"].get("spotify")
                    self._get_current_track_lastfm_customfm(title, artists, album, image_url, params, player=player, youtube_url=youtube_url)
                    return
                elif theme == minimal_index:  # Minimal
                    self._generate_minimal_card(track, params, force_spotify, etg_cover_image)
                else:
                    log(f"[NowFy] Theme index out of range: {theme}")
                    self._generate_apple_light_card(track, params, progress_ms, force_spotify, etg_cover_image)
        elif theme == 1 + len(external_themes):  # Spotlight (quando não há temas externos)
            log(f"[NowFy] Using Spotlight theme (no external themes case) - theme: {theme}")
            # Verificar se o player atual é suportado pelo tema Spotlight
            current_player = self._detect_current_player()
            supported_players = ["Spotify", "Apple Music", "FM"]
            
            if current_player in supported_players or (current_player and ".fm" in current_player.lower()):
                # Para Spotify e Apple Music, usar o tema Spotlight
                self._generate_spotlight_card(track, params, progress_ms, force_spotify, etg_cover_image)
            else:
                # Para outros players, fazer fallback para CustomFM
                log(f"[NowFy] Player {current_player} não suportado pelo tema Spotlight, usando CustomFM como fallback")
                title = track["name"]
                artists = ", ".join([a["name"] for a in track["artists"]])
                album = track["album"]["name"] if track.get("album") else ""
                images = track["album"].get("images", [])
                image_url = max(images, key=lambda i: i.get("width", 0))["url"] if images else None
                player = "Spotify" if force_spotify else current_player
                youtube_url = track["external_urls"].get("spotify")
                self._get_current_track_lastfm_customfm(title, artists, album, image_url, params, player=player, youtube_url=youtube_url)
                return
        elif theme == 2 + len(external_themes):  # Vinify (quando não há temas externos)
            log(f"[NowFy] Using Vinify theme (no external themes case) - theme: {theme}")
            # Verificar se o player atual é suportado pelo tema Vinify
            current_player = self._detect_current_player()
            supported_players = ["Spotify", "Apple Music", "YouTube", "YouTube Music", "SoundCloud", "Yandex Music", "FM", "AyuGram", "exteraGram"]
            
            if current_player in supported_players:
                # Para Spotify, Apple Music, YouTube, YouTube Music e SoundCloud, usar o tema Vinify
                self._generate_vinni_card(track, params, progress_ms, force_spotify, etg_cover_image, is_fm_command)
            else:
                # Para outros players, fazer fallback para CustomFM
                log(f"[NowFy] Player {current_player} não suportado pelo tema Vinify, usando CustomFM como fallback")
                title = track["name"]
                artists = ", ".join([a["name"] for a in track["artists"]])
                album = track["album"]["name"] if track.get("album") else ""
                images = track["album"].get("images", [])
                image_url = max(images, key=lambda i: i.get("width", 0))["url"] if images else None
                player = "Spotify" if force_spotify else current_player
                youtube_url = track["external_urls"].get("spotify")
                self._get_current_track_lastfm_customfm(title, artists, album, image_url, params, player=player, youtube_url=youtube_url)
                return
        elif theme == 3 + len(external_themes):  # Nowv (quando não há temas externos)
            log(f"[NowFy] Using Nowv theme (no external themes case) - theme: {theme}")
            current_player = self._detect_current_player()
            supported_players = ["Spotify", "Apple Music", "YouTube", "YouTube Music", "SoundCloud", "Yandex Music", "FM", "exteraGram", "AyuGram", "Telegram"]
            if current_player in supported_players:
                self._generate_nowv_card(track, params, progress_ms, force_spotify, etg_cover_image, is_fm_command)
            else:
                log(f"[NowFy] Player {current_player} não suportado pelo tema Nowv, usando CustomFM como fallback")
                title = track["name"]
                artists = ", ".join([a["name"] for a in track["artists"]])
                album = track["album"]["name"] if track.get("album") else ""
                images = track["album"].get("images", [])
                image_url = max(images, key=lambda i: i.get("width", 0))["url"] if images else None
                player = "Spotify" if force_spotify else current_player
                youtube_url = track["external_urls"].get("spotify")
                self._get_current_track_lastfm_customfm(title, artists, album, image_url, params, player=player, youtube_url=youtube_url)
                return
        elif theme == 4 + len(external_themes):  # CustomFM (quando não há temas externos)
            log(f"[NowFy] Using CustomFM theme (no external themes case) - theme: {theme}")
            # Extrair informações da faixa
            title = track["name"]
            artists = ", ".join([a["name"] for a in track["artists"]])
            album = track["album"]["name"] if track.get("album") else ""
            images = track["album"].get("images", [])
            image_url = max(images, key=lambda i: i.get("width", 0))["url"] if images else None
            player = "Spotify" if force_spotify else self._detect_current_player()
            youtube_url = track["external_urls"].get("spotify")
            self._get_current_track_lastfm_customfm(title, artists, album, image_url, params, player=player, youtube_url=youtube_url)
            return
        elif theme == 5 + len(external_themes):  # Minimal (quando não há temas externos)
            log(f"[NowFy] Using Minimal theme (no external themes case) - theme: {theme}")
            self._generate_minimal_card(track, params, force_spotify, etg_cover_image)
        else:
            # Verificar se é SoundCloud antes de usar Apple Light como fallback
            player = "Spotify" if force_spotify else self._detect_current_player()
            if player == "SoundCloud":
                log(f"[NowFy] Apple Light blocked for SoundCloud as requested (fallback case)")
                # Usar CustomFM como fallback para SoundCloud
                title = track["name"]
                artists = ", ".join([a["name"] for a in track["artists"]])
                album = track["album"]["name"] if track.get("album") else ""
                images = track["album"].get("images", [])
                image_url = max(images, key=lambda i: i.get("width", 0))["url"] if images else None
                youtube_url = track["external_urls"].get("spotify")
                self._get_current_track_lastfm_customfm(title, artists, album, image_url, params, player=player, youtube_url=youtube_url)
            else:
                self._generate_apple_light_card(track, params, progress_ms, force_spotify, etg_cover_image)

    def _generate_spotlight_card(self, track, params=None, progress_ms=None, force_spotify=False, etg_cover_image=None):
        """Gera card do tema Spotlight com design minimalista - fundo branco, apenas mini capa e barra de progresso"""
        try:
            # Obter configurações da skin do Spotlight
            spotlight_skin = self.get_setting("spotlight_skin", 0)
            skin_config = SPOTLIGHT_SKIN_STYLE.get(spotlight_skin, SPOTLIGHT_SKIN_STYLE[0])
            
            # Criar imagem base 567x614 com cor de fundo baseada na skin
            bg_color = skin_config.get("bg_color", (255, 255, 255))
            img = Image.new("RGB", (567, 614), bg_color)
            
            title = track["name"]
            artists = ", ".join([a["name"] for a in track["artists"]])
            
            # Obter capa do álbum
            if etg_cover_image is not None:
                cover_image = etg_cover_image
            else:
                # Detectar player atual
                player_name = self._detect_current_player()
                
                # Lógica dedicada para Yandex Music com capa YouTube-first
                if player_name == "Yandex Music":
                    youtube_cover_url = self._get_youtube_cover(title, artists)
                    if youtube_cover_url == "https://i.postimg.cc/4yjVLFTV/icondefault.png":
                        youtube_cover_url = self._get_youtube_thumbnail_forced(title, artists)
                    try:
                        cover_data = self._get_cached_image_enhanced(youtube_cover_url, f"yt_cover_{hash(youtube_cover_url)}")
                        if cover_data:
                            cover_image = Image.open(BytesIO(cover_data)).convert("RGBA")
                        else:
                            raise Exception("Failed to download cover from cache")
                    except Exception as e:
                        log(f"Erro ao carregar capa do YouTube para Yandex: {e}")
                        cover_image = self._get_fallback_cover(title, artists)
                elif player_name == "SoundCloud":
                    youtube_cover_url = self._get_youtube_cover(title, artists)
                    if youtube_cover_url == "https://i.postimg.cc/4yjVLFTV/icondefault.png":
                        youtube_cover_url = self._get_youtube_thumbnail_forced(title, artists)
                    try:
                        cover_data = self._get_cached_image_enhanced(youtube_cover_url, f"yt_cover_{hash(youtube_cover_url)}")
                        if cover_data:
                            cover_image = Image.open(BytesIO(cover_data)).convert("RGBA")
                        else:
                            raise Exception("Failed to download cover from cache")
                    except Exception as e:
                        log(f"Erro ao carregar capa do YouTube para SoundCloud: {e}")
                        cover_image = self._get_fallback_cover(title, artists)
                else:
                    # Lógica para obter capa via imagens do álbum e fallback
                    images = track["album"].get("images", [])
                    cover_url = max(images, key=lambda i: i.get("width", 0))["url"] if images else None
                    if cover_url:
                        try:
                            cover_data = self._get_cached_image_enhanced(cover_url, f"album_cover_{hash(cover_url)}")
                            if cover_data:
                                cover_image = Image.open(BytesIO(cover_data)).convert("RGBA")
                            else:
                                raise Exception("Failed to download cover from cache")
                        except Exception as e:
                            cover_image = self._get_fallback_cover(title, artists)
                    else:
                        cover_image = self._get_fallback_cover(title, artists)
            
            # Se a capa carregada for pequena, tentar upgrade com YouTube
            if cover_image and (cover_image.width < 457 or cover_image.height < 457):
                try:
                    yt_url_upgrade = self._get_youtube_cover(title, artists)
                    if yt_url_upgrade == "https://i.postimg.cc/4yjVLFTV/icondefault.png":
                        yt_url_upgrade = self._get_youtube_thumbnail_forced(title, artists)
                    cover_data_upgrade = self._get_cached_image_enhanced(yt_url_upgrade, f"yt_cover_{hash(yt_url_upgrade)}")
                    if cover_data_upgrade:
                        cover_image = Image.open(BytesIO(cover_data_upgrade)).convert("RGBA")
                except Exception as e:
                    log(f"Upgrade de capa YouTube falhou: {e}")
            
            # Redimensionar mini capa para 457x457 com bordas arredondadas
            if cover_image:
                from PIL import ImageOps
                mini_cover = ImageOps.fit(cover_image, (457, 457), method=Image.LANCZOS, centering=(0.5, 0.5))
                
                # Se for a variação Blur, aplicar blur simples na capa como fundo
                if skin_config.get("use_blur_bg", False):
                    # Criar fundo blur da capa
                    blur_bg = cover_image.resize((567, 614), Image.LANCZOS)
                    blur_bg = blur_bg.filter(ImageFilter.GaussianBlur(radius=15))
                    
                    # Aplicar overlay escuro para escurecer o background
                    dark_overlay = Image.new('RGBA', (567, 614), (0, 0, 0, 150))
                    blur_bg = Image.alpha_composite(blur_bg.convert('RGBA'), dark_overlay)
                    
                    # Usar o fundo blur escurecido
                    img = blur_bg.convert("RGB")
                
                # Aplicar bordas arredondadas
                mini_cover = self._apply_rounded_corners(mini_cover, radius=20)
                
                # Posicionar mini capa centralizada horizontalmente e um pouco mais baixo
                cover_x = (567 - 457) // 2  # Centralizar horizontalmente
                cover_y = 50  # Posição mais baixa para centralizar com a barra
                img.paste(mini_cover, (cover_x, cover_y), mini_cover)
            
            draw = ImageDraw.Draw(img)
            
            # Configurar fonte apenas para a barra de progresso
            try:
                font_time = ImageFont.truetype("SourceSansPro-Regular.ttf", 14)
            except Exception:
                font_time = ImageFont.load_default()
            
            # Barra de progresso "spotibar" abaixo da capa
            if progress_ms is not None and track.get("duration_ms"):
                progress_y = cover_y + 457 + 49  # 40px abaixo da capa
                self._draw_spotibar(draw, img, progress_ms, track["duration_ms"], progress_y, font_time)
            
            # Salvar imagem
            output_path = File(ApplicationLoader.getFilesDirFixed(), "nowfy_spotlight_card.png")
            img.save(output_path.getAbsolutePath(), "PNG")
            
            # Enviar mensagem
            self._send_card_with_caption(params, output_path.getAbsolutePath(), track)
            
        except Exception as e:
            log(f"Erro ao gerar card Spotlight: {e}")
            import traceback
            traceback.print_exc()
    
    def _apply_rounded_corners(self, image, radius):
        """Aplica bordas arredondadas à imagem"""
        # Criar máscara com bordas arredondadas
        mask = Image.new("L", image.size, 0)
        draw = ImageDraw.Draw(mask)
        draw.rounded_rectangle([(0, 0), image.size], radius=radius, fill=255)
        
        # Aplicar máscara
        result = Image.new("RGBA", image.size, (0, 0, 0, 0))
        result.paste(image, (0, 0))
        result.putalpha(mask)
        
        return result
    
    def _draw_spotibar(self, draw, image, progress_ms, duration_ms, y_position, font_time):
        """Desenha a barra de progresso spotibar com tempos ao lado da barra"""
        # Obter configurações da skin do Spotlight
        spotlight_skin = self.get_setting("spotlight_skin", 0)
        skin_config = SPOTLIGHT_SKIN_STYLE.get(spotlight_skin, SPOTLIGHT_SKIN_STYLE[0])
        
        # Configurações da barra - largura igual à capa (457px)
        cover_width = 457  # Largura da capa
        bar_width = 350    # Largura da barra (menor que a capa para dar espaço aos tempos)
        bar_height = 8     # Altura normal, não muito fina
        
        # Tempos
        current_time = self._format_time(progress_ms)
        total_time = self._format_time(duration_ms)
        
        # Usar fonte padrão SourceSansPro
        try:
            font_default = ImageFont.truetype("/system/fonts/SourceSansPro-Regular.ttf", 24)
        except Exception:
            font_default = font_time  # Fallback para fonte padrão
        
        # Calcular larguras dos tempos para posicionamento
        try:
            current_width = draw.textlength(current_time, font=font_default)
            total_width = draw.textlength(total_time, font=font_default)
        except:
            try:
                left, top, right, bottom = font_default.getbbox(current_time)
                current_width = right - left
                left, top, right, bottom = font_default.getbbox(total_time)
                total_width = right - left
            except:
                current_width = len(current_time) * 8  # Estimativa
                total_width = len(total_time) * 8
        
        # Posicionamento dentro da margem da capa (457px)
        cover_x = (567 - cover_width) // 2  # Posição da capa
        spacing = 15  # Espaçamento entre tempo e barra
        
        # Centralizar tudo dentro da largura da capa
        total_width_needed = current_width + spacing + bar_width + spacing + total_width
        start_x = cover_x + (cover_width - total_width_needed) // 2
        
        # Posições
        current_x = start_x
        bar_x = current_x + current_width + spacing
        total_x = bar_x + bar_width + spacing
        bar_offset = 5  # Ajuste independente da barra (+ para baixo, - para cima)
        bar_y = y_position + bar_offset
        
        # Calcular progresso
        progress_ratio = min(progress_ms / duration_ms, 1.0) if duration_ms > 0 else 0
        progress_width = int(bar_width * progress_ratio)
        
        # Desenhar barra de fundo com efeito glass (blur + overlay semi-transparente escuro)
        if skin_config.get("use_blur_bg", False):
            try:
                # Extrair a área da imagem onde a barra será desenhada
                blur_area = image.crop((
                    bar_x, bar_y, 
                    bar_x + bar_width, bar_y + bar_height
                ))

                # Aplicar blur na área extraída para suavizar o fundo
                blurred_area = blur_area.filter(ImageFilter.GaussianBlur(radius=10))

                # Criar uma sobreposição translúcida escura para efeito vidro fosco
                overlay = Image.new('RGBA', (bar_width, bar_height), (30, 30, 30, 120))  # Cinza escuro semi-transparente

                # Combinar blur com overlay escura
                glass_effect = Image.alpha_composite(blurred_area.convert('RGBA'), overlay)

                # Criar máscara com cantos arredondados para a barra
                mask = Image.new('L', (bar_width, bar_height), 0)
                mask_draw = ImageDraw.Draw(mask)
                mask_draw.rounded_rectangle(
                    [(0, 0), (bar_width - 1, bar_height - 1)],
                    radius=4,
                    fill=255
                )

                # Aplicar máscara para manter cantos arredondados
                glass_effect.putalpha(mask)

                # Colar efeito vidro na imagem principal
                image.paste(glass_effect, (bar_x, bar_y), glass_effect)

            except Exception as e:
                # Fallback para cor sólida mais clara e transparente
                draw.rounded_rectangle(
                    [(bar_x, bar_y), (bar_x + bar_width, bar_y + bar_height)],
                    radius=4,
                    fill=(60, 60, 60, 100)  # Menos opaco que antes
                )
        else:
            # Cor sólida normal (sem blur)
            draw.rounded_rectangle(
                [(bar_x, bar_y), (bar_x + bar_width, bar_y + bar_height)],
                radius=4,
                fill=skin_config["bar_bg_color"]
            )
        
        # Desenhar barra de progresso
        if progress_width > 0:
            draw.rounded_rectangle(
                [(bar_x, bar_y), (bar_x + progress_width, bar_y + bar_height)],
                radius=4,
                fill=skin_config["bar_fill_color"]
            )
        
        # Posicionar tempos independentemente da barra
        try:
            left, top, right, bottom = font_default.getbbox("0")
            text_height = bottom - top
        except:
            text_height = 24  # Altura estimada
        text_y = y_position + (bar_height - text_height) // 2  # Usar posição original dos tempos
        
        # Tempo atual (esquerda)
        draw.text((current_x, text_y), current_time, font=font_default, fill=skin_config["time_color"])
        
        # Tempo total (direita)
        draw.text((total_x, text_y), total_time, font=font_default, fill=skin_config["time_color"])
    
    def _format_time(self, ms):
        """Formata tempo em milissegundos para mm:ss"""
        if ms is None:
            return "0:00"
        seconds = int(ms / 1000)
        minutes = seconds // 60
        seconds = seconds % 60
        return f"{minutes}:{seconds:02d}"
    
    def _get_universal_youtube_key(self):
        """Key Universal UT - Experimental"""
        # Chave criptografada com XOR + base64
        _encrypted_key = "a2NQS3lTaX1nYB17dXx8RUZ8SUFQRmV4YU1vZXtgRVNGcmRGfERJ"
        _xor_salt = 42
        
        try:
            # Decodifica base64 e aplica XOR reverso
            encrypted_bytes = base64.b64decode(_encrypted_key)
            decrypted = ''.join(chr(b ^ _xor_salt) for b in encrypted_bytes)
            return decrypted
        except Exception:
            # Fallback em caso de erro na descriptografia
            return "AIzaSyCWMJ7Q_VVolVckzlORKgEOQJoylXNlVnc"

    def _generate_vinni_card(self, track, params=None, progress_ms=None, force_spotify=False, etg_cover_image=None, is_fm_command=False):
        """Gera card do tema Vinni com design personalizado - dimensões 1012x512"""
        try:
            # Criar imagem base 1012x512
            img = Image.new("RGB", (1012, 512), (0, 0, 0))
            
            title = track["name"]
            artists = ", ".join([a["name"] for a in track["artists"]])
            
            # Obter capa do álbum
            if etg_cover_image is not None:
                cover_image = etg_cover_image
            else:
                # Detectar player atual
                player_name = self._detect_current_player()

                # FM (Active Player) - suportar Vinify como SoundCloud
                if player_name == "FM":
                    images = track.get("album", {}).get("images", [])
                    cover_url = max(images, key=lambda i: i.get("width", 0)).get("url") if images else None
                    if cover_url:
                        try:
                            cover_data = self._get_cached_image_enhanced(cover_url, f"album_cover_{hash(cover_url)}")
                            if cover_data:
                                cover_image = Image.open(BytesIO(cover_data)).convert("RGBA")
                            else:
                                raise Exception("Failed to download cover from cache")
                        except Exception:
                            # Fallback YouTube-first unificado para FM
                            cover_image = self._get_fallback_cover(title, artists)
                    else:
                        # Fallback YouTube-first unificado para FM
                        cover_image = self._get_fallback_cover(title, artists)
                elif player_name in ("YouTube", "YouTube Music", "Yandex Music"):
                    youtube_cover_url = self._get_youtube_cover(title, artists)
                    if youtube_cover_url == "https://i.postimg.cc/4yjVLFTV/icondefault.png":
                        youtube_cover_url = self._get_youtube_thumbnail_forced(title, artists)
                    try:
                        cover_data = self._get_cached_image_enhanced(youtube_cover_url, f"yt_cover_{hash(youtube_cover_url)}")
                        if cover_data:
                            cover_image = Image.open(BytesIO(cover_data)).convert("RGBA")
                        else:
                            raise Exception("Failed to download cover from cache")
                    except Exception as e:
                        log(f"Erro ao carregar capa do YouTube para {player_name}: {e}")
                        cover_image = Image.new("RGBA", (375, 375), (30, 30, 30, 255))
                elif player_name == "SoundCloud":
                    youtube_cover_url = self._get_youtube_cover(title, artists)
                    if youtube_cover_url == "https://i.postimg.cc/4yjVLFTV/icondefault.png":
                        youtube_cover_url = self._get_youtube_thumbnail_forced(title, artists)
                    try:
                        cover_data = self._get_cached_image_enhanced(youtube_cover_url, f"yt_cover_{hash(youtube_cover_url)}")
                        if cover_data:
                            cover_image = Image.open(BytesIO(cover_data)).convert("RGBA")
                        else:
                            raise Exception("Failed to download cover from cache")
                    except Exception as e:
                        log(f"Erro ao carregar capa do YouTube para SoundCloud: {e}")
                        cover_image = Image.new("RGBA", (375, 375), (30, 30, 30, 255))
                else:
                    # Lógica para outros players
                    images = track["album"].get("images", [])
                    cover_url = max(images, key=lambda i: i.get("width", 0))["url"] if images else None
                    if cover_url:
                        try:
                            cover_data = self._get_cached_image_enhanced(cover_url, f"album_cover_{hash(cover_url)}")
                            if cover_data:
                                cover_image = Image.open(BytesIO(cover_data)).convert("RGBA")
                            else:
                                raise Exception("Failed to download cover from cache")
                        except Exception:
                            cover_image = self._get_fallback_cover(title, artists)
                    else:
                        cover_image = self._get_fallback_cover(title, artists)
            
            # Armazenar a capa para uso no gradiente da barra de progresso
            self._current_album_cover = cover_image
            
            # Criar fundo com base nas novas opções do Vinify UI
            if cover_image:
                # Determinar imagem de fundo: BG Style, Custom BG ou capa
                custom_bg_enabled = self.get_setting("vinify_custom_bg_enable", False)
                custom_bg_url = self.get_setting("vinify_custom_bg_url", "").strip()
                bg_style = self.get_setting("vinify_bg_style", 0)  # 0=None, 1=Obsidian, 2=Morph, 3=Noir, 4=Ethereal, 5=Ethereal Mirage, 6=Silken, 7=Mock, 8=Random
                shadow_style = self.get_setting("vinify_shadow_style", 0)  # 0=None, 1=Black, 2=White, 3=Gradient

                bg_image = None
                style_url = None
                if bg_style == 1:
                    style_url = "https://raw.githubusercontent.com/soumaki/nowFy/refs/heads/main/bg/Obsidian.png"
                elif bg_style == 2:
                    style_url = "https://raw.githubusercontent.com/soumaki/nowFy/refs/heads/main/bg/Morph.png"
                elif bg_style == 3:
                    style_url = "https://raw.githubusercontent.com/soumaki/nowFy/refs/heads/main/bg/Noir.png"
                elif bg_style == 4:
                    style_url = "https://raw.githubusercontent.com/soumaki/nowFy/refs/heads/main/bg/Ethereal.png"
                elif bg_style == 5:
                    style_url = "https://raw.githubusercontent.com/soumaki/nowFy/refs/heads/main/bg/Ethereal%20Mirage.png"
                elif bg_style == 6:
                    style_url = "https://raw.githubusercontent.com/soumaki/nowFy/refs/heads/main/bg/Silken.png"
                elif bg_style == 7:
                    style_url = "https://raw.githubusercontent.com/soumaki/nowFy/refs/heads/main/bg/Mock.png"
                elif bg_style == 8:
                    try:
                        import random
                        rand_style = random.choice([1, 2, 3, 4, 5, 6, 7])
                        if rand_style == 1:
                            style_url = "https://raw.githubusercontent.com/soumaki/nowFy/refs/heads/main/bg/Obsidian.png"
                        elif rand_style == 2:
                            style_url = "https://raw.githubusercontent.com/soumaki/nowFy/refs/heads/main/bg/Morph.png"
                        elif rand_style == 3:
                            style_url = "https://raw.githubusercontent.com/soumaki/nowFy/refs/heads/main/bg/Noir.png"
                        elif rand_style == 4:
                            style_url = "https://raw.githubusercontent.com/soumaki/nowFy/refs/heads/main/bg/Ethereal.png"
                        elif rand_style == 5:
                            style_url = "https://raw.githubusercontent.com/soumaki/nowFy/refs/heads/main/bg/Ethereal%20Mirage.png"
                        elif rand_style == 6:
                            style_url = "https://raw.githubusercontent.com/soumaki/nowFy/refs/heads/main/bg/Silken.png"
                        else:
                            style_url = "https://raw.githubusercontent.com/soumaki/nowFy/refs/heads/main/bg/Mock.png"
                    except Exception as e:
                        log(f"[NowFy] Random BG selection failed: {e}")
                        style_url = None

                if style_url:
                    try:
                        style_data = self._get_cached_image_enhanced(style_url, f"vinify_bg_style_{bg_style}")
                        if style_data:
                            bg_image = Image.open(BytesIO(style_data)).convert("RGBA")
                    except Exception as e:
                        log(f"[NowFy] Falha ao carregar BG Style: {e}")
                        bg_image = None
                elif custom_bg_enabled and custom_bg_url:
                    try:
                        custom_data = self._get_cached_image_enhanced(custom_bg_url, f"vinify_custom_bg_{hash(custom_bg_url)}")
                        if custom_data:
                            bg_image = Image.open(BytesIO(custom_data)).convert("RGBA")
                    except Exception as e:
                        log(f"[NowFy] Falha ao carregar Custom BG: {e}")
                        bg_image = None

                # Fallback para capa do álbum se não houver imagem de fundo definida
                if bg_image is None:
                    bg_image = cover_image

                # Redimensionar imagem de fundo para cobrir todo o fundo 1012x512 mantendo proporção
                background_cover = self._resize_with_aspect_ratio_vinni(bg_image, (1012, 512))
                
                # Aplicar flip horizontal se ativado
                flip_background = self.get_setting("vinify_flip_background", False)
                if flip_background:
                    background_cover = background_cover.transpose(Image.FLIP_LEFT_RIGHT)
                
                # Obter configuração do efeito de fundo
                background_effect = self.get_setting("vinify_background_effect", 0)
                
                # Aplicar efeitos baseados na seleção
                if background_effect == 1:  # Album Colors (Cores do Álbum)
                    # Extrair cores dominantes da capa e criar um fundo gradiente conforme o modo escolhido
                    try:
                        import random
                        # Redimensionar a capa para análise mais rápida
                        small_cover = cover_image.resize((50, 50), Image.LANCZOS)
                        # Converter para RGB se necessário
                        if small_cover.mode != 'RGB':
                            small_cover = small_cover.convert('RGB')
                        
                        # Extrair cores dominantes usando quantização
                        quantized = small_cover.quantize(colors=4)
                        palette = quantized.getpalette()
                        
                        # Obter as 4 cores mais dominantes
                        colors = []
                        for i in range(4):
                            r = palette[i*3]
                            g = palette[i*3 + 1]
                            b = palette[i*3 + 2]
                            colors.append((r, g, b))
                        # Garantir 4 cores
                        while len(colors) < 4:
                            colors.append(colors[-1])
                        
                        # Função de interpolação de cor
                        def interp_color(cs, t):
                            t = max(0.0, min(1.0, t))
                            if t > 0.75:
                                return cs[0]
                            elif t > 0.5:
                                tt = (t - 0.5) / 0.25
                                return tuple(int(cs[0][i] * tt + cs[1][i] * (1 - tt)) for i in range(3))
                            elif t > 0.25:
                                tt = (t - 0.25) / 0.25
                                return tuple(int(cs[1][i] * tt + cs[2][i] * (1 - tt)) for i in range(3))
                            else:
                                tt = t / 0.25
                                return tuple(int(cs[2][i] * tt + cs[3][i] * (1 - tt)) for i in range(3))
                        
                        # Novo seletor de efeitos
                        mode = self.get_setting("vinify_colors_effect", 0)  # 0=Random, 1=Diagonal, 2=Top to Bottom
                        if mode == 0:
                            mode = random.choice([1, 2])
                        
                        if mode == 2:
                            # Top to Bottom: gradiente vertical
                            color_bg = Image.new('RGB', (1012, 512), colors[0])
                            draw = ImageDraw.Draw(color_bg)
                            for y in range(512):
                                ratio = y / 512.0
                                color = interp_color(colors, ratio)
                                draw.line([(0, y), (1012, y)], fill=color)
                        elif mode == 1:
                            # Diagonal: linhas diagonais de topo-esquerda a base-direita
                            color_bg = Image.new('RGB', (1012, 512), colors[0])
                            draw = ImageDraw.Draw(color_bg)
                            total = 1012 + 512
                            for d in range(-512, 1012):
                                t = (d + 512) / float(total)
                                color = interp_color(colors, t)
                                x1 = max(0, d)
                                y1 = 0
                                x2 = min(1012, d + 512)
                                y2 = 512
                                draw.line([(x1, y1), (x2, y2)], fill=color)
                        else:
                            # Fallback: gradiente radial (compatível)
                            color_bg = Image.new('RGB', (1012, 512), colors[0])
                            draw = ImageDraw.Draw(color_bg)
                            center_x, center_y = 506, 256
                            max_radius = 600
                            for radius in range(max_radius, 0, -8):
                                ratio = radius / max_radius
                                color = interp_color(colors, ratio)
                                bbox = [center_x - radius, center_y - radius, center_x + radius, center_y + radius]
                                draw.ellipse(bbox, fill=color)
                        
                        # Aplicar overlay escuro para garantir legibilidade do texto
                        overlay = Image.new("RGBA", (1012, 512), (0, 0, 0, 100))  # 40% de opacidade
                        color_bg = color_bg.convert("RGBA")
                        img = Image.alpha_composite(color_bg, overlay).convert("RGB")
                        
                    except Exception as e:
                        log(f"[NowFy] Erro ao aplicar efeito Album Colors: {e}")
                        # Fallback para gradiente padrão colorido
                        fallback_bg = Image.new('RGB', (1012, 512), (60, 60, 120))
                        draw = ImageDraw.Draw(fallback_bg)
                        for y in range(512):
                            ratio = y / 512
                            color = (int(60 + ratio * 100), int(60 + ratio * 80), int(120 + ratio * 60))
                            draw.line([(0, y), (1012, y)], fill=color)
                        overlay = Image.new("RGBA", (1012, 512), (0, 0, 0, 100))
                        fallback_bg = fallback_bg.convert("RGBA")
                        img = Image.alpha_composite(fallback_bg, overlay).convert("RGB")
                        
                elif background_effect == 2:  # Blur
                    background_cover = background_cover.filter(ImageFilter.GaussianBlur(radius=15))
                    img = background_cover.convert("RGB")
                elif background_effect == 3:  # Darker
                    # Aplicar escurecimento sutil (overlay escuro 30%)
                    overlay = Image.new("RGBA", (1012, 512), (0, 0, 0, 77))  # 30% de opacidade
                    background_cover = background_cover.convert("RGBA")
                    background_cover = Image.alpha_composite(background_cover, overlay)
                    img = background_cover.convert("RGB")
                elif background_effect == 4:  # Both (Blur + Darker)
                    # Aplicar blur
                    background_cover = background_cover.filter(ImageFilter.GaussianBlur(radius=15))
                    # Aplicar escurecimento (overlay escuro 40%)
                    overlay = Image.new("RGBA", (1012, 512), (0, 0, 0, 102))  # 40% de opacidade
                    background_cover = background_cover.convert("RGBA")
                    background_cover = Image.alpha_composite(background_cover, overlay)
                    img = background_cover.convert("RGB")
                else:  # None (0)
                    # Aplicar escurecimento muito sutil para não ficar muito claro
                    overlay = Image.new("RGBA", (1012, 512), (0, 0, 0, 25))  # 10% de opacidade
                    background_cover = background_cover.convert("RGBA")
                    background_cover = Image.alpha_composite(background_cover, overlay)
                    img = background_cover.convert("RGB")
                
                # Aplicar overlay de Shadow sobre o fundo (após o efeito)
                if shadow_style in (1, 2, 3):
                    shadow_urls = {
                        1: "https://raw.githubusercontent.com/soumaki/nowFy/refs/heads/main/bg/shadow.png",
                        2: "https://raw.githubusercontent.com/soumaki/nowFy/refs/heads/main/bg/shadow_white.png",
                        3: "https://raw.githubusercontent.com/soumaki/nowFy/refs/heads/main/bg/shadow_gradient.png"
                    }
                    shadow_url = shadow_urls.get(shadow_style)
                    try:
                        shadow_data = self._get_cached_image_enhanced(shadow_url, f"vinify_shadow_{shadow_style}")
                        if shadow_data:
                            shadow_img = Image.open(BytesIO(shadow_data)).convert("RGBA")
                            if shadow_img.size != (1012, 512):
                                shadow_img = shadow_img.resize((1012, 512), Image.LANCZOS)
                            base_rgba = img.convert("RGBA")
                            img = Image.alpha_composite(base_rgba, shadow_img).convert("RGB")
                    except Exception as e:
                        log(f"[NowFy] Falha ao aplicar Shadow overlay: {e}")
                
                # Verificar se o swap layout está habilitado
                swap_layout = self.get_setting("vinify_swap_layout", False)
                
                # Redimensionar capa para 375x375 mantendo proporção (corte central)
                try:
                    cover_display = ImageOps.fit(cover_image, (375, 375), method=Image.LANCZOS, centering=(0.5, 0.5))
                except Exception:
                    # Fallback em caso de erro: usar resize padrão
                    cover_display = cover_image.resize((375, 375), Image.LANCZOS)
                
                # Aplicar bordas arredondadas na capa
                mask = Image.new("L", (375, 375), 0)
                ImageDraw.Draw(mask).rounded_rectangle((0, 0, 375, 375), 25, fill=255)
                cover_display = cover_display.convert("RGBA")
                cover_display.putalpha(mask)
                
                # Posicionar capa baseado no swap layout
                if swap_layout:
                    # Capa à direita
                    cover_x = 1012 - 60 - 375  # Margem direita de 60px
                    img.paste(cover_display, (cover_x, 68), cover_display)
                    # Área de texto à esquerda
                    text_x = 60  # Margem esquerda
                    text_width = cover_x - text_x - 40  # Largura disponível para texto (margem entre texto e capa)
                else:
                    # Capa à esquerda (padrão)
                    cover_x = 60
                    img.paste(cover_display, (cover_x, 68), cover_display)
                    # Área de texto à direita
                    text_x = 475  # Início do texto após a capa (60 + 375 + 40 margem)
                    text_width = 1012 - text_x - 50  # Largura disponível para texto (margem direita aumentada para evitar texto na borda)
            
            draw = ImageDraw.Draw(img)
            
            # Configurar fontes com suporte a custom fonts
            font_selector = self.get_setting("font_selector", 0)
            
            try:
                # Usar sistema de custom fonts para título (bold)
                font_title_path = self._get_font_path_by_selector(font_selector)
                font_title = ImageFont.truetype(font_title_path, 44)
            except:
                font_title = ImageFont.truetype("/system/fonts/SourceSansPro-Bold.ttf", 44)
            
            try:
                # Usar sistema de custom fonts para artista (regular)
                font_artist_path = self._get_font_regular_by_selector(font_selector)
                font_artist = ImageFont.truetype(font_artist_path, 24)
            except:
                font_artist = ImageFont.truetype("/system/fonts/SourceSansPro-Regular.ttf", 24)
            
            try:
                # Fonte padrão para tempo
                font_time = ImageFont.truetype("/system/fonts/SourceSansPro-Regular.ttf", 20)
            except:
                font_time = ImageFont.load_default()
            
            # Área de texto (baseada no swap layout)
            # text_x e text_width já foram definidos acima baseado no swap_layout
            
            # Alinhamento vertical dos textos com a capa do álbum
            capa_y = 68  # Posição Y da capa
            
            # Título da música (negrito, branco) - alinhado com o topo da capa
            title_y = capa_y  # Alinhado exatamente com o topo da capa
            
            # Quebra de linha automática para título
            title_lines = self._wrap_text_vinni(title, font_title, text_width)
            for i, line in enumerate(title_lines[:2]):  # Máximo 2 linhas
                draw.text((text_x, title_y + i * 50), line, font=font_title, fill=(255, 255, 255))
            
            # Nome do artista (maiúsculas, branco com opacidade)
            artist_text = artists.upper()
            artist_y = title_y + len(title_lines[:2]) * 50 + 20
            
            # Quebra de linha automática para artista
            artist_lines = self._wrap_text_vinni(artist_text, font_artist, text_width)
            for i, line in enumerate(artist_lines[:2]):  # Máximo 2 linhas
                draw.text((text_x, artist_y + i * 30), line, font=font_artist, fill=(217, 217, 217))  # 85% opacidade
            
            # Calcular posição Y após o artista
            current_y = artist_y + len(artist_lines[:2]) * 30 + 10
            
            # Exibir nome do álbum/playlist baseado no modo selecionado (apenas para tema Vinify)
            album_name = self._get_album_or_playlist_name(track)
            if album_name:
                try:
                    # Usar sistema de custom fonts para álbum (bold)
                    font_album_path = self._get_font_path_by_selector(font_selector)
                    font_album = ImageFont.truetype(font_album_path, 20)
                except:
                    font_album = ImageFont.truetype("/system/fonts/SourceSansPro-Bold.ttf", 20)
                
                # Quebra de linha automática para álbum/playlist
                album_lines = self._wrap_text_vinni(album_name, font_album, text_width)
                for i, line in enumerate(album_lines[:1]):  # Máximo 1 linha
                    draw.text((text_x, current_y + i * 25), line, font=font_album, fill=(255, 255, 255))  # Branco, negrito
                current_y += len(album_lines[:1]) * 25 + 10
            
            # Exibir informações do dispositivo ou perfil do usuário se habilitado (apenas para tema Vinify)
            device_y = 375 - 50  # Posição fixa acima da barra de progresso
            device_profile_mode = self.get_setting("vinify_device_profile_mode", 0)  # 0 = Show Device, 1 = My Profile, 2 = Custom Name, 3 = None

            # Auto-ativar Custom Name para .fm/.stats quando houver nome personalizado configurado
            try:
                player_name = self._detect_current_player()
            except Exception:
                player_name = "Spotify"
            track_source = track.get("source", "")
            vinify_name = self.get_setting("vinify_custom_display_name", "").strip()
            fm_name = self.get_setting("fm_custom_player_name", "").strip()
            if (player_name == "FM" or track_source == "statsfm" or is_fm_command) and (vinify_name or fm_name):
                device_profile_mode = 2
            
            if device_profile_mode == 0:  # Show Device
                device_full_info = self._get_current_device_full_info()
                if device_full_info:
                    try:
                        # Fonte padrão para dispositivo
                        font_device_name = ImageFont.truetype("/system/fonts/SourceSansPro-Bold.ttf", 18)
                    except:
                        font_device_name = ImageFont.load_default()
                    
                    # Obter ícone SVG baseado no tipo do dispositivo
                    device_type = device_full_info.get("type", "computer")
                    
                    # Usar nome personalizado se configurado, senão usar o nome detectado
                    custom_device_name = self.get_setting("vinify_device_name", "")
                    if custom_device_name.strip():
                        device_name = custom_device_name.strip()
                    else:
                        device_name = device_full_info.get("name", "Unknown Device")
                    
                    # URLs dos ícones PNG para cada tipo de dispositivo - URLs corretos e funcionais
                    device_icon_urls = {
                        "smartphone": "https://raw.githubusercontent.com/soumaki/nowFy/main/icons/mobile.png",
                        "computer": "https://raw.githubusercontent.com/soumaki/nowFy/main/icons/computer.png", 
                        "speaker": "https://raw.githubusercontent.com/soumaki/nowFy/main/icons/speaker.png",
                        "tv": "https://raw.githubusercontent.com/soumaki/nowFy/main/icons/tv.png",
                        "web": "https://raw.githubusercontent.com/soumaki/nowFy/main/icons/web.png"
                    }
                    
                    # Obter URL do ícone baseado no tipo do dispositivo
                    icon_url = device_icon_urls.get(device_type, device_icon_urls["computer"])
                    
                    try:
                        # Usar cache com prioridade para arquivo local e persistência após download
                        cache_key = f"device_icon_{device_type}"
                        log(f"[Nowfy] Tentando carregar ícone do dispositivo: {device_type} - URL: {icon_url}")
                        from urllib.parse import urlparse
                        plugin_dir = os.path.dirname(os.path.realpath(__file__))
                        icons_dir = os.path.join(plugin_dir, "icons")
                        os.makedirs(icons_dir, exist_ok=True)
                        filename = os.path.basename(urlparse(icon_url).path) or f"{device_type}.png"
                        local_path = os.path.join(icons_dir, filename)
                        icon_image = None
                        # Tenta abrir do disco
                        if os.path.exists(local_path):
                            try:
                                icon_image = Image.open(local_path).convert("RGBA")
                                log(f"[Nowfy] Ícone de dispositivo local carregado: {filename}")
                            except Exception as e:
                                log(f"[Nowfy] Falha ao abrir ícone local {filename}: {str(e)}")
                        # Se não existir, baixa e salva
                        if icon_image is None:
                            icon_data = self._get_cached_image_enhanced(icon_url, cache_key)
                            if icon_data:
                                log(f"[Nowfy] Ícone carregado com sucesso: {len(icon_data)} bytes")
                                icon_image = Image.open(BytesIO(icon_data)).convert("RGBA")
                                try:
                                    with open(local_path, "wb") as f:
                                        f.write(icon_data)
                                    log(f"[Nowfy] Ícone de dispositivo salvo localmente: {filename}")
                                except Exception as e:
                                    log(f"[Nowfy] Erro ao salvar ícone local: {str(e)}")
                        if icon_image:
                            # Redimensionar ícone para 20x20 pixels
                            icon_size = 20
                            icon_image = icon_image.resize((icon_size, icon_size), Image.LANCZOS)
                            # Colar o ícone na posição
                            img.paste(icon_image, (text_x, device_y), icon_image)
                            icon_width = icon_size + 8  # Espaço após o ícone
                        else:
                            log(f"[Nowfy] Falha ao carregar ícone do dispositivo {device_type}, usando fallback emoji")
                            fallback_text = {
                                "smartphone": "📱",
                                "computer": "💻", 
                                "speaker": "🔊",
                                "tv": "📺",
                                "web": "🌐"
                            }.get(device_type, "💻")
                            draw.text((text_x, device_y), fallback_text, font=font_device_name, fill=(255, 255, 255))
                            icon_width = 25
                    except Exception as e:
                        log(f"[Nowfy] Erro ao carregar ícone do dispositivo {device_type}: {str(e)}")
                        fallback_text = {
                            "smartphone": "📱",
                            "computer": "💻", 
                            "speaker": "🔊",
                            "tv": "📺",
                            "web": "🌐"
                        }.get(device_type, "💻")
                        draw.text((text_x, device_y), fallback_text, font=font_device_name, fill=(255, 255, 255))
                        icon_width = 25
                    
                    # Desenhar nome do dispositivo em negrito e maiúsculas
                    device_name_upper = device_name.upper()
                    draw.text((text_x + icon_width, device_y), device_name_upper, font=font_device_name, fill=(255, 255, 255))
            
            elif device_profile_mode == 1:  # My Profile
                spotify_profile = self._get_spotify_user_profile()
                if spotify_profile:
                    try:
                        # Fonte padrão para perfil
                        font_profile_name = ImageFont.truetype("/system/fonts/SourceSansPro-Bold.ttf", 18)
                    except:
                        font_profile_name = ImageFont.load_default()
                    
                    # Obter nome do perfil
                    profile_name = spotify_profile.get("display_name", spotify_profile.get("id", "Spotify User"))
                    
                    # Tentar carregar a imagem de perfil
                    profile_image_url = spotify_profile.get("profile_image_url", "")
                    icon_width = 0
                    
                    if profile_image_url:
                        try:
                            # Usar o sistema de cache nativo do plugin com cache key específico para imagens de perfil
                            cache_key = f"profile_image_{hash(profile_image_url)}"
                            profile_data = self._get_cached_image_enhanced(profile_image_url, cache_key)
                            if profile_data:
                                profile_image = Image.open(BytesIO(profile_data)).convert("RGBA")
                                
                                # Redimensionar imagem de perfil para 20x20 pixels
                                profile_size = 20
                                profile_image = profile_image.resize((profile_size, profile_size), Image.LANCZOS)
                                
                                # Aplicar bordas arredondadas na imagem de perfil
                                mask = Image.new("L", (profile_size, profile_size), 0)
                                ImageDraw.Draw(mask).ellipse((0, 0, profile_size, profile_size), fill=255)
                                profile_image.putalpha(mask)
                                
                                # Colar a imagem de perfil na posição
                                img.paste(profile_image, (text_x, device_y), profile_image)
                                icon_width = profile_size + 8  # Espaço após a imagem
                        except Exception as e:
                            log(f"[Nowfy] Error loading profile image: {str(e)}")
                    
                    # Se não conseguiu carregar a imagem, usar ícone fy.png como fallback
                    if icon_width == 0:
                        try:
                            # Tentar carregar o ícone fy.png como fallback
                            fallback_url = "https://raw.githubusercontent.com/soumaki/nowFy/main/icons/fy.png"
                            cache_key = "fallback_fy_icon_profile"
                            fallback_data = self._get_cached_image_enhanced(fallback_url, cache_key)
                            if fallback_data:
                                fallback_image = Image.open(BytesIO(fallback_data)).convert("RGBA")
                                
                                # Redimensionar ícone para 18x18 pixels (ligeiramente menor para melhor aparência)
                                fallback_size = 18
                                fallback_image = fallback_image.resize((fallback_size, fallback_size), Image.LANCZOS)
                                
                                # Colar o ícone na posição
                                img.paste(fallback_image, (text_x, device_y), fallback_image)
                                icon_width = fallback_size + 8  # Espaço após a imagem
                        except Exception as e:
                            log(f"[Nowfy] Error loading fallback fy.png icon for profile: {str(e)}")
                        
                        # Se ainda não conseguiu carregar, usar emoji como último fallback
                        if icon_width == 0:
                            draw.text((text_x, device_y), "👤", font=font_profile_name, fill=(255, 255, 255))
                            icon_width = 25
                    
                    # Desenhar nome do perfil em negrito e maiúsculas
                    profile_name_upper = profile_name.upper()
                    draw.text((text_x + icon_width, device_y), profile_name_upper, font=font_profile_name, fill=(255, 255, 255))
            
            elif device_profile_mode == 2:  # Custom Name
                custom_display_name = self.get_setting("vinify_custom_display_name", "").strip() or self.get_setting("fm_custom_player_name", "").strip()
                if custom_display_name.strip():
                    try:
                        # Fonte padrão para nome personalizado
                        font_custom_name = ImageFont.truetype("/system/fonts/SourceSansPro-Bold.ttf", 18)
                    except:
                        font_custom_name = ImageFont.load_default()
                    
                    # Usar a mesma lógica de imagem de perfil do My Profile
                    icon_width = 0
                    try:
                        # Obter informações do perfil do Spotify (mesmo que My Profile)
                        profile_info = self._get_spotify_user_profile()
                        if profile_info and profile_info.get("images"):
                            profile_image_url = profile_info["images"][0]["url"]
                            cache_key = f"profile_{hashlib.md5(profile_image_url.encode()).hexdigest()}"
                            
                            # Carregar imagem de perfil com cache
                            profile_data = self._get_cached_image_enhanced(profile_image_url, cache_key)
                            if profile_data:
                                profile_image = Image.open(BytesIO(profile_data)).convert("RGBA")
                                
                                # Redimensionar imagem de perfil para 20x20 pixels
                                profile_size = 20
                                profile_image = profile_image.resize((profile_size, profile_size), Image.LANCZOS)
                                
                                # Aplicar bordas arredondadas na imagem de perfil
                                mask = Image.new("L", (profile_size, profile_size), 0)
                                ImageDraw.Draw(mask).ellipse((0, 0, profile_size, profile_size), fill=255)
                                profile_image.putalpha(mask)
                                
                                # Colar a imagem de perfil na posição
                                img.paste(profile_image, (text_x, device_y), profile_image)
                                icon_width = profile_size + 8  # Espaço após a imagem
                    except Exception as e:
                        log(f"[Nowfy] Error loading profile image for custom name: {str(e)}")
                    
                    # Se não conseguiu carregar a imagem, usar ícone fy.png como fallback
                    if icon_width == 0:
                        try:
                            # Tentar carregar o ícone fy.png como fallback
                            fallback_url = "https://raw.githubusercontent.com/soumaki/nowFy/main/icons/fy.png"
                            cache_key = "fallback_fy_icon"
                            fallback_data = self._get_cached_image_enhanced(fallback_url, cache_key)
                            if fallback_data:
                                fallback_image = Image.open(BytesIO(fallback_data)).convert("RGBA")
                                
                                # Redimensionar ícone para 18x18 pixels
                                fallback_size = 18
                                fallback_image = fallback_image.resize((fallback_size, fallback_size), Image.LANCZOS)
                                
                                # Colar o ícone na posição
                                img.paste(fallback_image, (text_x, device_y), fallback_image)
                                icon_width = fallback_size + 8  # Espaço após a imagem
                        except Exception as e:
                            log(f"[Nowfy] Error loading fallback fy.png icon: {str(e)}")
                        
                        # Se ainda não conseguiu carregar, usar emoji como último fallback
                        if icon_width == 0:
                            draw.text((text_x, device_y), "✨", font=font_custom_name, fill=(255, 255, 255))
                            icon_width = 25
                    
                    # Desenhar nome personalizado em negrito e maiúsculas
                    custom_name_upper = custom_display_name.strip().upper()
                    draw.text((text_x + icon_width, device_y), custom_name_upper, font=font_custom_name, fill=(255, 255, 255))
            
            elif device_profile_mode == 3:  # Profile & Device
                # Layout combinado: foto do perfil + nome do usuário + ícone do dispositivo + nome do dispositivo
                try:
                    # Fonte padrão para perfil e dispositivo
                    font_profile_device = ImageFont.truetype("/system/fonts/SourceSansPro-Bold.ttf", 16)
                except:
                    font_profile_device = ImageFont.load_default()
                
                current_x = text_x
                
                # 1. Carregar e exibir foto do perfil
                profile_info = self._get_spotify_user_profile()
                profile_width = 0
                
                if profile_info:
                    profile_image_url = profile_info.get("profile_image_url", "")
                    if profile_image_url:
                        try:
                            cache_key = f"profile_image_{hash(profile_image_url)}"
                            profile_data = self._get_cached_image_enhanced(profile_image_url, cache_key)
                            if profile_data:
                                profile_image = Image.open(BytesIO(profile_data)).convert("RGBA")
                                
                                # Redimensionar imagem de perfil para 18x18 pixels
                                profile_size = 18
                                profile_image = profile_image.resize((profile_size, profile_size), Image.LANCZOS)
                                
                                # Aplicar bordas arredondadas na imagem de perfil
                                mask = Image.new("L", (profile_size, profile_size), 0)
                                ImageDraw.Draw(mask).ellipse((0, 0, profile_size, profile_size), fill=255)
                                profile_image.putalpha(mask)
                                
                                # Colar a imagem de perfil na posição
                                img.paste(profile_image, (current_x, device_y + 1), profile_image)
                                profile_width = profile_size + 6  # Espaço após a imagem
                        except Exception as e:
                            log(f"[Nowfy] Error loading profile image for Profile & Device: {str(e)}")
                
                # Se não conseguiu carregar a imagem de perfil, usar ícone fy.png como fallback
                if profile_width == 0:
                    try:
                        fallback_url = "https://raw.githubusercontent.com/soumaki/nowFy/main/icons/fy.png"
                        cache_key = "fallback_fy_icon_profile_device"
                        fallback_data = self._get_cached_image_enhanced(fallback_url, cache_key)
                        if fallback_data:
                            fallback_image = Image.open(BytesIO(fallback_data)).convert("RGBA")
                            
                            # Redimensionar ícone para 18x18 pixels
                            fallback_size = 18
                            fallback_image = fallback_image.resize((fallback_size, fallback_size), Image.LANCZOS)
                            
                            # Colar o ícone na posição
                            img.paste(fallback_image, (current_x, device_y), fallback_image)
                            profile_width = fallback_size + 6  # Espaço após a imagem
                    except Exception as e:
                        log(f"[Nowfy] Error loading fallback fy.png icon for Profile & Device: {str(e)}")
                    
                    # Se ainda não conseguiu carregar, usar emoji como último fallback
                    if profile_width == 0:
                        draw.text((current_x, device_y), "👤", font=font_profile_device, fill=(255, 255, 255))
                        profile_width = 20
                
                current_x += profile_width
                
                # 2. Exibir nome do usuário
                if profile_info:
                    profile_name = profile_info.get("display_name", profile_info.get("id", "User"))
                    draw.text((current_x, device_y), profile_name.upper(), font=font_profile_device, fill=(255, 255, 255))
                    
                    # Calcular largura do nome do usuário para posicionar o próximo elemento
                    try:
                        bbox = font_profile_device.getbbox(profile_name.upper())
                        name_width = bbox[2] - bbox[0] + 12  # Espaço após o nome
                    except:
                        name_width = len(profile_name) * 8 + 12  # Fallback aproximado
                    
                    current_x += name_width
                
                # 3. Adicionar separador "•" antes do ícone do dispositivo
                draw.text((current_x, device_y), "•", font=font_profile_device, fill=(255, 255, 255))
                current_x += 15  # Espaço após o separador
                
                # 4. Carregar e exibir ícone do dispositivo
                device_full_info = self._get_current_device_full_info()
                device_icon_width = 0
                
                if device_full_info:
                    device_type = device_full_info.get("type", "computer")
                    
                    # URLs dos ícones PNG para cada tipo de dispositivo
                    device_icon_urls = {
                        "smartphone": "https://raw.githubusercontent.com/soumaki/nowFy/main/icons/mobile.png",
                        "computer": "https://raw.githubusercontent.com/soumaki/nowFy/main/icons/computer.png", 
                        "speaker": "https://raw.githubusercontent.com/soumaki/nowFy/main/icons/speaker.png",
                        "tv": "https://raw.githubusercontent.com/soumaki/nowFy/main/icons/tv.png",
                        "web": "https://raw.githubusercontent.com/soumaki/nowFy/main/icons/web.png"
                    }
                    
                    icon_url = device_icon_urls.get(device_type, device_icon_urls["computer"])
                    
                    try:
                        cache_key = f"device_icon_{device_type}_profile_device"
                        from urllib.parse import urlparse
                        plugin_dir = os.path.dirname(os.path.realpath(__file__))
                        icons_dir = os.path.join(plugin_dir, "icons")
                        os.makedirs(icons_dir, exist_ok=True)
                        filename = os.path.basename(urlparse(icon_url).path) or f"{device_type}.png"
                        local_path = os.path.join(icons_dir, filename)
                        icon_image = None
                        # Tenta abrir do disco primeiro
                        if os.path.exists(local_path):
                            try:
                                icon_image = Image.open(local_path).convert("RGBA")
                                log(f"[Nowfy] Ícone de dispositivo local (Profile & Device) carregado: {filename}")
                            except Exception as e:
                                log(f"[Nowfy] Falha ao abrir ícone local {filename}: {str(e)}")
                        # Se não existir, baixa e salva
                        if icon_image is None:
                            icon_data = self._get_cached_image_enhanced(icon_url, cache_key)
                            if icon_data:
                                icon_image = Image.open(BytesIO(icon_data)).convert("RGBA")
                                try:
                                    with open(local_path, "wb") as f:
                                        f.write(icon_data)
                                    log(f"[Nowfy] Ícone de dispositivo salvo localmente (Profile & Device): {filename}")
                                except Exception as e:
                                    log(f"[Nowfy] Erro ao salvar ícone local: {str(e)}")
                        if icon_image:
                            # Redimensionar ícone para 16x16 pixels
                            icon_size = 16
                            icon_image = icon_image.resize((icon_size, icon_size), Image.LANCZOS)
                            # Colar o ícone na posição
                            img.paste(icon_image, (current_x, device_y + 2), icon_image)
                            device_icon_width = icon_size + 6  # Espaço após o ícone
                        else:
                            log(f"[Nowfy] Falha ao carregar ícone de dispositivo para Profile & Device, usando fallback emoji")
                            fallback_text = {
                                "smartphone": "📱",
                                "computer": "💻", 
                                "speaker": "🔊",
                                "tv": "📺",
                                "web": "🌐"
                            }.get(device_type, "💻")
                            draw.text((current_x, device_y), fallback_text, font=font_profile_device, fill=(255, 255, 255))
                            device_icon_width = 18
                    except Exception as e:
                        log(f"[Nowfy] Error loading device icon for Profile & Device: {str(e)}")
                        fallback_text = {
                            "smartphone": "📱",
                            "computer": "💻", 
                            "speaker": "🔊",
                            "tv": "📺",
                            "web": "🌐"
                        }.get(device_type, "💻")
                        draw.text((current_x, device_y), fallback_text, font=font_profile_device, fill=(255, 255, 255))
                        device_icon_width = 18
                    
                    current_x += device_icon_width
                    
                    # 5. Exibir nome do dispositivo
                    custom_device_name = self.get_setting("vinify_device_name", "")
                    if custom_device_name.strip():
                        device_name = custom_device_name.strip()
                    else:
                        device_name = device_full_info.get("name", "Unknown Device")
                    
                    draw.text((current_x, device_y), device_name.upper(), font=font_profile_device, fill=(255, 255, 255))
            
            # Barra de progresso na parte inferior - POSIÇÃO BASEADA NO LAYOUT
            progress_y = 375  # Posição fixa independente do tamanho do texto (capa_y=68 + 375 - 45)
            
            # Ajustar posição X e largura da barra de progresso baseado no swap layout
            # A barra deve ficar alinhada com os textos, não com a capa
            if swap_layout:
                # Barra alinhada com os textos à esquerda
                progress_x = text_x  # Mesma posição X dos textos
                progress_width = text_width  # Mesma largura da área de texto
            else:
                # Barra alinhada com os textos à direita (padrão)
                progress_x = text_x  # Mesma posição X dos textos
                progress_width = text_width  # Mesma largura da área de texto
            
            # Ocultar ViniBar no Vinify quando for comando .fm (LastFM)
            current_player = self._detect_current_player()
            if not is_fm_command:
                self._draw_vinni_progress_bar_new(draw, track, progress_ms, font_time, progress_x, progress_y, progress_width)
            
            # Adicionar logo da plataforma (Spotify/Apple/AyuGram/exteraGram)
            if current_player in ["Spotify", "Apple Music", "AyuGram", "exteraGram"]:
                platform_logo_option = self.get_setting("vinify_platform_logo", 0)
                self._add_platform_logo_vinify(img, current_player, platform_logo_option, swap_layout)
            
            # Durante o comando .fm (LastFM): usar overlays por player quando suportado;
            # caso contrário (inclui player FM), aplicar overlay do LastFM.
            if is_fm_command:
                try:
                    player_overlay_map = {
                        "YouTube": {
                            "normal": "https://i.postimg.cc/KvgX14KB/yt.png",
                            "swap":   "https://i.postimg.cc/Ghs049BX/yt-swap.png",
                        },
                        "YouTube Music": {
                            "normal": "https://i.postimg.cc/Yqmcvj48/ytmusic.png",
                            "swap":   "https://i.postimg.cc/c48qv6Kh/ytmusic-swap.png",
                        },
                        "SoundCloud": {
                            "normal": "https://i.postimg.cc/Jz19Px6G/soundcloud.png",
                            "swap":   "https://i.postimg.cc/W12QX8W0/soundcloud-swap.png",
                        },
                        "exteraGram": {
                            "normal": "https://i.postimg.cc/tCPx2tZF/etg-normal-bottom.png",
                            "swap":   "https://i.postimg.cc/htB7wzTX/etg-swap-bottom.png",
                        },
                        "AyuGram": {
                            "normal": "https://i.postimg.cc/TwCy5C4k/ayu-normal-bottom.png",
                            "swap":   "https://i.postimg.cc/W3XDqXHW/ayu-swap-bottom.png",
                        },
                        "Yandex Music": {
                            "normal": "https://i.postimg.cc/3RbX5S9T/yandex.png",
                            "swap":   "https://i.postimg.cc/5977bpj4/yandex-swap.png",
                        },
                    }
                    if current_player in player_overlay_map:
                        overlay_url = player_overlay_map[current_player]["swap" if swap_layout else "normal"]
                        response = requests.get(overlay_url, timeout=10)
                        if response.status_code == 200:
                            overlay_image = Image.open(BytesIO(response.content)).convert("RGBA")
                            if overlay_image.size != (1012, 512):
                                overlay_image = overlay_image.resize((1012, 512), Image.LANCZOS)
                                try:
                                    overlay_image = overlay_image.filter(ImageFilter.UnsharpMask(radius=1, percent=150, threshold=3))
                                except Exception:
                                    pass
                            img = Image.alpha_composite(img.convert("RGBA"), overlay_image).convert("RGB")
                            log(f"[Nowfy] Overlay {current_player} aplicado durante .fm com sucesso")
                        else:
                            log(f"[Nowfy] Erro ao baixar overlay {current_player} (.fm): HTTP {response.status_code}")
                    else:
                        overlay_url = (
                            "https://raw.githubusercontent.com/soumaki/nowFy/refs/heads/main/plataform/lastfm_swap.png"
                            if swap_layout
                            else "https://raw.githubusercontent.com/soumaki/nowFy/refs/heads/main/plataform/lastfm.png"
                        )
                        response = requests.get(overlay_url, timeout=10)
                        if response.status_code == 200:
                            overlay_image = Image.open(BytesIO(response.content)).convert("RGBA")
                            overlay_image = overlay_image.resize((1012, 512), Image.LANCZOS)
                            img = Image.alpha_composite(img.convert("RGBA"), overlay_image).convert("RGB")
                            log(f"[Nowfy] Overlay LastFM aplicado durante .fm com sucesso")
                        else:
                            log(f"[Nowfy] Erro ao baixar overlay LastFM (.fm): HTTP {response.status_code}")
                except Exception as e:
                    log(f"[Nowfy] Erro ao aplicar overlay durante .fm: {e}")
            
            # Salvar imagem
            temp_dir = File(ApplicationLoader.getFilesDirFixed(), "exteraFy")
            if not temp_dir.exists():
                temp_dir.mkdirs()
            filename = f"{uuid.uuid4()}.png"
            temp_path = File(temp_dir, filename).getAbsolutePath()
            performance_mode = self.get_setting("performance_mode", 1)
            compress_level = 1 if performance_mode == 0 else 4 if performance_mode == 1 else 6
            img.save(temp_path, format="PNG", optimize=True, compress_level=compress_level)
            
            if params:
                self._send_card_with_caption(params, temp_path, track, force_spotify)
        except Exception as e:
            if params:
                self._send_msg(params, f"Erro: {e}")
    
    def _wrap_text_vinni(self, text, font, max_width):
        """Quebra texto em linhas para o tema Vinni"""
        words = text.split(' ')
        lines = []
        current_line = ""
        
        for word in words:
            test_line = current_line + (" " if current_line else "") + word
            try:
                bbox = font.getbbox(test_line)
                text_width = bbox[2] - bbox[0]
            except:
                text_width = len(test_line) * 10  # Fallback aproximado
            
            if text_width <= max_width:
                current_line = test_line
            else:
                if current_line:
                    lines.append(current_line)
                    current_line = word
                else:
                    lines.append(word)  # Palavra muito longa, adiciona mesmo assim
        
        if current_line:
            lines.append(current_line)
        
        return lines
    
    def _resize_with_aspect_ratio_vinni(self, img, target_size):
        """Redimensiona a imagem com crop inteligente para remover bordas pretas e evitar distorção"""
        width, height = img.size
        target_width, target_height = target_size
        
        # Detectar e remover bordas pretas automaticamente
        img_cropped = self._remove_black_borders(img)
        width, height = img_cropped.size
        
        # Calcular proporções
        img_ratio = width / height
        target_ratio = target_width / target_height
        
        # Estratégia: sempre preencher completamente o espaço (crop inteligente)
        if img_ratio > target_ratio:
            # Imagem mais larga que o target - crop nas laterais
            new_height = target_height
            new_width = round(new_height * img_ratio)
            resized_img = img_cropped.resize((new_width, new_height), Image.LANCZOS)
            
            # Crop centralizado
            crop_x = (new_width - target_width) // 2
            final_img = resized_img.crop((crop_x, 0, crop_x + target_width, target_height))
        else:
            # Imagem mais alta que o target - crop em cima/baixo
            new_width = target_width
            new_height = round(new_width / img_ratio)
            resized_img = img_cropped.resize((new_width, new_height), Image.LANCZOS)
            
            # Crop centralizado
            crop_y = (new_height - target_height) // 2
            final_img = resized_img.crop((0, crop_y, target_width, crop_y + target_height))
        
        # Garantir que a imagem final tenha exatamente o tamanho target
        if final_img.size != target_size:
            final_img = final_img.resize(target_size, Image.LANCZOS)
        
        return final_img
    
    def _remove_black_borders(self, img):
        """Remove bordas pretas da imagem automaticamente"""
        try:
            import numpy as np
            
            # Converter para array numpy
            img_array = np.array(img)
            
            # Se for RGBA, usar apenas RGB para detecção
            if img_array.shape[2] == 4:
                rgb_array = img_array[:, :, :3]
            else:
                rgb_array = img_array
            
            # Detectar pixels que não são pretos (threshold baixo para capturar quase-pretos)
            # Considera preto qualquer pixel com todos os canais RGB < 30
            non_black_mask = np.any(rgb_array > 30, axis=2)
            
            # Encontrar limites da área não-preta
            rows = np.any(non_black_mask, axis=1)
            cols = np.any(non_black_mask, axis=0)
            
            if not np.any(rows) or not np.any(cols):
                # Se toda a imagem for preta, retornar original
                return img
            
            # Encontrar coordenadas de crop
            top, bottom = np.where(rows)[0][[0, -1]]
            left, right = np.where(cols)[0][[0, -1]]
            
            # Adicionar pequena margem para evitar cortar conteúdo importante
            margin = 2
            top = max(0, top - margin)
            left = max(0, left - margin)
            bottom = min(img.height - 1, bottom + margin)
            right = min(img.width - 1, right + margin)
            
            # Crop apenas se houver bordas significativas (> 5% da imagem)
            crop_threshold = 0.05
            if (top > img.height * crop_threshold or 
                left > img.width * crop_threshold or 
                (img.height - bottom) > img.height * crop_threshold or 
                (img.width - right) > img.width * crop_threshold):
                
                return img.crop((left, top, right + 1, bottom + 1))
            
            return img
            
        except Exception as e:
            # Em caso de erro, retornar imagem original
            log(f"[Nowfy] Erro ao remover bordas pretas: {e}")
            return img
    
    def _add_platform_logo_vinify(self, img, player, logo_option, swap_layout):
        """Adiciona logo da plataforma no tema Vinify como overlay"""
        try:
            # Log de debug para rastrear a execução
            log(f"[Nowfy] Platform Logo Debug - player: {player}, logo_option: {logo_option}, swap_layout: {swap_layout}")
            
            # Se a opção "None" (índice 0) estiver selecionada, não aplicar logo
            if logo_option == 0:
                log(f"[Nowfy] Platform Logo: Opção 'None' selecionada, não aplicando logo")
                return
            
            # Ajustar índice para as opções de logo (subtrair 1 porque "None" é índice 0)
            adjusted_logo_option = logo_option - 1
            log(f"[Nowfy] Platform Logo: Índice ajustado: {adjusted_logo_option}")
            
            # URLs dos logos baseados na plataforma, opção de cor, swap layout e posição
            logo_urls = {
                "Spotify": {
                    "normal": {
                        0: "https://raw.githubusercontent.com/soumaki/nowFy/refs/heads/main/plataform/spotify_green_and_white.png",  # Green & White
                        1: "https://raw.githubusercontent.com/soumaki/nowFy/refs/heads/main/plataform/spotify_white_and_green.png",  # White & Green
                        2: "https://raw.githubusercontent.com/soumaki/nowFy/refs/heads/main/plataform/spotify_black_and_white.png",  # Black & White
                        3: "https://raw.githubusercontent.com/soumaki/nowFy/refs/heads/main/plataform/spotify_white_and_black.png"   # White & Black
                    },
                    "swap": {
                        0: "https://raw.githubusercontent.com/soumaki/nowFy/refs/heads/main/plataform/white_and_green_swap.png",  # White & Green
                        1: "https://raw.githubusercontent.com/soumaki/nowFy/refs/heads/main/plataform/green_and_white_swap.png",  # Green & White
                        2: "https://raw.githubusercontent.com/soumaki/nowFy/refs/heads/main/plataform/black_and_white_swap.png",  # Black & White
                        3: "https://raw.githubusercontent.com/soumaki/nowFy/refs/heads/main/plataform/white_and_black_swap.png"   # White & Black
                    },
                    "inf_normal": {
                        0: "https://raw.githubusercontent.com/soumaki/nowFy/refs/heads/main/plataform/spotify_inf_green_and_white.png",  # Green & White (inferior)
                        1: "https://raw.githubusercontent.com/soumaki/nowFy/refs/heads/main/plataform/spotify_inf_white_and_green.png",  # White & Green (inferior)
                        2: "https://raw.githubusercontent.com/soumaki/nowFy/refs/heads/main/plataform/spotify_inf_black_and_white.png",  # Black & White (inferior)
                        3: "https://raw.githubusercontent.com/soumaki/nowFy/refs/heads/main/plataform/spotify_inf_white_and_black.png"   # White & Black (inferior)
                    },
                    "inf_swap": {
                        0: "https://raw.githubusercontent.com/soumaki/nowFy/refs/heads/main/plataform/spotify_inf_green_and_white_swap.png",  # Green & White (inferior swap)
                        1: "https://raw.githubusercontent.com/soumaki/nowFy/refs/heads/main/plataform/spotify_inf_white_and_green_swap.png",  # White & Green (inferior swap)
                        2: "https://raw.githubusercontent.com/soumaki/nowFy/refs/heads/main/plataform/spotify_inf_black_and_white_swap.png",  # Black & White (inferior swap)
                        3: "https://raw.githubusercontent.com/soumaki/nowFy/refs/heads/main/plataform/spotify_inf_white_and_black_swap.png"   # White & Black (inferior swap)
                    }
                },
                "Apple Music": {
                    "normal": {
                        0: "https://raw.githubusercontent.com/soumaki/nowFy/refs/heads/main/plataform/apple_red_and_white.png",  # Red & White
                        1: "https://raw.githubusercontent.com/soumaki/nowFy/refs/heads/main/plataform/apple_white_and_red.png",  # White & Red
                        2: "https://raw.githubusercontent.com/soumaki/nowFy/refs/heads/main/plataform/apple_black_and_white.png",  # Black & White
                        3: "https://raw.githubusercontent.com/soumaki/nowFy/refs/heads/main/plataform/apple_white_and_black.png"   # White & Black
                    },
                    "swap": {
                        0: "https://raw.githubusercontent.com/soumaki/nowFy/refs/heads/main/plataform/apple_white_and_red_swap.png",  # White & Red
                        1: "https://raw.githubusercontent.com/soumaki/nowFy/refs/heads/main/plataform/apple_red_and_white_swap.png",  # Red & White
                        2: "https://raw.githubusercontent.com/soumaki/nowFy/refs/heads/main/plataform/apple_black_and_white_swap.png",  # Black & White
                        3: "https://raw.githubusercontent.com/soumaki/nowFy/refs/heads/main/plataform/apple_white_and_black_swap.png"   # White & Black
                    },
                    "inf_normal": {
                        0: "https://raw.githubusercontent.com/soumaki/nowFy/refs/heads/main/plataform/apple_inf_red_and_white.png",  # Red & White (inferior)
                        1: "https://raw.githubusercontent.com/soumaki/nowFy/refs/heads/main/plataform/apple_inf_white_and_red.png",  # White & Red (inferior)
                        2: "https://raw.githubusercontent.com/soumaki/nowFy/refs/heads/main/plataform/apple_inf_black_and_white.png",  # Black & White (inferior)
                        3: "https://raw.githubusercontent.com/soumaki/nowFy/refs/heads/main/plataform/apple_inf_white_and_black.png"   # White & Black (inferior)
                    },
                    "inf_swap": {
                        0: "https://raw.githubusercontent.com/soumaki/nowFy/refs/heads/main/plataform/apple_inf_red_and_white_swap.png",  # Red & White (inferior swap)
                        1: "https://raw.githubusercontent.com/soumaki/nowFy/refs/heads/main/plataform/apple_inf_white_and_red_swap.png",  # White & Red (inferior swap)
                        2: "https://raw.githubusercontent.com/soumaki/nowFy/refs/heads/main/plataform/apple_inf_black_and_white_swap.png",  # Black & White (inferior swap)
                        3: "https://raw.githubusercontent.com/soumaki/nowFy/refs/heads/main/plataform/apple_inf_white_and_black_swap.png"   # White & Black (inferior swap)
                    }
                },
                "exteraGram": {
                    "inf_normal": {
                        0: "https://raw.githubusercontent.com/soumaki/nowFy/refs/heads/main/plataform/etg_normal_bottom.png"
                    },
                    "inf_swap": {
                        0: "https://raw.githubusercontent.com/soumaki/nowFy/refs/heads/main/plataform/etg_swap_bottom.png"
                    }
                },
                "AyuGram": {
                    "inf_normal": {
                        0: "https://raw.githubusercontent.com/soumaki/nowFy/9ba69c8657e36830457a94ef5c288454631905e9/plataform/ayu_normal_bottom.png"
                    },
                    "inf_swap": {
                        0: "https://raw.githubusercontent.com/soumaki/nowFy/refs/heads/main/plataform/ayu_swap_bottom.png"
                    }
                }
            }
            
            # Determinar layout (swap ou normal) e posição (superior/inferior)
            if player in ("AyuGram", "exteraGram"):
                # Forçar posição inferior para AyuGram/exteraGram
                layout_type = "inf_swap" if swap_layout else "inf_normal"
            else:
                layout_type = "swap" if swap_layout else "normal"
                logo_position = self.get_setting("vinify_logo_position", 0)  # 0: Superior, 1: Inferior
                if logo_position == 1:
                    layout_type = "inf_swap" if swap_layout else "inf_normal"
            log(f"[Nowfy] Platform Logo: Layout type: {layout_type}")
            
            # Obter URL do logo usando o índice ajustado
            logo_url = logo_urls.get(player, {}).get(layout_type, {}).get(adjusted_logo_option)
            log(f"[Nowfy] Platform Logo: URL do logo: {logo_url}")
            if not logo_url:
                log(f"[Nowfy] Platform Logo: URL não encontrada para player={player}, layout={layout_type}, option={adjusted_logo_option}")
                return
            
            # Carregar logo priorizando arquivo local e persistindo após download
            cache_key = f"platform_logo_{player.lower().replace(' ', '_')}_{layout_type}_{adjusted_logo_option}"
            log(f"[Nowfy] Platform Logo: Cache key: {cache_key}")
            logo_image = None
            try:
                from urllib.parse import urlparse
                plugin_dir = os.path.dirname(os.path.realpath(__file__))
                icons_dir = os.path.join(plugin_dir, "icons")
                os.makedirs(icons_dir, exist_ok=True)
                filename = os.path.basename(urlparse(logo_url).path) or f"{player.lower()}_logo.png"
                local_path = os.path.join(icons_dir, filename)
            except Exception:
                local_path = None
                filename = None
            # Tenta carregar do disco primeiro
            if local_path and os.path.exists(local_path):
                try:
                    logo_image = Image.open(local_path).convert("RGBA")
                    log(f"[Nowfy] Platform Logo: Ícone local carregado: {filename}")
                except Exception as e:
                    log(f"[Nowfy] Platform Logo: Falha ao abrir ícone local {filename}: {str(e)}")
            # Se não houver local, busca remoto e salva
            if logo_image is None:
                logo_data = self._get_cached_image_enhanced(logo_url, cache_key)
                if not logo_data and "/refs/heads/" in logo_url:
                    try:
                        alt_url = logo_url.replace("/refs/heads/", "/")
                        logo_data = self._get_cached_image_enhanced(alt_url, cache_key + "_alt")
                    except Exception:
                        pass
                if logo_data:
                    logo_image = Image.open(BytesIO(logo_data)).convert("RGBA")
                    try:
                        if local_path:
                            with open(local_path, "wb") as f:
                                f.write(logo_data)
                            log(f"[Nowfy] Platform Logo: Salvo localmente em {filename}")
                    except Exception as e:
                        log(f"[Nowfy] Platform Logo: Erro ao salvar ícone local: {str(e)}")
                else:
                    # Fallback para nomes locais conhecidos (AyuGram/exteraGram)
                    if player in ("AyuGram", "exteraGram"):
                        try:
                            plugin_dir = os.path.dirname(os.path.realpath(__file__))
                            icons_dir = os.path.join(plugin_dir, "icons")
                            if player == "AyuGram":
                                filename_fb = "ayu_swap_bottom.png" if layout_type == "inf_swap" else "ayu_normal_bottom.png"
                            else:
                                filename_fb = "etg_swap_bottom.png" if layout_type == "inf_swap" else "etg_normal_bottom.png"
                            local_fb = os.path.join(icons_dir, filename_fb)
                            if os.path.exists(local_fb):
                                logo_image = Image.open(local_fb).convert("RGBA")
                                log(f"[Nowfy] Platform Logo: Fallback ícone local carregado: {filename_fb}")
                        except Exception as e:
                            log(f"[Nowfy] Platform Logo: Erro no fallback de ícone local: {str(e)}")
                    if logo_image is None:
                        log(f"[Nowfy] Platform Logo: Falha ao carregar dados da imagem do logo")
                        return
            log(f"[Nowfy] Platform Logo: Logo carregado com sucesso, aplicando overlay")
            
            # Tamanho do card
            card_size = (1012, 512)
            # Redimensionar somente se necessário e aplicar leve nitidez após upscale
            if logo_image.size != card_size:
                logo_image = logo_image.resize(card_size, Image.LANCZOS)
                try:
                    logo_image = logo_image.filter(ImageFilter.UnsharpMask(radius=1, percent=150, threshold=3))
                except Exception:
                    pass
            
            # Compor com alpha para melhor qualidade
            try:
                base_rgba = img.convert("RGBA")
                composited = Image.alpha_composite(base_rgba, logo_image)
                img.paste(composited.convert("RGB"), (0, 0))
            except Exception:
                # Fallback para paste com máscara
                img.paste(logo_image, (0, 0), logo_image)
            
            log(f"[Nowfy] Platform Logo: Overlay aplicado com sucesso")
            
        except Exception as e:
            log(f"[Nowfy] Error adding platform logo: {str(e)}")
    
    def _draw_vinni_progress_bar_new(self, draw, track, progress_ms, font_time, x, y, width, use_blur_override=None):
        """Desenha a barra de progresso do tema Vinni ao lado direito da capa"""
        # Configurações da barra
        progress_y = y
        progress_x = x
        progress_width = width
        progress_height = 10
        
        duration_ms = track.get("duration_ms", 225000)
        if progress_ms is None:
            progress_ms = 0
        
        # Log de depuração para ViniBar
        log(f"[NowFy] ViniBar Debug - progress_ms: {progress_ms}, duration_ms: {duration_ms}, track: {track.get('name', 'Unknown')}")
        
        # Obter configurações de cores da ViniBar
        color_options = [
            (255, 255, 255, 255),  # Branco
            (255, 0, 0, 255),      # Vermelho
            (255, 127, 0, 255),    # Laranja
            (255, 255, 0, 255),    # Amarelo
            (0, 255, 0, 255),      # Verde
            (0, 0, 255, 255),      # Azul
            (75, 0, 130, 255),     # Índigo
            (148, 0, 211, 255)     # Violeta
        ]
        
        dark_color_options = [
            (128, 128, 128, 8),    # Cinza (padrão)
            (128, 0, 0, 8),       # Vermelho escuro
            (128, 64, 0, 8),      # Laranja escuro
            (128, 128, 0, 8),     # Amarelo escuro
            (0, 128, 0, 8),       # Verde escuro
            (0, 0, 128, 8),       # Azul escuro
            (64, 0, 64, 8),       # Índigo escuro
            (75, 0, 96, 8)        # Violeta escuro
        ]
        
        # Obter índices das cores selecionadas
        bar_color_index = self.get_setting("vinify_bar_color", 0)
        bg_color_index = self.get_setting("vinify_bar_bg_color", 0)
        use_gradient = self.get_setting("vinify_bar_gradient", False)
        # Permitir override para usar efeito vidro (glass) por padrão no Nowv
        use_blur = self.get_setting("vinify_bar_blur", False) if use_blur_override is None else bool(use_blur_override)
        
        # Cores padrão caso os índices estejam fora do intervalo
        bar_color = color_options[min(bar_color_index, len(color_options) - 1)]
        bg_color = dark_color_options[min(bg_color_index, len(dark_color_options) - 1)]
        
        # Fundo da barra com efeito de blur ou cor selecionada
        if use_blur and hasattr(draw, '_image'):
            try:
                # EFEITO DE BLUR ATIVADO: Criar efeito de vidro translúcido
                log(f"[NowFy] ViniBar Blur ATIVO - Aplicando efeito de vidro")
                
                # Extrair a área da imagem onde a barra será desenhada
                blur_area = draw._image.crop((
                    progress_x, progress_y, 
                    progress_x + progress_width, progress_y + progress_height
                ))
                
                # Aplicar blur na área extraída
                blurred_area = blur_area.filter(ImageFilter.GaussianBlur(radius=8))
                
                # Criar uma sobreposição translúcida para o efeito de vidro
                overlay = Image.new('RGBA', (progress_width, progress_height), (255, 255, 255, 40))
                
                # Combinar o blur com a sobreposição
                glass_effect = Image.alpha_composite(blurred_area.convert('RGBA'), overlay)
                
                # Criar máscara com cantos arredondados
                mask = Image.new('L', (progress_width, progress_height), 0)
                mask_draw = ImageDraw.Draw(mask)
                mask_draw.rounded_rectangle(
                    [(0, 0), (progress_width - 1, progress_height - 1)],
                    radius=5,
                    fill=255
                )
                
                # Aplicar a máscara ao efeito de vidro
                glass_effect.putalpha(mask)
                
                # Colar o efeito de vidro na imagem principal
                draw._image.paste(glass_effect, (progress_x, progress_y), glass_effect)
                
            except Exception as e:
                log(f"[NowFy] Erro no efeito de blur, usando cor sólida: {e}")
                # Fallback para cor sólida
                draw.rounded_rectangle(
                    [(progress_x, progress_y), (progress_x + progress_width, progress_y + progress_height)],
                    radius=5,
                    fill=bg_color
                )
        else:
            # EFEITO DE BLUR DESATIVADO: Usar cor selecionada
            draw.rounded_rectangle(
                [(progress_x, progress_y), (progress_x + progress_width, progress_y + progress_height)],
                radius=5,
                fill=bg_color
            )
        
        # Calcular progresso
        if duration_ms > 0:
            progress_ratio = min(progress_ms / duration_ms, 1.0)
            filled_width = int(progress_width * progress_ratio)
            
            # Barra preenchida com a cor selecionada ou gradiente
            if filled_width > 0:
                if use_gradient:
                    try:
                        # GRADIENTE ATIVADO: Usar cores da capa do álbum
                        log(f"[NowFy] ViniBar Gradient ATIVO - Extraindo cores da capa do álbum")
                        
                        # Tentar obter a capa do álbum atual
                        album_cover = None
                        
                        # Verificar se temos acesso à capa através da função _generate_vinni_card
                        # Buscar a capa na função pai ou usar uma referência global
                        if hasattr(self, '_current_album_cover') and self._current_album_cover:
                            album_cover = self._current_album_cover
                        else:
                            # Tentar obter a capa do track atual
                            try:
                                current_track = self._get_current_track()
                                if current_track and current_track.get('album', {}).get('images'):
                                    images = current_track['album']['images']
                                    cover_url = max(images, key=lambda i: i['width'])['url'] if images else None
                                    if cover_url:
                                        cover_data = self._get_cached_image_enhanced(cover_url, f"gradient_cover_{hash(cover_url)}")
                                        if cover_data:
                                            album_cover = Image.open(BytesIO(cover_data)).convert('RGB')
                            except Exception as e:
                                log(f"[NowFy] Erro ao obter capa para gradiente: {e}")
                        
                        if album_cover:
                            # Extrair cores da capa usando a função existente
                            extracted_colors = self._extract_colors_from_cover(album_cover, 0)  # Modo dominante + variação
                            
                            # Converter cores hex para RGB
                            def hex_to_rgb(hex_color):
                                hex_color = hex_color.lstrip('#')
                                return tuple(int(hex_color[i:i+2], 16) for i in (0, 2, 4))
                            
                            start_color = hex_to_rgb(extracted_colors[0]) + (255,)
                            end_color = hex_to_rgb(extracted_colors[1]) + (255,)
                            
                            log(f"[NowFy] Cores extraídas da capa: {extracted_colors[0]} -> {extracted_colors[1]}")
                        else:
                            # Fallback: gradiente dinâmico baseado no tempo
                            import time
                            import colorsys
                            
                            current_time = int(time.time() * 2) % 360
                            h1 = (current_time / 360.0) % 1.0
                            s1, v1 = 0.8, 0.9
                            r1, g1, b1 = colorsys.hsv_to_rgb(h1, s1, v1)
                            start_color = (int(r1 * 255), int(g1 * 255), int(b1 * 255), 255)
                            
                            h2 = (h1 + 0.3) % 1.0
                            r2, g2, b2 = colorsys.hsv_to_rgb(h2, s1, v1)
                            end_color = (int(r2 * 255), int(g2 * 255), int(b2 * 255), 255)
                            
                            log(f"[NowFy] Usando gradiente dinâmico (fallback): {start_color} -> {end_color}")
                        
                        # NOVA IMPLEMENTAÇÃO: Criar gradiente diretamente na imagem principal
                        # Criar uma imagem temporária para o gradiente completo
                        gradient_img = Image.new('RGBA', (filled_width, progress_height), (0, 0, 0, 0))
                        
                        # Desenhar o gradiente preenchendo completamente a área
                        for x_pos in range(filled_width):
                            # Calcular a cor do gradiente para esta posição
                            if filled_width > 1:
                                ratio = x_pos / (filled_width - 1)
                            else:
                                ratio = 0
                            
                            # Interpolar as cores
                            r = int(start_color[0] * (1 - ratio) + end_color[0] * ratio)
                            g = int(start_color[1] * (1 - ratio) + end_color[1] * ratio)
                            b = int(start_color[2] * (1 - ratio) + end_color[2] * ratio)
                            
                            # Desenhar uma linha vertical com a cor interpolada
                            for y_pos in range(progress_height):
                                gradient_img.putpixel((x_pos, y_pos), (r, g, b, 255))
                        
                        # Criar máscara com cantos arredondados
                        mask = Image.new('L', (filled_width, progress_height), 0)
                        mask_draw = ImageDraw.Draw(mask)
                        mask_draw.rounded_rectangle(
                            [(0, 0), (filled_width - 1, progress_height - 1)],
                            radius=5,
                            fill=255
                        )
                        
                        # Aplicar a máscara ao gradiente
                        gradient_img.putalpha(mask)
                        
                        # Colar o gradiente na imagem principal, sobrepondo completamente a barra de fundo
                        if hasattr(draw, '_image'):
                            # Primeiro, desenhar um retângulo sólido para cobrir completamente o fundo
                            temp_draw = ImageDraw.Draw(draw._image)
                            temp_draw.rounded_rectangle(
                                [(progress_x, progress_y), (progress_x + filled_width, progress_y + progress_height)],
                                radius=5,
                                fill=(0, 0, 0, 0)  # Transparente para limpar a área
                            )
                            
                            # Agora colar o gradiente
                            draw._image.paste(gradient_img, (progress_x, progress_y), gradient_img)
                        else:
                            # Fallback: usar método de desenho direto
                            self._draw_gradient_fallback(draw, progress_x, progress_y, filled_width, progress_height, start_color, end_color)
                        
                    except Exception as e:
                        # Fallback para cor sólida em caso de erro
                        log(f"[NowFy] Erro no gradiente, usando cor sólida: {e}")
                        draw.rounded_rectangle(
                            [(progress_x, progress_y), (progress_x + filled_width, progress_y + progress_height)],
                            radius=5,
                            fill=bar_color
                        )
                else:
                    # GRADIENTE DESATIVADO: Usar cor selecionada nos seletores
                    log(f"[NowFy] ViniBar Gradient DESATIVADO - Usando cor selecionada: {bar_color}")
                    draw.rounded_rectangle(
                        [(progress_x, progress_y), (progress_x + filled_width, progress_y + progress_height)],
                        radius=5,
                        fill=bar_color
                    )
        
        # Função para formatar tempo
        def ms_to_minsec(ms):
            m = int(ms // 60000)
            s = int((ms % 60000) // 1000)
            return f"{m}:{s:02d}"
        
        # Tempo atual e total
        current_time = ms_to_minsec(progress_ms)
        total_time = ms_to_minsec(duration_ms)
        
        # Tempo atual (esquerda)
        draw.text((progress_x, progress_y + 20), current_time, font=font_time, fill=(255, 255, 255))
        
        # Tempo total (direita)
        try:
            total_time_bbox = draw.textbbox((0, 0), total_time, font=font_time)
            total_time_width = total_time_bbox[2] - total_time_bbox[0]
        except:
            total_time_width = len(total_time) * 10  # Fallback aproximado
        
        draw.text((progress_x + progress_width - total_time_width, progress_y + 20), total_time, font=font_time, fill=(255, 255, 255))
    
    def _draw_gradient_fallback(self, draw, x, y, width, height, start_color, end_color):
        """Método fallback para desenhar gradiente quando não há acesso direto à imagem"""
        try:
            # Dividir em segmentos menores para um gradiente mais suave
            segments = min(width, 50)  # Máximo de 50 segmentos
            segment_width = width / segments
            
            for i in range(segments):
                # Calcular posição e largura do segmento
                seg_x = x + int(i * segment_width)
                seg_width = int((i + 1) * segment_width) - int(i * segment_width)
                
                # Calcular cor interpolada
                ratio = i / (segments - 1) if segments > 1 else 0
                r = int(start_color[0] * (1 - ratio) + end_color[0] * ratio)
                g = int(start_color[1] * (1 - ratio) + end_color[1] * ratio)
                b = int(start_color[2] * (1 - ratio) + end_color[2] * ratio)
                
                # Desenhar segmento
                if i == 0:  # Primeiro segmento com cantos arredondados à esquerda
                    draw.rounded_rectangle(
                        [(seg_x, y), (seg_x + seg_width, y + height)],
                        radius=5,
                        fill=(r, g, b, 255)
                    )
                elif i == segments - 1:  # Último segmento com cantos arredondados à direita
                    draw.rounded_rectangle(
                        [(seg_x, y), (seg_x + seg_width, y + height)],
                        radius=5,
                        fill=(r, g, b, 255)
                    )
                else:  # Segmentos do meio sem cantos arredondados
                    draw.rectangle(
                        [(seg_x, y), (seg_x + seg_width, y + height)],
                        fill=(r, g, b, 255)
                    )
        except Exception as e:
            log(f"[NowFy] Erro no fallback do gradiente: {e}")
            # Último recurso: cor sólida
            draw.rounded_rectangle(
                [(x, y), (x + width, y + height)],
                radius=5,
                fill=start_color
            )
    
    def _draw_vinni_progress_bar(self, draw, track, progress_ms=None):
        """Desenha a barra de progresso personalizada do tema Vinni (versão antiga)"""
        bar_width = 260
        bar_height = 6
        bar_x = 70 + (298 - bar_width) // 2
        bar_y = 153 - 35
        duration_ms = track.get("duration_ms", 225000)
        if progress_ms is None:
            progress_ms = 0
        
        if duration_ms <= 0:
            progress_width = 0
        else:
            progress_width = int((progress_ms / duration_ms) * bar_width)
            progress_width = min(progress_width, bar_width)
        
        # Barra de fundo (cinza escuro)
        draw.rounded_rectangle(
            (bar_x, bar_y, bar_x + bar_width, bar_y + bar_height),
            radius=bar_height // 2,
            fill=(60, 60, 70, 26)
        )
        
        # Barra de progresso (azul vibrante)
        draw.rounded_rectangle(
            (bar_x, bar_y, bar_x + progress_width, bar_y + bar_height),
            radius=bar_height // 2,
            fill=(100, 150, 255, 255)
        )
        
        # Handle (círculo azul)
        handle_radius = 8
        handle_x = bar_x + progress_width
        handle_y = bar_y + bar_height // 2
        draw.ellipse(
            (handle_x - handle_radius, handle_y - handle_radius, handle_x + handle_radius, handle_y + handle_radius),
            fill=(100, 150, 255, 255)
        )
        
        # Tempos
        def ms_to_minsec(ms):
            m = int(ms // 60000)
            s = int((ms % 60000) // 1000)
            return f"{m}:{s:02d}"
        
        font = ImageFont.truetype("/system/fonts/SourceSansPro-Regular.ttf", 22)
        time_current = ms_to_minsec(progress_ms)
        time_total = ms_to_minsec(duration_ms)
        # Usando método alternativo para calcular altura do texto
        font_height = font.size
        text_y = bar_y + bar_height // 2 - font_height // 2
        draw.text((bar_x, text_y - 30), time_current, font=font, fill=(176, 176, 176, 255))
        # Estimativa simples para largura do texto
        time_width = len(time_total) * (font.size // 2)
        draw.text((bar_x + bar_width - time_width, text_y - 30), time_total, font=font, fill=(176, 176, 176, 255))

    def _generate_apple_light_card(self, track, params=None, progress_ms=None, force_spotify=False, etg_cover_image=None):
        try:
            base_path = self._ensure_card_base_image(theme=0)
            img = Image.open(base_path).convert("RGBA")
            title = track["name"]
            artists = ", ".join([a["name"] for a in track["artists"]])
            target_size = (298, 298)

            # Usar a imagem de capa do ETG se disponível
            if etg_cover_image is not None:
                # Aplicar anti-aliasing avançado do Apple UI
                cover = self._apply_apple_antialiasing(etg_cover_image, target_size)
            else:
                player_name = self._detect_current_player()

                if player_name == "SoundCloud":
                    # Primeiro tentar obter capa diretamente do SoundCloud
                    soundcloud_cover_url = self.get_soundcloud_cover(title, artists)
                    if soundcloud_cover_url:
                        try:
                            resp = requests.get(soundcloud_cover_url, timeout=10)
                            resp.raise_for_status()
                            cover = Image.open(BytesIO(resp.content)).convert("RGBA")
                            cover = self._apply_apple_antialiasing(cover, target_size)
                        except Exception as e:
                            log(f"Erro ao carregar capa do SoundCloud: {e}")
                            # Fallback para YouTube apenas se SoundCloud falhar
                            youtube_cover_url = self._get_youtube_cover(title, artists)
                            if youtube_cover_url == "https://i.postimg.cc/4yjVLFTV/icondefault.png":
                                youtube_cover_url = self._get_youtube_thumbnail_forced(title, artists)
                            try:
                                resp = requests.get(youtube_cover_url, timeout=10)
                                resp.raise_for_status()
                                cover = Image.open(BytesIO(resp.content)).convert("RGBA")
                                cover = self._apply_apple_antialiasing(cover, target_size)
                            except Exception:
                                cover = Image.new("RGBA", target_size, (30, 30, 30, 255))
                    else:
                        # Fallback para YouTube se SoundCloud não retornar capa
                        youtube_cover_url = self._get_youtube_cover(title, artists)
                        if youtube_cover_url == "https://i.postimg.cc/4yjVLFTV/icondefault.png":
                            youtube_cover_url = self._get_youtube_thumbnail_forced(title, artists)
                        try:
                            resp = requests.get(youtube_cover_url, timeout=10)
                            resp.raise_for_status()
                            cover = Image.open(BytesIO(resp.content)).convert("RGBA")
                            cover = self._apply_apple_antialiasing(cover, target_size)
                        except Exception as e:
                            log(f"Erro ao carregar capa do YouTube para SoundCloud: {e}")
                            cover = Image.new("RGBA", target_size, (30, 30, 30, 255))
                elif player_name in ("YouTube", "YouTube Music", "Yandex Music"):
                    # Lógica dedicada: obter capa do YouTube/YouTube Music
                    try:
                        youtube_cover_url = self._get_youtube_cover(title, artists)
                        if youtube_cover_url == "https://i.postimg.cc/4yjVLFTV/icondefault.png":
                            youtube_cover_url = self._get_youtube_thumbnail_forced(title, artists)
                        resp = requests.get(youtube_cover_url, timeout=10)
                        resp.raise_for_status()
                        cover = Image.open(BytesIO(resp.content)).convert("RGBA")
                        cover = self._apply_apple_antialiasing(cover, target_size)
                    except Exception as e:
                        log(f"Erro ao carregar capa do YouTube: {e}")
                        # Fallback obrigatório: tentar APIs, YouTube cover ou icondefault
                        cover = self._get_fallback_cover(title, artists)
                else:
                    images = track["album"].get("images", [])
                    cover_url = max(images, key=lambda i: i.get("width", 0))["url"] if images else None
                    if cover_url:
                        try:
                            # Tentar baixar diretamente como no Apple Dark
                            resp = requests.get(cover_url, timeout=10)
                            resp.raise_for_status()
                            cover = Image.open(BytesIO(resp.content)).convert("RGBA")
                            cover = self._apply_apple_antialiasing(cover, target_size)
                        except Exception:
                            # Fallback obrigatório: tentar APIs, YouTube cover ou icondefault
                            cover = self._get_fallback_cover(title, artists)
                    else:
                        cover = self._get_fallback_cover(title, artists)

            # Não aplicar máscara adicional aqui, pois o raio já foi aplicado pelo _apply_apple_antialiasing
            img.paste(cover, (70, 153), cover)
            draw = ImageDraw.Draw(img)

            if self.get_setting("show_extera_bar", True):
                track_source = track.get("source") if isinstance(track, dict) else None
                if track_source in ("spotify", "statsfm"):
                    self.exteraBarSeek(draw, track, progress_ms)

            font_selector = self.get_setting("font_selector", 0)
            max_font_size = 54
            min_font_size = 36
            base_font_size = 42
            if len(title) <= 10:
                font_size = max_font_size
            elif len(title) <= 18:
                font_size = int(base_font_size + (max_font_size - base_font_size) * (18 - len(title)) / 8)
            else:
                font_size = min_font_size

            # Fonte do título e artista: selecionada/custom
            font_path_bold = self._get_font_path_by_selector(font_selector)
            font_path_regular = self._get_font_regular_by_selector(font_selector)
            try:
                font_title = ImageFont.truetype(font_path_bold, font_size)
            except Exception as e:
                log(f"[Nowfy] Erro ao carregar fonte bold {font_path_bold}: {e}")
                font_title = ImageFont.load_default()

            if self._is_arabic(artists):
                try:
                    font_artist = ImageFont.truetype("/system/fonts/NotoNaskhArabic-Regular.ttf", 25)
                except Exception:
                    font_artist = ImageFont.load_default()
            else:
                try:
                    font_artist = ImageFont.truetype(font_path_regular, 25)
                except Exception as e:
                    log(f"[Nowfy] Erro ao carregar fonte regular {font_path_regular}: {e}")
                    font_artist = ImageFont.load_default()

            # Fonte padrão para 'Playing'
            try:
                font_playing = ImageFont.truetype("/system/fonts/SourceSansPro-Regular.ttf", 26)
            except Exception:
                font_playing = ImageFont.load_default()

            text_x = 400
            text_y = 160
            max_text_width = 600
            playing_text = tr("playing")

            text_y = self.draw_multiline_text(draw, playing_text, (text_x, text_y), font_playing, "#888888", max_text_width)
            text_y += 12
            text_y = self.draw_multiline_text(draw, title, (text_x, text_y), font_title, "#000000", max_text_width)
            text_y += 20
            self.draw_multiline_text(draw, artists, (text_x, text_y), font_artist, "#888888", max_text_width)

            temp_dir = File(ApplicationLoader.getFilesDirFixed(), "exteraFy")
            if not temp_dir.exists():
                temp_dir.mkdirs()
            filename = f"{uuid.uuid4()}.png"
            temp_path = File(temp_dir, filename).getAbsolutePath()
            performance_mode = self.get_setting("performance_mode", 1)
            compress_level = 1 if performance_mode == 0 else 4 if performance_mode == 1 else 6
            img.save(temp_path, format="PNG", optimize=True, compress_level=compress_level)
            if params:
                self._send_card_with_caption(params, temp_path, track, force_spotify)
        except Exception as e:
            if params:
                self._send_msg(params, f"Erro: {e}")


    def exteraBarSeek(self, draw, track, progress_ms=None):
        # --- Barra de progresso estilo seekbar no topo da capa ---
        bar_width = 260  # Largura menor
        bar_height = 5
        bar_x = 70 + (298 - bar_width) // 2  # Centralizada em relação à capa
        bar_y = 153 - 30  # 30px acima da capa
        duration_ms = track.get("duration_ms", 225000)
        if progress_ms is None:
            progress_ms = 0
        # Proteção para não ultrapassar a barra
        if duration_ms <= 0:
            progress_width = 0
        else:
            progress_width = int((progress_ms / duration_ms) * bar_width)
            progress_width = min(progress_width, bar_width)
        # --- Desenhar barra de fundo (cinza médio) ---
        draw.rounded_rectangle(
            (bar_x, bar_y, bar_x + bar_width, bar_y + bar_height),
            radius=bar_height // 2,
            fill=(180, 180, 180, 255)  # Cinza mais escuro, mas ainda sutil
        )
        # --- Desenhar barra de progresso (preta) ---
        draw.rounded_rectangle(
            (bar_x, bar_y, bar_x + progress_width, bar_y + bar_height),
            radius=bar_height // 2,
            fill=(40, 40, 40, 255)
        )
        # --- Desenhar handle (círculo) ---
        handle_radius = 10
        handle_x = bar_x + progress_width
        handle_y = bar_y + bar_height // 2
        draw.ellipse(
            (handle_x - handle_radius, handle_y - handle_radius, handle_x + handle_radius, handle_y + handle_radius),
            fill=(40, 40, 40, 255)
        )
        # --- Tempo atual e total ---
        # Nota: Esta função só é chamada quando não é Last.FM com Spotify
        if True:  # Sempre mostrar tempos quando a barra é exibida
            def ms_to_minsec(ms):
                m = int(ms // 60000)
                s = int((ms % 60000) // 1000)
                return f"{m}:{s:02d}"
            font = ImageFont.truetype("/system/fonts/SourceSansPro-Regular.ttf", 24)
            time_current = ms_to_minsec(progress_ms)
            time_total = ms_to_minsec(duration_ms)
            # Tempo atual real à esquerda da barra
            left, top, right, bottom = font.getbbox("Ay")
            text_y = bar_y + bar_height // 2 - (bottom - top) // 2
            draw.text((bar_x, text_y - 28), time_current, font=font, fill=(40, 40, 40, 255))
            # Tempo total à direita da barra
            left, top, right, bottom = font.getbbox(time_total)
            draw.text((bar_x + bar_width - (right - left), text_y - 28), time_total, font=font, fill=(40, 40, 40, 255))

    def _generate_nowv_card(self, track, params=None, progress_ms=None, force_spotify=False, etg_cover_image=None, is_fm_command=False):
        """Gera o card do tema Nowv (1280x719) com capa central e overlays"""
        try:
            import io
            from PIL import Image, ImageDraw, ImageFilter, ImageOps, ImageFont

            W, H = 1280, 719
            canvas = Image.new("RGB", (W, H), (12, 12, 12))
            draw = ImageDraw.Draw(canvas)

            # Metadados
            title = track.get("name") or track.get("title") or "Unknown Track"
            artists_list = track.get("artists", [])
            if isinstance(artists_list, list) and artists_list and isinstance(artists_list[0], dict):
                artists = ", ".join([a.get("name", "") for a in artists_list])
            else:
                artists = track.get("artist") or track.get("artists_text") or "Unknown Artist"

            # Capa
            cover = None
            if etg_cover_image:
                try:
                    cover = Image.open(io.BytesIO(etg_cover_image)).convert("RGB")
                except Exception:
                    cover = None
            if cover is None:
                image_url = None
                images = track.get("album", {}).get("images", []) if isinstance(track.get("album"), dict) else []
                if images:
                    try:
                        image_url = max(images, key=lambda i: i.get("width", 0)).get("url")
                    except Exception:
                        image_url = images[0].get("url")
                if image_url:
                    try:
                        image_bytes = self._get_cached_image_enhanced(image_url, cache_key=image_url)
                        cover = Image.open(io.BytesIO(image_bytes)).convert("RGB")
                    except Exception:
                        cover = None
            if cover is None:
                try:
                    cover = self._get_fallback_cover(title, artists)
                    if cover:
                        cover = cover.convert("RGB")
                except Exception:
                    cover = None

            # Verificar se Banner Style está ativado
            banner_style = self.get_setting("nowv_banner_style", False)
            
            if banner_style:
                # Banner Style: Usar apenas fundo da capa sem efeitos
                if cover is not None:
                    bg = cover.copy()
                    # Redimensionar para cobrir o canvas mantendo proporção e recortar centralizado
                    try:
                        scale = max(W / float(bg.width), H / float(bg.height))
                        new_w = int(bg.width * scale)
                        new_h = int(bg.height * scale)
                        bg = bg.resize((new_w, new_h), Image.LANCZOS)
                        left = max(0, (new_w - W) // 2)
                        top = max(0, (new_h - H) // 2)
                        bg = bg.crop((left, top, left + W, top + H))
                    except Exception:
                        bg = bg.resize((W, H), Image.LANCZOS)
                    canvas = bg
                    draw = ImageDraw.Draw(canvas)
                else:
                    draw.rectangle([0, 0, W, H], fill=(20, 20, 22))
            else:
                # Modo normal: Fundo com efeitos
                bg_effect = self.get_setting("nowv_background_effect", 0)
                flip_bg = self.get_setting("nowv_flip_background", False)
                if cover is not None:
                    bg = cover.copy()
                    # Redimensionar para cobrir o canvas mantendo proporção e recortar centralizado
                    try:
                        scale = max(W / float(bg.width), H / float(bg.height))
                        new_w = int(bg.width * scale)
                        new_h = int(bg.height * scale)
                        bg = bg.resize((new_w, new_h), Image.LANCZOS)
                        left = max(0, (new_w - W) // 2)
                        top = max(0, (new_h - H) // 2)
                        bg = bg.crop((left, top, left + W, top + H))
                    except Exception:
                        # Fallback simples caso algo falhe
                        bg = bg.resize((W, H), Image.LANCZOS)
                    if flip_bg:
                        bg = ImageOps.mirror(bg)
                    if bg_effect == 1:  # Blur
                        bg = bg.filter(ImageFilter.GaussianBlur(24))
                    elif bg_effect == 2:  # Darker
                        overlay = Image.new("RGBA", (W, H), (0, 0, 0, 140))
                        bg = bg.convert("RGBA")
                        bg.alpha_composite(overlay)
                        bg = bg.convert("RGB")
                    elif bg_effect == 3:  # Both
                        bg = bg.filter(ImageFilter.GaussianBlur(24))
                        overlay = Image.new("RGBA", (W, H), (0, 0, 0, 140))
                        bg = bg.convert("RGBA")
                        bg.alpha_composite(overlay)
                        bg = bg.convert("RGB")
                    else:
                        overlay = Image.new("RGBA", (W, H), (0, 0, 0, 90))
                        bg = bg.convert("RGBA")
                        bg.alpha_composite(overlay)
                        bg = bg.convert("RGB")
                    canvas = bg
                    draw = ImageDraw.Draw(canvas)
                else:
                    draw.rectangle([0, 0, W, H], fill=(20, 20, 22))

            # Capa central e overlay (dependendo do modo)
            if banner_style:
                # Banner Style: Adicionar overlay baseado no NowvBar Style
                nowv_bar_style = self.get_setting("nowv_bar_style", 0)
                overlay_url = "https://raw.githubusercontent.com/soumaki/nowFy/refs/heads/main/bg/Style1.png" if nowv_bar_style == 0 else "https://raw.githubusercontent.com/soumaki/nowFy/refs/heads/main/bg/Style2.png"
                
                try:
                    # Baixar e aplicar overlay
                    overlay_data = self._get_cached_image_enhanced(overlay_url, f"nowv_overlay_style{nowv_bar_style + 1}")
                    if overlay_data:
                        overlay_img = Image.open(io.BytesIO(overlay_data)).convert("RGBA")
                        # Redimensionar overlay para o tamanho do canvas
                        overlay_img = overlay_img.resize((W, H), Image.LANCZOS)
                        # Aplicar overlay sobre o canvas
                        canvas = canvas.convert("RGBA")
                        canvas = Image.alpha_composite(canvas, overlay_img)
                        canvas = canvas.convert("RGB")
                        draw = ImageDraw.Draw(canvas)
                except Exception as e:
                    log(f"[NowFy] Erro ao aplicar overlay Banner Style: {e}")
            else:
                # Modo normal: Capa central com cantos arredondados e glass effect
                if cover is not None:
                    s = min(cover.width, cover.height)
                    l = (cover.width - s) // 2
                    t = (cover.height - s) // 2
                    cover_sq = cover.crop((l, t, l + s, t + s)).resize((512, 512), Image.LANCZOS)
                    mask = Image.new("L", (512, 512), 0)
                    mdraw = ImageDraw.Draw(mask)
                    try:
                        mdraw.rounded_rectangle((0, 0, 512, 512), radius=36, fill=255)
                    except Exception:
                        mdraw.rectangle((0, 0, 512, 512), fill=255)
                    cx = (W - 512) // 2
                    cy = 84
                    # Criar painel de vidro atrás da capa (glass effect)
                    try:
                        bg_region = canvas.crop((cx, cy, cx + 512, cy + 512))
                        blurred_bg = bg_region.filter(ImageFilter.GaussianBlur(12))
                        glass_overlay = Image.new("RGBA", (512, 512), (255, 255, 255, 48))
                        glass_panel = Image.alpha_composite(blurred_bg.convert("RGBA"), glass_overlay)
                        glass_panel.putalpha(mask)
                        canvas.paste(glass_panel, (cx, cy), glass_panel)
                    except Exception:
                        pass
                    canvas.paste(cover_sq, (cx, cy), mask)

            # Tipografia (apenas fonte de tempo; remover título e artista)
            font_selector = self.get_setting("font_selector", 0)
            try:
                time_font = ImageFont.truetype(self._get_font_regular_by_selector(font_selector), 22)
            except Exception:
                time_font = ImageFont.load_default()

            def text_w(font, text):
                try:
                    bbox = font.getbbox(text)
                    return bbox[2] - bbox[0]
                except Exception:
                    return draw.textlength(text, font=font)

            # Barra de progresso (NowvBar) - Compatível apenas com Spotify API, StatsFM e Apple Music
            current_player = self._detect_current_player()
            compatible_players = ["Spotify", "Apple Music"]
            
            # Verificar se é StatsFM (player pode ser "StatsFM" ou similar)
            is_statsfm = current_player == "StatsFM" or (hasattr(self, '_is_statsfm_mode') and self._is_statsfm_mode)
            
            duration_ms = track.get("duration_ms") or track.get("duration") or 0
            if (duration_ms and progress_ms is not None and 
                (current_player in compatible_players or is_statsfm or force_spotify)):
                
                try:
                    ratio = max(0.0, min(1.0, float(progress_ms) / float(duration_ms)))
                except Exception:
                    ratio = 0.0
                
                # Configurar NowvBar baseado no estilo selecionado
                nowv_bar_style = self.get_setting("nowv_bar_style", 0)
                
                if nowv_bar_style == 1:  # Style 2 - Compacto
                    bw = 512  # Largura da capa
                    bx = (W - bw) // 2  # Centralizado como a capa
                    by = H - 84
                else:  # Style 1 - Padrão
                    bw = 800
                    bx = (W - bw) // 2
                    by = H - 84
                
                # Usar ViniBar com efeito vidro (glass) como padrão
                self._draw_vinni_progress_bar_new(draw, track, progress_ms, time_font, bx, by, bw, use_blur_override=True)

            # Salvar e enviar
            temp_dir = File(ApplicationLoader.getFilesDirFixed(), "exteraFy")
            if not temp_dir.exists():
                temp_dir.mkdirs()
            temp_path = File(temp_dir, f"nowv_{int(time.time()*1000)}.png").getAbsolutePath()
            performance_mode = self.get_setting("performance_mode", 1)
            compress_level = 1 if performance_mode == 0 else 4 if performance_mode == 1 else 6
            canvas.save(temp_path, format="PNG", optimize=True, compress_level=compress_level)
            if params:
                self._send_card_with_caption(params, temp_path, track, force_spotify)
            return temp_path
        except Exception as e:
            log(f"[NowFy] Erro ao gerar card Nowv: {e}")
            try:
                if params:
                    self._send_msg(params, f"Erro: {e}")
            except Exception:
                pass
            return None

    def _send_card_with_caption(self, params, temp_path, track, force_spotify=False):
        """Envia o card com caption personalizada"""
        try:
            show_caption = self.get_setting("show_caption", True)
            # Verificar se está no modo NowCast para usar bot_caption
            is_nowcast_mode = getattr(self, '_nowcast_mode', False)
            
            # Verificar se show_caption está ativado
            if not show_caption:
                # Se show_caption está OFF, enviar apenas o card sem caption
                params["caption"] = ""
                self._send_photo(params, temp_path)
                return
            
            # Obter o estilo de caption selecionado
            caption_style_index = self.get_setting("caption_style", 0)
            caption_style_items = ["Custom", "Apple Based", "Pepe", "Minim", "Spoty"]
            caption_style = caption_style_items[caption_style_index] if caption_style_index < len(caption_style_items) else "Custom"
            
            if is_nowcast_mode:
                custom_caption = self.get_setting("bot_caption_text", "")
            else:
                custom_caption = self.get_setting("custom_footer_text", "")
            
            show_track_link = self.get_setting("show_track_link", True)
            platform_links = self.get_setting("platform_links", 0)  # 0=Spotify, 1=Universal, 2=Both
            
            # Detectar o player real para links corretos
            real_player = self._detect_current_player()
            # Se force_spotify=True (comando .now), usar Spotify para compatibilidade, mas manter player real para links
            if force_spotify:
                player = "Spotify"
                # Para temas Apple, usar o player real para links corretos
                link_player = real_player
            else:
                player = real_player
                link_player = real_player
            
            # Montar link/caption de acordo com o serviço selecionado
            caption_parts = []
            used_link_placeholders = False
            
            # Processar caption baseado no estilo selecionado
            if caption_style == "Custom":
                # Usar caption personalizado (comportamento original)
                if custom_caption:
                    # Processar variáveis {track}, {artist} e {album} no custom caption
                    processed_caption = custom_caption.strip()
                    if "{track}" in processed_caption or "{artist}" in processed_caption or "{album}" in processed_caption or "{spotify}" in processed_caption or "{song}" in processed_caption:
                        title = track.get("name", "Unknown Track")
                        artists = ", ".join([a["name"] for a in track.get("artists", [])]) if track.get("artists") else "Unknown Artist"
                        album = track.get("album", {}).get("name", "Unknown Album") if track.get("album") else "Unknown Album"
                        # Links para placeholders
                        spotify_link = None
                        try:
                            external_urls = track.get("external_urls")
                            if isinstance(external_urls, dict):
                                spotify_link = external_urls.get("spotify")
                        except Exception:
                            spotify_link = None
                        song_link_url = None
                        try:
                            if spotify_link:
                                song_link_url = self._get_song_link(spotify_link)
                        except Exception:
                            song_link_url = None
                        processed_caption = processed_caption.replace("{track}", title)
                        processed_caption = processed_caption.replace("{artist}", artists)
                        processed_caption = processed_caption.replace("{album}", album)
                        # Substituição dos novos placeholders {spotify} e {song}
                        if "{spotify}" in processed_caption:
                            processed_caption = processed_caption.replace("{spotify}", spotify_link or "")
                        if "{song}" in processed_caption:
                            processed_caption = processed_caption.replace("{song}", song_link_url or "")
                        # Marcar que placeholders de link foram usados para evitar duplicação de links automáticos
                        used_link_placeholders = ("{spotify}" in custom_caption) or ("{song}" in custom_caption)
                    caption_parts.append(processed_caption)
            else:
                # Usar template predefinido
                title = track.get("name", "Unknown Track")
                artists = ", ".join([a["name"] for a in track.get("artists", [])]) if track.get("artists") else "Unknown Artist"
                album = track.get("album", {}).get("name", "Unknown Album") if track.get("album") else "Unknown Album"
                
                track_data = {
                    "name": title,
                    "artist": artists,
                    "album": album
                }
                
                template_caption = self._get_caption_template(caption_style, track_data)
                if template_caption:
                    caption_parts.append(template_caption)
            
            # Adicionar links apenas se show_track_link estiver ativado e não houver links via placeholders
            if show_track_link and not used_link_placeholders:
                # Verificar se estamos usando Last.FM com Spotify configurado
                media_source = self.get_setting("media_source", 0)
                current_player_setting = self.get_setting("current_player", 0)
                is_lastfm_with_spotify = media_source == 1 and current_player_setting == 0  # Last.FM + Spotify
                
                if link_player == "Spotify" or is_lastfm_with_spotify:
                    spotify_link = track["external_urls"]["spotify"]
                    
                    # Lógica baseada no novo Platform Links selector
                    if platform_links == 0:  # Spotify only
                        caption_parts.append(f"[Spotify]({spotify_link})")
                    elif platform_links == 1:  # Universal only
                        song_link_url = self._get_song_link(spotify_link)
                        caption_parts.append(f"[song.link]({song_link_url})")
                    elif platform_links == 2:  # Both
                        caption_parts.append(f"[Spotify]({spotify_link})")
                        song_link_url = self._get_song_link(spotify_link)
                        caption_parts.append(f"[song.link]({song_link_url})")

                elif link_player == "YouTube":
                    search_query = f"{track['name']} {', '.join([a['name'] for a in track['artists']])} official music video"
                    yt_link = f"https://www.youtube.com/results?search_query={quote(search_query)}"
                    caption_parts.append(f"[YouTube]({yt_link})")

                elif link_player == "YouTube Music":
                    search_query = f"{track['name']} {', '.join([a['name'] for a in track['artists']])}"
                    ytm_link = f"https://music.youtube.com/search?q={quote(search_query)}"
                    caption_parts.append(f"[YouTube Music]({ytm_link})")

                elif link_player == "SoundCloud":
                    external_urls = track.get("external_urls")
                    soundcloud_url = None
                    if isinstance(external_urls, dict):
                        soundcloud_url = external_urls.get("soundcloud")
                    if not soundcloud_url:
                        search_query = f"{track['name']} {', '.join([a['name'] for a in track['artists']])}"
                        soundcloud_url = f"https://soundcloud.com/search?q={quote(search_query)}"
                    caption_parts.append(f"[SoundCloud]({soundcloud_url})")

                elif link_player == "Apple Music":
                    # Gerar link de busca do Apple Music
                    search_query = f"{track['name']} {', '.join([a['name'] for a in track['artists']])}"
                    apple_music_url = f"https://music.apple.com/search?term={quote(search_query)}"
                    caption_parts.append(f"[Apple Music]({apple_music_url})")

                elif link_player == "Yandex Music":
                    # Usar song.link como universal para Yandex Music
                    if track.get("external_urls", {}).get("spotify"):
                        spotify_link = track["external_urls"]["spotify"]
                        song_link_url = self._get_song_link(spotify_link)
                        caption_parts.append(f"[Yandex Music]({song_link_url})")

                elif link_player in ["exteraGram", "AyuGram"]:
                    # Adicionar link específico para exteraGram/AyuGram
                    display_name = "AyuGram" if link_player == "AyuGram" else "exteraGram"
                    username = self.get_setting("exteragram_username", "").strip()
                    if username.startswith("@"):
                        username = username[1:]
                        if not username:
                            link = "https://t.me/exteraGram" if link_player == "exteraGram" else "https://t.me/ayugram"
                        else:
                            link = f"https://t.me/{username}"
                        caption_parts.append(f"[{display_name}]({link})")

                    # Se nenhum, usar song.link apenas para players .fm (media source) que não sejam Last.FM com Spotify
                    elif link_player not in ["exteraGram", "AyuGram"] and ".fm" in link_player.lower() and not is_lastfm_with_spotify:
                        spotify_link = track["external_urls"]["spotify"]
                        song_link_url = self._get_song_link(spotify_link)
                        caption_parts.append(f"[song.link]({song_link_url})")

                # Adicionar link FM baseado na seleção do usuário
                fm_link_option = self.get_setting("fm_link_option", 0)
                if fm_link_option == 1:  # LastFM
                    lastfm_user = self.get_setting("lastfm_user", "")
                    if lastfm_user:
                        caption_parts.append(f"[Last.FM](https://www.last.fm/user/{lastfm_user})")
                elif fm_link_option == 2:  # StatsFM
                    statsfm_username = self.get_setting("statsfm_username", "")
                    if statsfm_username:
                        caption_parts.append(f"[Stats.FM](https://stats.fm/{statsfm_username})")
                elif fm_link_option == 3:  # Custom Link para FM
                    custom_url = self.get_setting("fm_custom_link_url", "")
                    custom_name = self.get_setting("fm_custom_player_name", "Custom Player")
                    if custom_url:
                        caption_parts.append(f"[{custom_name}]({custom_url})")

            # Montar caption final
            caption = " • ".join(caption_parts)
            if caption and params:
                # Processar emojis premium (sempre habilitado)
                caption = self._process_premium_emojis(caption)
                
                caption_md = parse_markdown(caption)
                # Atribuição segura de caption/entities para objetos ou dicionários
                try:
                    params.caption = caption_md.text
                    params.entities = ArrayList()
                    for entity in caption_md.entities:
                        params.entities.add(entity.to_tlrpc_object())
                    is_attr_params = True
                except Exception:
                    is_attr_params = False
                    try:
                        params["caption"] = caption_md.text
                        params["entities"] = [entity.to_tlrpc_object() for entity in caption_md.entities]
                    except Exception as e:
                        log(f"[NowFy] Falha ao definir caption/entities no params: {e}")

                send_helper = get_send_messages_helper()
                photo = send_helper.generatePhotoSizes(temp_path, None)
                # Atribuição segura de photo/path/message
                try:
                    params.photo = photo
                    params.path = temp_path
                    params.message = None
                except Exception:
                    try:
                        params["photo"] = photo
                        params["path"] = temp_path
                        params["message"] = None
                    except Exception as e:
                        log(f"[NowFy] Falha ao definir photo/path/message no params: {e}")

                # Verificar se está no modo NowCast
                if hasattr(self, '_nowcast_mode') and self._nowcast_mode:
                    # Enviar via API do bot para o NowCast
                    self._send_nowcast_image_via_bot(temp_path, caption)
                    if bool(self.get_setting("enable_quick_dismiss", True)):
                        run_on_ui_thread(self._dismiss_loading_dialog)
                else:
                    # Envio normal via Telegram
                    if is_attr_params:
                        run_on_ui_thread(lambda: send_helper.sendMessage(params))
                        if bool(self.get_setting("enable_quick_dismiss", True)):
                            run_on_ui_thread(self._dismiss_loading_dialog)
                        try:
                            run_on_ui_thread(self._trigger_send_ripple)
                        except Exception:
                            pass
                    else:
                        # Fallback: se params for dict, enviar via API do bot para evitar incompatibilidade
                        self._send_nowcast_image_via_bot(temp_path, caption)
                        if bool(self.get_setting("enable_quick_dismiss", True)):
                            run_on_ui_thread(self._dismiss_loading_dialog)

                # Atualizar bio após o envio do card
                if self.get_setting("enable_autobio", False):
                    autobio_text = self.get_setting("autobio_text", "Now Playing: {track} by {artist}")
                    bio = autobio_text.format(track=track["name"], artist=", ".join([a["name"] for a in track["artists"]]))
                    run_on_ui_thread(lambda: self._update_bio(bio, show_bulletin=False))

                # Reativar/atualizar o Dynamic Island com a faixa atual
                if str(getattr(self, "_last_overlay_trigger_command", "")) == ".stats":
                    pass
                else:
                    try:
                        title_di = track.get("name", "")
                        artists_di = ", ".join([a["name"] for a in track.get("artists", [])]) if track.get("artists") else ""
                        image_url_di = None
                        try:
                            image_url_di = track.get("image_url")
                            if not image_url_di:
                                images = track.get("album", {}).get("images", []) if isinstance(track.get("album"), dict) else []
                                if images:
                                    try:
                                        image_url_di = max(images, key=lambda i: i.get("width", 0)).get("url")
                                    except Exception:
                                        try:
                                            image_url_di = images[0].get("url")
                                        except Exception:
                                            image_url_di = None
                        except Exception:
                            image_url_di = None
                        try:
                            td = self._get_current_track_for_nowcast()
                            import android_utils as _au
                            fn = getattr(_au, "run_on_ui_thread", None)
                            was_active = bool(getattr(self, "_di_is_active", False))
                            if fn:
                                try:
                                    from org.telegram.messenger import R as R_tg
                                    icon_res = R_tg.raw.chats_infotip
                                except Exception:
                                    icon_res = 0
                                fragment = get_last_fragment()
                                def _shorten(text, max_len=48):
                                    try:
                                        s = str(text)
                                        return s if len(s) <= max_len else s[:max_len - 1] + "…"
                                    except Exception:
                                        return text
                                def _ui():
                                    if (
                                        bool(self.get_setting("dynamic_island_overlay", False))
                                        and not bool(getattr(self, "_di_is_active", False))
                                        and bool(getattr(self, "_di_closed_by_user", False))
                                        and str(getattr(self, "_last_overlay_trigger_command", "")) in (".now", ".stats")
                                    ):
                                        title = tr("pop_island_title") if "pop_island_title" in TRANSLATIONS else "Floatify"
                                        subtitle = _shorten(tr("overlay_island_prompt_subtitle_short") if "overlay_island_prompt_subtitle_short" in TRANSLATIONS else "Floatify is enabled. Start now?")
                                        button_text = _shorten(tr("overlay_enable_bulletin_action_short") if "overlay_enable_bulletin_action_short" in TRANSLATIONS else "Start now")
                                        try:
                                            BulletinHelper.show_two_line(
                                                title,
                                                subtitle,
                                                icon_res,
                                                fragment
                                            )
                                        except Exception:
                                            pass
                                        try:
                                            BulletinHelper.show_with_button(
                                                title,
                                                icon_res,
                                                button_text,
                                                lambda: (
                                                    setattr(self, "_di_closed_by_user", False),
                                                    self._safe_start_dynamic_island_overlay(),
                                                    self._update_dynamic_island_content(td)
                                                ),
                                                fragment
                                            )
                                        except Exception:
                                            pass
                                    else:
                                        self._safe_start_dynamic_island_overlay()
                                        self._update_dynamic_island_content(td)
                                        try:
                                            if (
                                                not was_active
                                                and bool(getattr(self, "_di_is_active", False))
                                                and str(getattr(self, "_last_overlay_trigger_command", "")) in (".now", ".stats")
                                            ):
                                                BulletinHelper.show_two_line(
                                                    tr("overlay_island_started_title"),
                                                    tr("overlay_island_started_subtitle"),
                                                    icon_res,
                                                    fragment
                                                )
                                        except Exception:
                                            pass
                                fn(_ui)
                            else:
                                raise Exception("no run_on_ui_thread")
                        except Exception:
                            try:
                                td = self._get_current_track_for_nowcast()
                                was_active = bool(getattr(self, "_di_is_active", False))
                                if (
                                    bool(self.get_setting("dynamic_island_overlay", False))
                                    and not bool(getattr(self, "_di_is_active", False))
                                    and bool(getattr(self, "_di_closed_by_user", False))
                                    and str(getattr(self, "_last_overlay_trigger_command", "")) in (".now", ".stats")
                                ):
                                    try:
                                        try:
                                            from org.telegram.messenger import R as R_tg
                                            icon_res = R_tg.raw.chats_infotip
                                        except Exception:
                                            icon_res = 0
                                        fragment = get_last_fragment()
                                        def _shorten(text, max_len=48):
                                            try:
                                                s = str(text)
                                                return s if len(s) <= max_len else s[:max_len - 1] + "…"
                                            except Exception:
                                                return text
                                        title = tr("pop_island_title") if "pop_island_title" in TRANSLATIONS else "Floatify"
                                        subtitle = _shorten(tr("overlay_island_prompt_subtitle_short") if "overlay_island_prompt_subtitle_short" in TRANSLATIONS else "Floatify is enabled. Start now?")
                                        button_text = _shorten(tr("overlay_enable_bulletin_action_short") if "overlay_enable_bulletin_action_short" in TRANSLATIONS else "Start now")
                                        try:
                                            BulletinHelper.show_two_line(
                                                title,
                                                subtitle,
                                                icon_res,
                                                fragment
                                            )
                                        except Exception:
                                            pass
                                        try:
                                            BulletinHelper.show_with_button(
                                                title,
                                                icon_res,
                                                button_text,
                                                lambda: (setattr(self, "_di_closed_by_user", False), self._safe_start_dynamic_island_overlay(), self._update_dynamic_island_content(td)),
                                                fragment
                                            )
                                        except Exception:
                                            pass
                                    except Exception:
                                        pass
                                else:
                                    self._safe_start_dynamic_island_overlay()
                                    self._update_dynamic_island_content(td)
                                    try:
                                        if not was_active and bool(getattr(self, "_di_is_active", False)):
                                            fragment = get_last_fragment()
                                            try:
                                                from org.telegram.messenger import R as R_tg
                                                icon_res = R_tg.raw.chats_infotip
                                            except Exception:
                                                icon_res = 0
                                            BulletinHelper.show_two_line(
                                                tr("overlay_island_started_title"),
                                                tr("overlay_island_started_subtitle"),
                                                icon_res,
                                                fragment
                                            )
                                    except Exception:
                                        pass
                            except Exception:
                                pass
                    except Exception:
                        pass

                if bool(self.get_setting("enable_quick_dismiss", True)):
                    run_on_ui_thread(self._dismiss_loading_dialog)

        except Exception as e:
            if params:
                self._send_msg(params, f"Erro: {e}")

    def _generate_external_theme_card(self, track, params=None, progress_ms=None, theme_id=None, theme_data=None, force_spotify=False, etg_cover_image=None):
        """Gera card usando tema externo do plugin 'Themes for NowFy'"""
        player = "Spotify" if force_spotify else self._detect_current_player()
        
        # Temas Apple removidos do seletor
        
        title = track.get("name") or ""
        artist = ", ".join([a["name"] for a in track.get("artists", [])]) if isinstance(track.get("artists"), list) else ""
        
        # Verificar se há uma imagem de capa do ETG e adicioná-la ao track
        if etg_cover_image and player in ["exteraGram", "AyuGram", "Telegram"]:
            track["etg_cover_image"] = etg_cover_image

        if player == "SoundCloud":
            youtube_cover_url = self._get_youtube_cover(title, artist)
            # Forçar uso de thumbnails mesmo se a API falhar
            if youtube_cover_url == "https://i.postimg.cc/4yjVLFTV/icondefault.png":
                youtube_cover_url = self._get_youtube_thumbnail_forced(title, artist)
            if youtube_cover_url and "icondefault.png" not in youtube_cover_url:
                track["image_url"] = youtube_cover_url
        # Fallback geral: se não houver image_url, tentar álbum ou YouTube (unificado)
        if not track.get("image_url"):
            images = track.get("album", {}).get("images", []) if isinstance(track.get("album"), dict) else []
            image_url = None
            if images:
                try:
                    image_url = max(images, key=lambda i: i.get("width", 0)).get("url")
                except Exception:
                    try:
                        image_url = images[0].get("url")
                    except Exception:
                        image_url = None
            if image_url:
                track["image_url"] = image_url
            else:
                youtube_cover_url = self._get_youtube_cover(title, artist)
                if youtube_cover_url == "https://i.postimg.cc/4yjVLFTV/icondefault.png":
                    youtube_cover_url = self._get_youtube_thumbnail_forced(title, artist)
                if youtube_cover_url and "icondefault.png" not in youtube_cover_url:
                    track["image_url"] = youtube_cover_url
        try:
            log(f"[NowFy] Generating external theme card: {theme_id}")
            
            # ========================================
            # SISTEMA DE TEMAS EXTERNOS V1.0
            # ========================================
            # IMPORTANTE: Todos os temas adicionais devem estar no plugin themes_for_nowfy.plugin
            # ========================================
            # Método 1: Tentar via PluginsController
            try:
                from com.exteragram.messenger.plugins import PluginsController
                plugins_controller = PluginsController.getInstance()
                log(f"[NowFy] PluginsController obtained: {plugins_controller is not None}")
                
                if plugins_controller:
                    # Buscar o plugin themes_for_nowfy
                    themes_plugin = plugins_controller.getPlugin("themes_for_nowfy")
                    log(f"[NowFy] Themes plugin found: {themes_plugin is not None}")
                    
                    if themes_plugin:
                        log(f"[NowFy] Themes plugin has generate_theme_card: {hasattr(themes_plugin, 'generate_theme_card')}")
                        
                        if hasattr(themes_plugin, 'generate_theme_card_direct'):
                            log(f"[NowFy] Calling generate_theme_card_direct for theme: {theme_id}")
                            image_path = themes_plugin.generate_theme_card_direct(theme_id, track, params, progress_ms)
                            log(f"[NowFy] generate_theme_card_direct result: {image_path}")
                            if image_path and params:
                                log(f"[NowFy] External theme card generated, sending with custom caption")
                                self._send_card_with_caption(params, image_path, track, force_spotify)
                                return
                            else:
                                log(f"[NowFy] generate_theme_card_direct returned False or no params")
                        elif hasattr(themes_plugin, 'generate_theme_card'):
                            log(f"[NowFy] Calling generate_theme_card for theme: {theme_id}")
                            success = themes_plugin.generate_theme_card(theme_id, track, params, progress_ms)
                            log(f"[NowFy] generate_theme_card result: {success}")
                            if success:
                                log(f"[NowFy] External theme card generated successfully")
                                return
                            else:
                                log(f"[NowFy] generate_theme_card returned False")
                        else:
                            log(f"[NowFy] Themes plugin doesn't have generate_theme_card method")
                    else:
                        log(f"[NowFy] Themes plugin not found")
                else:
                    log(f"[NowFy] PluginsController is None")
            except Exception as e:
                log(f"[NowFy] Error accessing themes plugin via PluginsController: {e}")
                
            # Método 2: Tentar importar diretamente o módulo
            try:
                import themes_for_nowfy
                if hasattr(themes_for_nowfy, 'get_themes_plugin_instance'):
                    themes_plugin = themes_for_nowfy.get_themes_plugin_instance()
                    log(f"[NowFy] Themes plugin instance obtained via import: {themes_plugin is not None}")
                    
                    if themes_plugin and hasattr(themes_plugin, 'generate_theme_card_direct'):
                        log(f"[NowFy] Calling generate_theme_card_direct via import for theme: {theme_id}")
                        image_path = themes_plugin.generate_theme_card_direct(theme_id, track, params, progress_ms)
                        log(f"[NowFy] generate_theme_card_direct result via import: {image_path}")
                        if image_path and params:
                            log(f"[NowFy] External theme card generated via import, sending with custom caption")
                            self._send_card_with_caption(params, image_path, track, force_spotify)
                            return
                    elif themes_plugin and hasattr(themes_plugin, 'generate_theme_card'):
                        log(f"[NowFy] Calling generate_theme_card via import for theme: {theme_id}")
                        success = themes_plugin.generate_theme_card(theme_id, track, params, progress_ms)
                        log(f"[NowFy] generate_theme_card result via import: {success}")
                        if success:
                            log(f"[NowFy] External theme card generated successfully via import")
                            return
            except Exception as e:
                log(f"[NowFy] Error accessing themes plugin via import: {e}")
                import traceback
                log(f"[NowFy] Traceback: {traceback.format_exc()}")
            
            # Método 3: Tentar via comunicação por arquivo JSON
            try:
                import os
                from java.io import File
                from org.telegram.messenger import ApplicationLoader
                
                # Criar diretório de comunicação se não existir
                comm_dir = File(ApplicationLoader.getFilesDirFixed(), "nowfy_communication")
                if not comm_dir.exists():
                    comm_dir.mkdirs()
                
                # Escrever dados do tema para o arquivo JSON
                theme_request = {
                    "action": "generate_theme_card",
                    "theme_id": theme_id,
                    "track": track,
                    "progress_ms": progress_ms,
                    "timestamp": datetime.now().isoformat()
                }
                
                request_file = File(comm_dir, "theme_request.json")
                with open(request_file.getAbsolutePath(), 'w', encoding='utf-8') as f:
                    json.dump(theme_request, f, ensure_ascii=False, indent=2)
                
                log(f"[NowFy] Theme request written to JSON file")
                
                # Aguardar um pouco para o plugin de temas processar
                import time
                time.sleep(0.5)
                
                # Verificar se o plugin de temas respondeu
                response_file = File(comm_dir, "theme_response.json")
                if response_file.exists():
                    with open(response_file.getAbsolutePath(), 'r', encoding='utf-8') as f:
                        response = json.load(f)
                    
                    if response.get("success") and response.get("image_path"):
                        log(f"[NowFy] Theme response received: {response.get('image_path')}")
                        # Enviar o card gerado pelo plugin de temas com caption customizável
                        if params:
                            self._send_card_with_caption(params, response.get("image_path"), track, force_spotify)
                        return
                    else:
                        log(f"[NowFy] Theme response indicates failure: {response.get('error', 'Unknown error')}")
                
                # Limpar arquivos de comunicação
                if request_file.exists():
                    request_file.delete()
                if response_file.exists():
                    response_file.delete()
                
            except Exception as e:
                log(f"[NowFy] Error in JSON communication method: {e}")
            
            # Fallback: informar erro se não conseguir acessar o plugin de temas
            log(f"[NowFy] All methods failed, unable to generate external theme card")
            if params:
                self._send_msg(params, "Erro: Não foi possível gerar o card do tema Apple Light. Verifique se o plugin 'Themes for NowFy' está ativo.")
                
        except Exception as e:
            log(f"[NowFy] Error generating external theme card: {e}")
            if params:
                self._send_msg(params, f"Erro ao gerar tema externo: {e}")


    def _generate_external_lastfm_theme_card(self, title, artist, album, image_url, params, progress_dialog, player, youtube_url, etg_cover_image, theme_data):
        """Gera card do LastFM usando tema externo do plugin 'Themes for NowFy'"""
        try:
            log(f"[NowFy] Generating external LastFM theme card: {theme_data['name']}")
            
            # Configurações do tema
            colors = theme_data.get("colors", {})
            bg_color = colors.get("background", "#ffffff")
            text_primary = colors.get("text_primary", "#000000")
            text_secondary = colors.get("text_secondary", "#666666")
            accent_color = colors.get("accent", "#1db954")
            
            # Usar o tema CustomFM do LastFM - StatsFM
            return self._get_current_track_lastfm_customfm(title, artist, album, image_url, params, progress_dialog, player, youtube_url, etg_cover_image)
            
        except Exception as e:
            log(f"[NowFy] Error generating external LastFM theme card: {e}")
            # Fallback para tema CustomFM
            return self._get_current_track_lastfm_customfm(title, artist, album, image_url, params, progress_dialog, player, youtube_url, etg_cover_image)

    # --- HOOK DE MENSAGEM ---
    def on_send_message_hook(self, account, params):
        if not hasattr(params, "message") or not isinstance(params.message, str):
            return HookResult()
        msg = params.message.strip()
        custom_cmd = self.get_setting("custom_command", ".now")
        # Captura antecipada do comando .code para garantir interceptação
        # Suporta variações: ".code <url|code>", ".code\n<url|code>", ou sem espaço
        import re
        if msg.startswith(".code ") or msg == ".code" or re.match(r"^\s*\.code\b", msg):
            progress_dialog = None
            try:
                fragment = get_last_fragment()
                from ui.alert import AlertDialogBuilder
                from org.telegram.messenger import ApplicationLoader
                ctx = fragment.getParentActivity() if fragment and fragment.getParentActivity() else ApplicationLoader.applicationContext
                progress_dialog = AlertDialogBuilder(ctx, AlertDialogBuilder.ALERT_TYPE_LOADING)
                progress_dialog.set_message(tr("exchanging_code") if "exchanging_code" in TRANSLATIONS else "Trocando código...")
                progress_dialog.show()
            except Exception as e:
                log(f"[Nowfy] Falha ao criar progress dialog para .code: {e}")
            def run_code():
                try:
                    if progress_dialog:
                        run_on_ui_thread(lambda: progress_dialog.set_progress(30))
                    time.sleep(0.5)
                    # Extrair o código da mensagem em diferentes formatos
                    raw_payload = ""
                    if " " in msg:
                        raw_payload = msg.split(" ", 1)[1].strip()
                    else:
                        parts = msg.splitlines()
                        if len(parts) >= 2:
                            raw_payload = "\n".join(parts[1:]).strip()
                    # Se não houver payload, informar falta de código
                    if not raw_payload:
                        run_on_ui_thread(lambda: BulletinHelper.show_info(tr("error_missing_code")))
                        if progress_dialog:
                            run_on_ui_thread(lambda: progress_dialog.dismiss())
                        return
                    # Se vier uma URL, tentar extrair o parâmetro code
                    code = raw_payload
                    if raw_payload.startswith("http://") or raw_payload.startswith("https://"):
                        try:
                            # Extrair após "code=" e antes de "&"
                            if "code=" in raw_payload:
                                code = raw_payload.split("code=")[-1].split("&")[0]
                        except Exception:
                            pass
                    elif "code=" in raw_payload:
                        code = raw_payload.split("code=")[-1].split("&")[0]
                    client_id = self.get_setting("client_id", "")
                    client_secret = self.get_setting("client_secret", "")
                    if not client_id or not client_secret:
                        run_on_ui_thread(lambda: BulletinHelper.show_error(tr("client_id_or_secret_missing")))
                        if progress_dialog:
                            run_on_ui_thread(lambda: progress_dialog.dismiss())
                        return
                    success, error_msg = self._exchange_code(code)
                    if progress_dialog:
                        run_on_ui_thread(lambda: progress_dialog.set_progress(70))
                    time.sleep(0.5)
                    if success:
                        run_on_ui_thread(lambda: BulletinHelper.show_success(tr("refresh_token_saved") if "refresh_token_saved" in TRANSLATIONS else "Refresh Token salvo com sucesso"))
                    else:
                        error_display = error_msg if error_msg else (tr("code_exchange_error") if "code_exchange_error" in TRANSLATIONS else "Erro ao trocar código")
                        run_on_ui_thread(lambda: BulletinHelper.show_info(f"Erro: {error_display}"))
                    if progress_dialog:
                        run_on_ui_thread(lambda: progress_dialog.set_progress(100))
                    time.sleep(0.2)
                except Exception as e:
                    run_on_ui_thread(lambda: BulletinHelper.show_info(f"Erro: {str(e)}"))
                finally:
                    if progress_dialog:
                        run_on_ui_thread(lambda: progress_dialog.dismiss())
            run_on_queue(run_code)
            return HookResult(strategy=HookStrategy.CANCEL)

        # Captura antecipada do comando .import com feedback visual
        if msg == ".import" or re.match(r"^\s*\.import\b", msg):
            progress_dialog = None
            try:
                fragment = get_last_fragment()
                from ui.alert import AlertDialogBuilder
                from org.telegram.messenger import ApplicationLoader
                ctx = fragment.getParentActivity() if fragment and fragment.getParentActivity() else ApplicationLoader.applicationContext
                progress_dialog = AlertDialogBuilder(ctx, AlertDialogBuilder.ALERT_TYPE_LOADING)
                progress_dialog.set_message(tr("backup_import_starting"))
                progress_dialog.show()
            except Exception as e:
                log(f"[NowFy] Falha ao criar progress dialog para .import: {e}")
            def _run_import():
                try:
                    if progress_dialog:
                        self._import_backup_with_progress(progress_dialog, params)
                    else:
                        self._import_backup(params)
                except Exception as e:
                    from ui.bulletin import BulletinHelper
                    err_title = tr("backup_import_error")
                    run_on_ui_thread(lambda: BulletinHelper.show_info(f"{err_title}: {str(e)}"))
                finally:
                    if progress_dialog:
                        run_on_ui_thread(lambda: progress_dialog.dismiss())
            run_on_queue(_run_import)
            try:
                params.message = ""
            except Exception:
                pass
            return HookResult(strategy=HookStrategy.CANCEL)
        if msg == custom_cmd:
            run_on_queue(lambda: self._trigger_chat_list_refresh())
            run_on_queue(lambda: self._handle_now_restore_bio(params))
            return HookResult(strategy=HookStrategy.CANCEL)
        
        if msg == ".bot":
            run_on_queue(lambda: self._handle_bot_command(params))
            return HookResult(strategy=HookStrategy.CANCEL)
        if msg == ".player":
            try:
                fragment = get_last_fragment()
                from ui.alert import AlertDialogBuilder
                ctx = fragment.getParentActivity() if fragment and fragment.getParentActivity() else ApplicationLoader.applicationContext
                players = [
                    "Spotify", "YouTube", "YouTube Music", "exteraGram",
                    "AyuGram", "SoundCloud", "Apple Music", "Yandex Music", "FM"
                ]

                def on_item_click(bld, which):
                    try:
                        self.set_setting("current_player", which)
                        BulletinHelper.show_info(f"{tr('active_player')}: {players[which]}")
                    except Exception as e:
                        log(f"[Nowfy] Error setting active player: {e}")
                    finally:
                        try:
                            bld.dismiss()
                        except Exception:
                            pass

                builder = AlertDialogBuilder(ctx)
                builder.set_title(tr("active_player"))
                builder.set_items(players, on_item_click)
                builder.set_negative_button(
                    tr("cancel") if "cancel" in TRANSLATIONS else "Cancelar",
                    lambda b, w: b.dismiss()
                )
                run_on_ui_thread(builder.show)
            except Exception as e:
                log(f"[Nowfy] Error showing player selector: {e}")
            return HookResult(strategy=HookStrategy.CANCEL)
        # Comando .ver: verificar versão e mostrar status com botão de atualização
        if msg == ".ver" or re.match(r"^\s*\.ver\b", msg):
            run_on_queue(lambda: self._check_version_async(True))
            try:
                params.message = ""
            except Exception:
                pass
            return HookResult(strategy=HookStrategy.CANCEL)
        if msg.startswith(".setkey "):
            self.set_setting("lastfm_api_key", msg.split(" ", 1)[1].strip())
            BulletinHelper.show_success(tr("lastfm_key_saved"))
            return HookResult(strategy=HookStrategy.CANCEL)

        if msg.startswith(".setuser "):
            self.set_setting("lastfm_username", msg.split(" ", 1)[1].strip())
            BulletinHelper.show_success(tr("lastfm_user_saved"))
            return HookResult(strategy=HookStrategy.CANCEL)
        if msg == ".list":
            run_on_queue(lambda: self._get_recently_played(params))
            return HookResult(strategy=HookStrategy.CANCEL)
        if msg == ".play":
            run_on_queue(lambda: self._resume_playback_only(params))
            return HookResult(strategy=HookStrategy.CANCEL)
        if msg == ".pause":
            run_on_queue(lambda: self._pause_playback_only(params))
            return HookResult(strategy=HookStrategy.CANCEL)
        if msg == ".skip":
            run_on_queue(lambda: self._skip_track(params))
            return HookResult(strategy=HookStrategy.CANCEL)
        if msg == ".back":
            run_on_queue(lambda: self._previous_track(params))
            return HookResult(strategy=HookStrategy.CANCEL)
        if msg == ".vol":
            BulletinHelper.show_info(tr("error_missing_volume"))
            return HookResult(strategy=HookStrategy.CANCEL)
        if msg == ".repeat":
            BulletinHelper.show_info(tr("error_missing_repeat"))
            return HookResult(strategy=HookStrategy.CANCEL)
        if msg == ".code":
            BulletinHelper.show_info(tr("error_missing_code"))
            return HookResult(strategy=HookStrategy.CANCEL)
        if msg == ".setid":
            BulletinHelper.show_info(tr("error_missing_setid"))
            return HookResult(strategy=HookStrategy.CANCEL)
        if msg == ".setsecret":
            BulletinHelper.show_info(tr("error_missing_setsecret"))
            return HookResult(strategy=HookStrategy.CANCEL)
        if msg == ".like":
            BulletinHelper.show_info(tr("error_missing_like"))
            return HookResult(strategy=HookStrategy.CANCEL)
        if msg == ".like now":
            run_on_queue(lambda: self._like_current_track(params))
            return HookResult(strategy=HookStrategy.CANCEL)
        if msg == ".guide":
            run_on_ui_thread(self._show_guide_dialog)
            return HookResult(strategy=HookStrategy.CANCEL)
        if msg.startswith(".vol "):
            try:
                value = int(msg.split(" ", 1)[1].strip())
            except Exception:
                value = -1
            run_on_queue(lambda: self._set_volume(params, value))
            return HookResult(strategy=HookStrategy.CANCEL)
        if msg.startswith(".repeat "):
            mode = msg.split(" ", 1)[1].strip().lower()
            run_on_queue(lambda: self._set_repeat(params, mode))
            return HookResult(strategy=HookStrategy.CANCEL)
        if msg.startswith(".like "):
            track_id = msg.split(" ", 1)[1].strip()
            run_on_queue(lambda: self._like_track(params, track_id))
            return HookResult(strategy=HookStrategy.CANCEL)
        if msg.startswith(".code "):
            fragment = get_last_fragment()
            ctx = fragment.getParentActivity() if fragment and fragment.getParentActivity() else ApplicationLoader.applicationContext
            progress_dialog = AlertDialogBuilder(ctx, AlertDialogBuilder.ALERT_TYPE_LOADING)
            progress_dialog.set_message(tr("exchanging_code"))
            progress_dialog.show()
            def run_code():
                try:
                    run_on_ui_thread(lambda: progress_dialog.set_progress(30))
                    time.sleep(0.5)
                    code = msg.split(" ", 1)[1].strip()
                    if "code=" in code:
                        code = code.split("code=")[1].split("&")[0] if "&" in code else code.split("code=")[1]
                    client_id = self.get_setting("client_id", "")
                    client_secret = self.get_setting("client_secret", "")
                    if not client_id or not client_secret:
                        run_on_ui_thread(lambda: BulletinHelper.show_info(tr("client_id_or_secret_missing")))
                        run_on_ui_thread(lambda: progress_dialog.dismiss())
                        return
                    
                    success, error_msg = self._exchange_code(code)
                    run_on_ui_thread(lambda: progress_dialog.set_progress(70))
                    time.sleep(0.5)
                    
                    if success:
                        refresh_token = self.get_setting("refresh_token", "")
                        token_preview = refresh_token[:10] + "..." if refresh_token else "Erro"
                        run_on_ui_thread(lambda: BulletinHelper.show_success("Yep!"))
                    else:
                        error_display = error_msg if error_msg else tr("code_exchange_error")
                        run_on_ui_thread(lambda: BulletinHelper.show_info(f"Erro: {error_display}"))
                    
                    run_on_ui_thread(lambda: progress_dialog.set_progress(100))
                    time.sleep(0.2)
                except Exception as e:
                    run_on_ui_thread(lambda: BulletinHelper.show_info(f"Erro: {str(e)}"))
                finally:
                    run_on_ui_thread(lambda: progress_dialog.dismiss())
            run_on_queue(run_code)
            return HookResult(strategy=HookStrategy.CANCEL)
        if msg.startswith(".setid "):
            self.set_setting("client_id", msg.split(" ", 1)[1].strip())
            BulletinHelper.show_success(tr("setid"))
            return HookResult(strategy=HookStrategy.CANCEL)
        if msg.startswith(".setsecret "):
            self.set_setting("client_secret", msg.split(" ", 1)[1].strip())
            BulletinHelper.show_success(tr("setsecret"))
            return HookResult(strategy=HookStrategy.CANCEL)
        if msg.startswith(".play "):
            track_number = msg.split(" ", 1)[1].strip()
            run_on_queue(lambda: self._play_track(account, params, track_number))
            return HookResult(strategy=HookStrategy.CANCEL)
        if msg == ".dev":
            run_on_ui_thread(lambda: self._open_plugin_settings())
            return HookResult(strategy=HookStrategy.CANCEL)
        if msg == ".bio":
            restore_bio_text = self.get_setting("restore_bio_text", "").strip()
            if restore_bio_text:
                restore_bio = restore_bio_text
            else:
                restore_bio = "I'm using Nowfy!"
            run_on_ui_thread(lambda: self._update_bio(restore_bio, show_bulletin=True))
            return HookResult(strategy=HookStrategy.CANCEL)
        if msg == ".clear":
            run_on_queue(lambda: self._clear_cache())
            return HookResult(strategy=HookStrategy.CANCEL)
        if msg == ".check":
            BulletinHelper.show_info(tr("check"))
            if self._validate_credentials():
                BulletinHelper.show_info(tr("valid"))
            else:
                BulletinHelper.show_info(tr("bio_error"))
            return HookResult(strategy=HookStrategy.CANCEL)
        if msg == ".update":
            client_id = self.get_setting("client_id", "")
            if not client_id:
                BulletinHelper.show_info(tr("client_id_missing"))
                return HookResult(strategy=HookStrategy.CANCEL)
            auth_url = (
                "https://accounts.spotify.com/authorize?"
                f"client_id={client_id}&response_type=code&"
                "redirect_uri=https://example.com/callback&"
                "scope=user-read-currently-playing%20user-read-playback-state%20user-modify-playback-state%20user-read-recently-played%20user-library-modify%20playlist-modify-private"
            )
            
            # Prepare message for clipboard
            message = f"Spotify Authorization Link:\n{auth_url}"
            
            # Create bulletin with copy button
            fragment = get_last_fragment()
            def on_copy():
                # Use fragment context for compatibility
                if hasattr(fragment, 'getParentActivity') and fragment.getParentActivity():
                    context = fragment.getParentActivity()
                else:
                    from org.telegram.messenger import ApplicationLoader
                    context = ApplicationLoader.applicationContext
                
                # Copy to clipboard using context
                clipboard = context.getSystemService(Context.CLIPBOARD_SERVICE)
                clip = ClipData.newPlainText("auth_url", auth_url)
                clipboard.setPrimaryClip(clip)
                
                run_on_ui_thread(lambda: (BulletinHelper.show_success(tr("copied_bulletin"), fragment)))
            
            # Show bulletin with copy button
            music_icon = getattr(R.raw, "music", R.raw.info)
            run_on_ui_thread(lambda: BulletinHelper.show_with_button(
                "Spotify Authorization",
                music_icon,
                "Copy Link",
                on_copy,
                fragment
            ))
            return HookResult(strategy=HookStrategy.CANCEL)

        if msg == ".connect":
            client_id = self.get_setting("client_id", "")
            if not client_id:
                BulletinHelper.show_info(tr("client_id_missing"))
                return HookResult(strategy=HookStrategy.CANCEL)
            auth_url = (
                "https://accounts.spotify.com/authorize?"
                f"client_id={client_id}&response_type=code&"
                "redirect_uri=https://example.com/callback&"
                "scope=user-read-currently-playing%20user-read-playback-state%20user-modify-playback-state%20user-read-recently-played%20user-library-modify%20playlist-modify-private"
            )
            caption = f"[🎵](5294137402430858861) [Connect your Spotify]({auth_url})"
            caption_md = parse_markdown(caption)
            # Atribuição segura para objetos ou dict
            try:
                params.message = caption_md.text
                params.entities = ArrayList()
                for entity in caption_md.entities:
                    params.entities.add(entity.to_tlrpc_object())
                run_on_ui_thread(lambda: get_send_messages_helper().sendMessage(params))
            except Exception:
                try:
                    params["message"] = caption_md.text
                    params["entities"] = [e.to_tlrpc_object() for e in caption_md.entities]
                    # Sem envio direto quando params é dict para evitar incompatibilidade
                    self._send_msg(params, caption_md.text)
                except Exception as e:
                    log(f"[NowFy] Erro ao definir message/entities no params: {e}")
            return HookResult(strategy=HookStrategy.CANCEL)

        if msg == ".search":
            BulletinHelper.show_info(tr("error_missing_search"))
            return HookResult(strategy=HookStrategy.CANCEL)
        if msg.startswith(".search "):
            query = msg.split(" ", 1)[1].strip()
            run_on_queue(lambda: self._search_spotify(params, query))
            return HookResult(strategy=HookStrategy.CANCEL)
        if msg == ".fm":
            fragment = get_last_fragment()
            if fragment:
                run_on_ui_thread(lambda: self._show_loading_dialog(fragment))
            run_on_queue(lambda: self._trigger_chat_list_refresh())
            run_on_queue(lambda: self._handle_fm_only_lastfm(account, params))
            return HookResult(strategy=HookStrategy.CANCEL)
        
        # Comando .etg - exteraGram music detection
        if msg == ".etg":
            fragment = get_last_fragment()
            if fragment:
                run_on_ui_thread(lambda: self._show_loading_dialog(fragment))
            run_on_queue(lambda: self._trigger_chat_list_refresh())
            run_on_queue(lambda: self._handle_etg_command(account, params))
            return HookResult(strategy=HookStrategy.CANCEL)
        
        # Comando .ayu - AyuGram music detection  
        if msg == ".ayu":
            fragment = get_last_fragment()
            if fragment:
                run_on_ui_thread(lambda: self._show_loading_dialog(fragment))
            run_on_queue(lambda: self._trigger_chat_list_refresh())
            run_on_queue(lambda: self._handle_ayu_command(account, params))
            return HookResult(strategy=HookStrategy.CANCEL)
        
        # Alternativa de testes - Comando interno
        if msg == ".api":
            log(f"[Nowfy] .api command - testing Last.fm credentials")
            user = self.get_setting("lastfm_username", "")
            api_key = self.get_setting("lastfm_api_key", "")
            
            log(f"[Nowfy] Test - User: '{user}' (length: {len(user) if user else 0})")
            log(f"[Nowfy] Test - API Key: '{api_key[:10] if api_key else ''}...' (length: {len(api_key) if api_key else 0})")
            
            if not user or not api_key:
                BulletinHelper.show_info(f"Credenciais faltando - User: {bool(user)}, API Key: {bool(api_key)}")
                return HookResult(strategy=HookStrategy.CANCEL)
            
            # Testar API diretamente
            import requests
            url = "http://ws.audioscrobbler.com/2.0/"
            params_test = {
                'method': 'user.getrecenttracks',
                'user': user,
                'api_key': api_key,
                'format': 'json',
                'limit': 1
            }
            
            try:
                resp = requests.get(url, params=params_test, timeout=10)
                log(f"[Nowfy] Test API response: {resp.status_code}")
                if resp.status_code == 200:
                    data = resp.json()
                    tracks = data.get('recenttracks', {}).get('track', [])
                    if tracks:
                        track = tracks[0] if isinstance(tracks, list) else tracks
                        track_name = track.get('name', 'Unknown')
                        BulletinHelper.show_info(f"API OK! Última música: {track_name}")
                    else:
                        BulletinHelper.show_info("API OK! Mas nenhuma música encontrada")
                else:
                    BulletinHelper.show_info(f"API Error: {resp.status_code}")
            except Exception as e:
                log(f"[Nowfy] Test API error: {e}")
                BulletinHelper.show_info(f"Erro na API: {str(e)}")
            
            return HookResult(strategy=HookStrategy.CANCEL)
        
        if msg == ".stats":
            # Restrições de Active Player para o comando .stats:
            # Suporta apenas Spotify e Apple Music.
            try:
                current_player_setting = self.get_setting("current_player", 0)
            except Exception:
                current_player_setting = 0
            if current_player_setting not in [0, 6]:  # 0 = Spotify, 6 = Apple Music
                BulletinHelper.show_info("O comando .stats suporta apenas Spotify e Apple Music no modo Active Player. Selecione um desses players em Configurações → Active Player.")
                return HookResult(strategy=HookStrategy.CANCEL)
            fragment = get_last_fragment()
            if fragment:
                run_on_ui_thread(lambda: self._show_loading_dialog(fragment))
            run_on_queue(lambda: self._trigger_chat_list_refresh())
            run_on_queue(lambda: self._handle_stats_only(account, params))
            return HookResult(strategy=HookStrategy.CANCEL)

        if msg == ".help":
            run_on_queue(lambda: self._show_help(params))
            return HookResult(strategy=HookStrategy.CANCEL)
        
        # Comandos de backup e restauração
        if msg == ".export":
            run_on_queue(lambda: self._export_backup(params))
            return HookResult(strategy=HookStrategy.CANCEL)
        
        if msg == ".backups":
            run_on_queue(lambda: self._list_backups(params))
            return HookResult(strategy=HookStrategy.CANCEL)
        
        return HookResult()

    def _handle_etg_command(self, account, params):
        """Comando .etg - exteraGram music detection"""
        self._last_overlay_trigger_command = ".etg"
        try:
            log(f"[Nowfy] .etg command - detecting music from exteraGram")
            
            # Usar o método da classe para detectar música do exteraGram
            track_info = self.get_current_track_etg(account)
            
            if track_info and track_info.get('title') and track_info.get('artist'):
                title = track_info.get('title', '')
                artist = track_info.get('artist', '')
                album = track_info.get('album', '')
                duration = track_info.get('duration', 0)
                position = track_info.get('progress', 0)
                
                log(f"[Nowfy] exteraGram track detected: {title} by {artist}")
                
                # Buscar capa do exteraGram
                etg_cover_image = None
                try:
                    # Obter o objeto de mensagem atual
                    from org.telegram.messenger import MediaController
                    media_controller = MediaController.getInstance()
                    playing_song = media_controller.getPlayingMessageObject()
                    
                    if playing_song:
                        etg_cover_image = self.get_etg_cover(playing_song)
                        log(f"[Nowfy] exteraGram cover obtained: {bool(etg_cover_image)}")
                except Exception as e:
                    log(f"[Nowfy] Error getting exteraGram cover: {e}")
                
                # Buscar link do Spotify
                spotify_url = None
                try:
                    spotify_url = self._search_spotify_url(title, artist)
                except Exception as e:
                    log(f"[Nowfy] Error searching Spotify URL: {e}")
                
                # Criar objeto de track no formato do Spotify
                track_obj = {
                    "name": title,
                    "artists": [{"name": artist}],
                    "album": {
                        "name": album,
                        "images": []
                    },
                    "external_urls": {
                        "spotify": spotify_url
                    },
                    "duration_ms": duration * 1000 if duration else 0
                }
                
                # Forçar o player como exteraGram para que o username apareça no caption
                original_player = getattr(self, '_forced_player', None)
                self._forced_player = "exteraGram"
                
                # Usar o _generate_card para aplicar o tema selecionado
                self._generate_card(track_obj, params, position * 1000 if position else 0, 
                                  force_spotify=False, etg_cover_image=etg_cover_image, is_fm_command=False)
                
                # Restaurar o player original
                if original_player is not None:
                    self._forced_player = original_player
                else:
                    if hasattr(self, '_forced_player'):
                        delattr(self, '_forced_player')
                log(f"[Nowfy] exteraGram track displayed: {title}")
                return True
            else:
                log(f"[Nowfy] No track currently playing on exteraGram")
                BulletinHelper.show_info("No track currently playing on exteraGram")
                return True

        except Exception as e:
            log(f"[Nowfy] Error in .etg command: {e}")
            BulletinHelper.show_info(f"Error: {e}")
        finally:
            if bool(self.get_setting("enable_quick_dismiss", True)):
                run_on_ui_thread(self._dismiss_loading_dialog)

    def _handle_ayu_command(self, account, params):
        """Comando .ayu - AyuGram music detection"""
        self._last_overlay_trigger_command = ".ayu"
        try:
            log(f"[Nowfy] .ayu command - detecting music from AyuGram")
            
            # Usar o método da classe para detectar música do AyuGram (mesma função do exteraGram)
            track_info = self.get_current_track_etg(account)
            
            if track_info and track_info.get('title') and track_info.get('artist'):
                title = track_info.get('title', '')
                artist = track_info.get('artist', '')
                album = track_info.get('album', '')
                duration = track_info.get('duration', 0)
                position = track_info.get('progress', 0)
                
                log(f"[Nowfy] AyuGram track detected: {title} by {artist}")
                
                # Buscar capa do AyuGram
                etg_cover_image = None
                try:
                    # Obter o objeto de mensagem atual
                    from org.telegram.messenger import MediaController
                    media_controller = MediaController.getInstance()
                    playing_song = media_controller.getPlayingMessageObject()
                    
                    if playing_song:
                        etg_cover_image = self.get_etg_cover(playing_song)
                        log(f"[Nowfy] AyuGram cover obtained: {bool(etg_cover_image)}")
                except Exception as e:
                    log(f"[Nowfy] Error getting AyuGram cover: {e}")
                
                # Buscar link do Spotify
                spotify_url = None
                try:
                    spotify_url = self._search_spotify_url(title, artist)
                except Exception as e:
                    log(f"[Nowfy] Error searching Spotify URL: {e}")
                
                # Criar objeto de track no formato do Spotify
                track_obj = {
                    "name": title,
                    "artists": [{"name": artist}],
                    "album": {
                        "name": album,
                        "images": []
                    },
                    "external_urls": {
                        "spotify": spotify_url
                    },
                    "duration_ms": duration * 1000 if duration else 0
                }
                
                # Usar o _generate_card para aplicar o tema selecionado
                self._generate_card(track_obj, params, position * 1000 if position else 0, 
                                  force_spotify=False, etg_cover_image=etg_cover_image, is_fm_command=False)
                log(f"[Nowfy] AyuGram track displayed: {title}")
                return True
            else:
                log(f"[Nowfy] No track currently playing on AyuGram")
                BulletinHelper.show_info("No track currently playing on AyuGram")
                return True

        except Exception as e:
            log(f"[Nowfy] Error in .ayu command: {e}")
            BulletinHelper.show_info(f"Error: {e}")
        finally:
            if bool(self.get_setting("enable_quick_dismiss", True)):
                run_on_ui_thread(self._dismiss_loading_dialog)

    def _handle_fm_only_lastfm(self, account, params):
        """Comando .fm - apenas Last.fm"""
        self._last_overlay_trigger_command = ".fm"
        try:
            user = self.get_setting("lastfm_username", "")
            api_key = self.get_setting("lastfm_api_key", "")
            
            # Debug: Log das credenciais recuperadas
            log(f"[Nowfy] Debug - Last.fm user: '{user}' (length: {len(user) if user else 0})")
            log(f"[Nowfy] Debug - Last.fm API key: '{api_key[:10]}...' (length: {len(api_key) if api_key else 0})")

            # Verificar se há credenciais do Last.fm disponíveis
            if not user or not api_key:
                log(f"[Nowfy] Debug - Missing credentials: user={bool(user)}, api_key={bool(api_key)}")
                BulletinHelper.show_info("Last.fm credentials not configured. Use .help for setup instructions.")
                return False

            # Tentar Last.fm
            try:
                import requests
                url = "http://ws.audioscrobbler.com/2.0/"
                params_lastfm = {
                    'method': 'user.getrecenttracks',
                    'user': user,
                    'api_key': api_key,
                    'format': 'json',
                    'limit': 1
                }
                
                resp = requests.get(url, params=params_lastfm, timeout=5)
                if resp.status_code == 200:
                    data = resp.json()
                    log(f"[Nowfy] Last.fm API response received, parsing tracks...")
                    tracks = data.get('recenttracks', {}).get('track', [])
                    log(f"[Nowfy] Found {len(tracks) if tracks else 0} tracks")
                    
                    if tracks and isinstance(tracks, list) and len(tracks) > 0:
                        track = tracks[0]
                        log(f"[Nowfy] Processing first track: {track.get('name', 'Unknown')}")
                        
                        # Nova lógica: verificar se a música mais recente foi scrobblada recentemente
                        # Se foi scrobblada nos últimos 10 minutos, considerar como "tocando agora"
                        import time
                        current_time = int(time.time())
                        
                        # Verificar se tem atributo nowplaying (música realmente tocando agora)
                        is_now_playing = track.get('@attr', {}).get('nowplaying') == 'true'
                        log(f"[Nowfy] Is now playing: {is_now_playing}")
                        
                        # Se não está tocando agora, verificar se foi scrobblada recentemente
                        is_recent = False
                        if not is_now_playing and 'date' in track:
                            track_time = int(track['date']['uts'])
                            time_diff = current_time - track_time
                            is_recent = time_diff <= 600  # 10 minutos = 600 segundos
                            log(f"[Nowfy] Track time diff: {time_diff} seconds (recent: {is_recent})")
                        elif not is_now_playing:
                            log(f"[Nowfy] No date field found, assuming now playing")
                            is_recent = True  # Se não tem data, assumir que está tocando
                        
                        # Mostrar se está tocando agora OU foi scrobblada recentemente
                        if is_now_playing or is_recent:
                            title = track.get('name', '')
                            artist_name = track.get('artist', {}).get('#text', '') if isinstance(track.get('artist'), dict) else str(track.get('artist', ''))
                            album_name = track.get('album', {}).get('#text', '') if isinstance(track.get('album'), dict) else str(track.get('album', ''))
                            
                            log(f"[Nowfy] Showing track: {title} by {artist_name} (nowplaying: {is_now_playing}, recent: {is_recent})")
                            
                            # Obter URL da imagem do álbum
                            image_url = None
                            images = track.get('image', [])
                            if images:
                                for img in images:
                                    if img.get('size') == 'large':
                                        image_url = img.get('#text', '')
                                        break
                            
                            # Buscar link do Spotify
                            spotify_url = None
                            try:
                                spotify_url = self._search_spotify_url(title, artist_name)
                            except Exception as e:
                                log(f"[Nowfy] Error searching Spotify URL: {e}")
                            
                            # Criar objeto de track no formato do Spotify
                            track_obj = {
                                "name": title,
                                "artists": [{"name": artist_name}],
                                "album": {
                                    "name": album_name,
                                    "images": [{"url": image_url, "width": 640, "height": 640}] if image_url else []
                                },
                                "external_urls": {
                                    "spotify": spotify_url
                                },
                                "duration_ms": 0
                            }
                            
                            # Usar o _generate_card para aplicar o tema selecionado
                            self._generate_card(track_obj, params, 0, force_spotify=False, etg_cover_image=None, is_fm_command=True)
                            log(f"[Nowfy] Last.fm track found and displayed: {title}")
                            return True
                        else:
                            log(f"[Nowfy] Last.fm: Track found but not showing (nowplaying: {is_now_playing}, recent: {is_recent})")
                            if 'date' in track:
                                track_time = int(track['date']['uts'])
                                time_diff = current_time - track_time
                                log(f"[Nowfy] Track was scrobbled {time_diff} seconds ago")
                            BulletinHelper.show_info("No track currently playing on Last.fm")
                            return True
                    else:
                        log(f"[Nowfy] Last.fm: No tracks found")
                        BulletinHelper.show_info("No track currently playing on Last.fm")
                        return True
                else:
                    log(f"[Nowfy] Last.fm API error: {resp.status_code} - {resp.text}")
                    BulletinHelper.show_info("Last.fm API error")
                    return True
            except Exception as e:
                log(f"[ERROR] Last.fm error: {e}")
                BulletinHelper.show_info("Last.fm connection error")
                return True

        except Exception as e:
            log(f"[Nowfy] Error in .fm command: {e}")
            BulletinHelper.show_info(f"Error: {e}")
        finally:
            if bool(self.get_setting("enable_quick_dismiss", True)):
                run_on_ui_thread(self._dismiss_loading_dialog)

    def _handle_stats_only(self, account, params):
        """Comando .stats - apenas Stats.fm"""
        self._last_overlay_trigger_command = ".stats"
        try:
            statsfm_username = self.get_setting("statsfm_username", "")

            # Verificar se há credenciais do Stats.fm disponíveis
            if not statsfm_username:
                BulletinHelper.show_info("Stats.fm username not configured. Use .help for setup instructions.")
                return False

            # Tentar Stats.fm
            import requests
            url = f"https://api.stats.fm/api/v1/users/{statsfm_username}/streams/current"
            headers = {
                "Accept": "application/json",
                "User-Agent": "NowfyPlugin/1.0"
            }

            try:
                resp = requests.get(url, headers=headers, timeout=5)
                if resp.status_code == 200:
                    data = resp.json()
                    item = data.get("item")
                    if item and item.get("isPlaying"):
                        # Criar um objeto de track compatível com o formato do Spotify
                        track_info = item.get("track", {})
                        artists_list = []
                        for artist_name in track_info.get("artists", []):
                            artists_list.append({"name": artist_name["name"]})
                        
                        album = track_info["albums"][0] if track_info.get("albums") else {}
                        album_images = []
                        if album.get("image"):
                            album_images.append({"url": album.get("image"), "width": 640, "height": 640})
                        
                        spotify_id = None
                        if track_info.get("externalIds") and track_info["externalIds"].get("spotify"):
                            spotify_id = track_info["externalIds"]["spotify"][0]
                        
                        # Criar objeto de track no formato do Spotify
                        track = {
                            "name": track_info.get("name", ""),
                            "artists": artists_list,
                            "album": {
                                "name": album.get("name", ""),
                                "images": album_images
                            },
                            "external_urls": {
                                "spotify": f"https://open.spotify.com/track/{spotify_id}" if spotify_id else None
                            },
                            "duration_ms": track_info.get("durationMs", 0)
                        }
                        
                        # Usar o _generate_card para aplicar o tema selecionado
                        progress_ms = item.get("progressMs", 0)
                        # .stats deve exibir ViniBar e não overlay
                        self._generate_card(track, params, progress_ms, force_spotify=False, etg_cover_image=None, is_fm_command=False)
                        return True
                    else:
                        BulletinHelper.show_info("No track currently playing on Stats.fm")
                        return True
                else:
                    log(f"[ERROR] Stats.fm API error: {resp.status_code} - {resp.text}")
                    BulletinHelper.show_info("Stats.fm API error")
                    return True
            except Exception as e:
                log(f"[ERROR] Stats.fm connection failed: {str(e)}")
                BulletinHelper.show_info("Stats.fm connection error")
                return True

        except Exception as e:
            log(f"[Nowfy] Error in .stats command: {e}")
            BulletinHelper.show_info(f"Error: {e}")
        finally:
            if bool(self.get_setting("enable_quick_dismiss", True)):
                run_on_ui_thread(self._dismiss_loading_dialog)

    def _handle_fm_lastfm(self, account, params):
        self._last_overlay_trigger_command = ".fm"
        try:
            user = self.get_setting("lastfm_username", "")
            api_key = self.get_setting("lastfm_api_key", "")
            theme = self.get_setting("theme_selector", 0)
            statsfm_username = self.get_setting("statsfm_username", "")
            show_track_link = self.get_setting("show_track_link", True)

            title = artist = album_name = image_url = None
            duration_ms = progress_ms = 0
            spotify_url = None

            def render_statsfm(data):
                nonlocal title, artist, album_name, image_url, duration_ms, progress_ms, spotify_url
                track = data.get("item")
                if not track:
                    return

                track_info = track.get("track", {})
                artists = ", ".join([artist["name"] for artist in track_info.get("artists", [])])
                album = track_info["albums"][0] if track_info.get("albums") else {}
                title = track_info.get("name", "")
                artist = artists
                album_name = album.get("name", "")
                image_url = album.get("image", "")
                progress_ms = track.get("progressMs", 0)
                duration_ms = track_info.get("durationMs", 0)

                if track_info.get("externalIds") and track_info["externalIds"].get("spotify"):
                    spotify_url = f"https://open.spotify.com/track/{track_info['externalIds']['spotify'][0]}"

                player = "StatsFM"
                link = spotify_url if show_track_link else None

                if theme_style == 0:
                    return self._get_current_track_lastfm_customfm(
                        title, artist, album_name, image_url, params,
                        None,      
                        "statsfm",      
                        link,         
                        None,           
                        None,           
                        None            
                    )
                else:
                    return self._get_current_track_lastfm_customfm(
                        title, artist, album_name, image_url, params,
                        None, player, link, None, None, None
                    )

            # 1. Tenta os dados do Stats.fm
            if statsfm_username:
                import requests
                url = f"https://api.stats.fm/api/v1/users/{statsfm_username}/streams/current"
                headers = {
                    "Accept": "application/json",
                    "User-Agent": "NowfyPlugin/1.0"
                }

                try:
                    resp = requests.get(url, headers=headers, timeout=5)
                    if resp.status_code == 200:
                        data = resp.json()
                        item = data.get("item")
                        if item and item.get("isPlaying"):
                            # Criar um objeto de track compatível com o formato do Spotify
                            track_info = item.get("track", {})
                            artists_list = []
                            for artist_name in track_info.get("artists", []):
                                artists_list.append({"name": artist_name["name"]})
                            
                            album = track_info["albums"][0] if track_info.get("albums") else {}
                            album_images = []
                            if album.get("image"):
                                album_images.append({"url": album.get("image"), "width": 640, "height": 640})
                            
                            spotify_id = None
                            if track_info.get("externalIds") and track_info["externalIds"].get("spotify"):
                                spotify_id = track_info["externalIds"]["spotify"][0]
                            
                            # Criar objeto de track no formato do Spotify
                            track = {
                                "name": track_info.get("name", ""),
                                "artists": artists_list,
                                "album": {
                                    "name": album.get("name", ""),
                                    "images": album_images
                                },
                                "external_urls": {
                                    "spotify": f"https://open.spotify.com/track/{spotify_id}" if spotify_id else None
                                },
                                "duration_ms": track_info.get("durationMs", 0)
                            }
                            
                            # Usar o _generate_card para aplicar o tema selecionado
                            progress_ms = item.get("progressMs", 0)
                            self._generate_card(track, params, progress_ms, force_spotify=False, etg_cover_image=None, is_fm_command=True)
                            return True
                    else:
                        log(f"[ERROR] Stats.fm API error: {resp.status_code} - {resp.text}")
                except Exception as e:
                    log(f"[ERROR] Stats.fm connection failed: {str(e)}")

            # 2. Tenta o Last.fm
            if user and api_key:
                try:
                    # Usar requests em vez de pylast para evitar dependência externa
                    import requests
                    url = "http://ws.audioscrobbler.com/2.0/"
                    params_lastfm = {
                        'method': 'user.getrecenttracks',
                        'user': user,
                        'api_key': api_key,
                        'format': 'json',
                        'limit': 1
                    }
                    
                    resp = requests.get(url, params=params_lastfm, timeout=5)
                    if resp.status_code == 200:
                        data = resp.json()
                        tracks = data.get('recenttracks', {}).get('track', [])
                        if tracks and isinstance(tracks, list) and len(tracks) > 0:
                            track = tracks[0]
                            # Verificar se está tocando agora
                            # Last.fm pode não incluir @attr.nowplaying quando está scrobblando
                            # Vamos assumir que a música mais recente está tocando, a menos que explicitamente diga que não
                            is_now_playing = track.get('@attr', {}).get('nowplaying') == 'true'
                            has_nowplaying_attr = '@attr' in track and 'nowplaying' in track['@attr']
                            
                            # Se tem o atributo nowplaying e é true, OU se não tem o atributo (assumir que está tocando)
                            # Mudança: ser mais permissivo - mostrar a música a menos que explicitamente não esteja tocando
                            if is_now_playing or not has_nowplaying_attr:
                                title = track.get('name', '')
                                artist_name = track.get('artist', {}).get('#text', '') if isinstance(track.get('artist'), dict) else str(track.get('artist', ''))
                                album_name = track.get('album', {}).get('#text', '') if isinstance(track.get('album'), dict) else str(track.get('album', ''))
                                
                                # Obter URL da imagem do álbum
                                image_url = None
                                images = track.get('image', [])
                                if images:
                                    # Prefer the largest available Last.fm image
                                    size_priority = ['mega', 'extralarge', 'large']
                                    size_map = {img.get('size'): img.get('#text', '') for img in images if img.get('#text')}
                                    for s in size_priority:
                                        if size_map.get(s):
                                            image_url = size_map[s]
                                            break
                                    if not image_url:
                                        # Fallback to last non-empty image URL
                                        for img in reversed(images):
                                            if img.get('#text'):
                                                image_url = img.get('#text', '')
                                                break
                                
                                # Buscar link do Spotify
                                spotify_url = None
                                try:
                                    spotify_url = self._search_spotify_url(title, artist_name)
                                except Exception as e:
                                    log(f"[Nowfy] Error searching Spotify URL: {e}")
                                
                                # Criar objeto de track no formato do Spotify
                                track = {
                                    "name": title,
                                    "artists": [{"name": artist_name}],
                                    "album": {
                                        "name": album_name,
                                        "images": [{"url": image_url, "width": 640, "height": 640}] if image_url else []
                                    },
                                    "external_urls": {
                                        "spotify": spotify_url
                                    },
                                    "duration_ms": 0
                                }
                                
                                # Usar o _generate_card para aplicar o tema selecionado
                                self._generate_card(track, params, 0, force_spotify=False, etg_cover_image=None, is_fm_command=True)
                                log(f"[Nowfy] Last.fm track found and displayed: {title}")
                                return True
                            else:
                                log(f"[Nowfy] Last.fm: Track found but not currently playing (nowplaying=false)")
                                BulletinHelper.show_info(tr("no_track_lastfm") if "no_track_lastfm" in TRANSLATIONS else "No track currently playing on Last.fm")
                                return True
                        else:
                            log(f"[Nowfy] Last.fm: No tracks found")
                            BulletinHelper.show_info(tr("no_track_lastfm") if "no_track_lastfm" in TRANSLATIONS else "No track currently playing on Last.fm")
                            return True
                    else:
                        log(f"[Nowfy] Last.fm API error: {resp.status_code} - {resp.text}")
                        BulletinHelper.show_info(tr("no_track_lastfm") if "no_track_lastfm" in TRANSLATIONS else "No track currently playing on Last.fm")
                        return True
                except Exception as e:
                    log(f"[ERROR] Last.fm error: {e}")
                    BulletinHelper.show_info(tr("no_track_lastfm") if "no_track_lastfm" in TRANSLATIONS else "No track currently playing on Last.fm")
                    return True

            # 3. Tenta o player do etg como fallback
            player_name = self._detect_current_player()
            if player_name in ["exteraGram", "AyuGram"]:
                etg_track = self.get_current_track_etg(account)
                if etg_track:
                    title = etg_track["title"]
                    artist = etg_track["artist"]
                    # Funcionalidade para obter dados do etg (áudio)
                    from org.telegram.messenger import MediaController
                    media_controller = MediaController.getInstance()
                    playing_song = media_controller.getPlayingMessageObject()
                    etg_cover_image = self.get_etg_cover(playing_song)
                    album_name = etg_track.get("album", "")
                    image_url = None  # Fallback
                    
                    # Buscar link do Spotify
                    spotify_url = None
                    try:
                        spotify_url = self._search_spotify_url(title, artist)
                    except Exception as e:
                        log(f"[Nowfy] Error searching Spotify URL: {e}")
                    
                    # Criar objeto de track no formato do Spotify
                    track = {
                        "name": title,
                        "artists": [{"name": artist}],
                        "album": {
                            "name": album_name,
                            "images": [{"url": image_url, "width": 640, "height": 640}] if image_url else []
                        },
                        "external_urls": {
                            "spotify": spotify_url
                        },
                        "duration_ms": 0
                    }
                    
                    # Usar o _generate_card com o cover do ETG
                    # Obter o tema selecionado
                    theme = self.get_setting("theme_selector", 0)
                    random_theme = self.get_setting("random_theme_mode", False)
                    
                    # Se for tema externo (índice >= 5), passar o etg_cover_image
                    if theme >= 5 and not random_theme:
                        # Obter temas externos
                        external_themes = self._get_external_themes()
                        if external_themes:
                            # Calcular qual tema externo usar
                            external_theme_index = theme - 5
                            external_theme_ids = list(external_themes.keys())
                            if external_theme_index < len(external_theme_ids):
                                theme_id = external_theme_ids[external_theme_index]
                                self._generate_external_theme_card(track, params, 0, theme_id, 
                                                                external_themes[theme_id], 
                                                                force_spotify=False, 
                                                                etg_cover_image=etg_cover_image)
                                return True
                    
                    # Para outros temas, usar o _generate_card normal
                    self._generate_card(track, params, 0, force_spotify=False, etg_cover_image=etg_cover_image, is_fm_command=True)
                    return True
                else:
                    # Não há música tocando no exteraGram/AyuGram - não enviar card
                    log(f"[Nowfy] No track playing on {player_name}")
                    BulletinHelper.show_info(tr("no_track_playing_generic"))
                    return False

            # 4. Sem respotas
            BulletinHelper.show_info(tr("no_track_playing_generic"))

        except Exception as e:
            log(f"[Nowfy] Error in .fm command: {e}")
            self._send_msg(params, f"Error: {e}")
        finally:
            if bool(self.get_setting("enable_quick_dismiss", True)):
                run_on_ui_thread(self._dismiss_loading_dialog)

    def _open_url(self, url):
        try:
            fragment = get_last_fragment()
            ctx = fragment.getParentActivity() if fragment and fragment.getParentActivity() else ApplicationLoader.applicationContext
            intent = Intent(Intent.ACTION_VIEW)
            intent.setData(Uri.parse(url))
            ctx.startActivity(intent)
        except Exception as e:
            log(f"Erro ao abrir link: {e}")

    def _send_msg(self, params, text):
        if isinstance(text, str) and text in TRANSLATIONS:
            BulletinHelper.show_info(tr(text))
        else:
            BulletinHelper.show_info(text)

    def _trigger_send_ripple(self):
        try:
            if not self.get_setting("enable_aurasend_on_send", False):
                return
            fragment = get_last_fragment()
            activity = fragment.getParentActivity() if fragment and fragment.getParentActivity() else None
            view = None
            if activity:
                try:
                    window = activity.getWindow()
                    if window:
                        view = window.getDecorView()
                except Exception:
                    view = None
            try:
                width = float(view.getWidth()) if view else 540.0
                height = float(view.getHeight()) if view else 960.0
            except Exception:
                width = 540.0
                height = 960.0
            cx = width / 2.0
            cy = height / 2.0
            # Seleciona estilo Notify (iOS) quando habilitado
            try:
                if not hasattr(self, "_launch_activity_jclass") or self._launch_activity_jclass is None:
                    self._launch_activity_jclass = JClass.forName("org.telegram.ui.LaunchActivity")
                    try:
                        self._launch_activity_clsobj = getattr(self._launch_activity_jclass, "class_", None)
                    except Exception:
                        self._launch_activity_clsobj = None
                owner = self._launch_activity_clsobj or self._launch_activity_jclass
                if owner:
                    if not hasattr(self, "_make_ripple_method") or self._make_ripple_method is None:
                        method = None
                        try:
                            method = owner.getDeclaredMethod("makeRipple", JFloat.TYPE, JFloat.TYPE, JFloat.TYPE)
                        except Exception:
                            try:
                                methods = owner.getDeclaredMethods()
                                for m in methods:
                                    try:
                                        if m.getName() != "makeRipple":
                                            continue
                                        if len(m.getParameterTypes()) == 3:
                                            method = m
                                            break
                                    except Exception:
                                        method = m
                                        break
                            except Exception:
                                method = None
                        if method:
                            try:
                                method.setAccessible(True)
                            except Exception:
                                pass
                            self._make_ripple_method = method
                    if getattr(self, "_make_ripple_method", None):
                        self._make_ripple_method.invoke(None, JFloat(cx), JFloat(cy), JFloat(2.5))
            except Exception as e:
                log(f"[NowFy] Ripple invoke error: {e}")
        except Exception:
            pass

    def _trigger_notify_effect(self):
        try:
            fragment = get_last_fragment()
            activity = fragment.getParentActivity() if fragment and fragment.getParentActivity() else None
            if not activity:
                return
            def _run():
                try:
                    # Root content view
                    content = activity.findViewById(16908290)  # android.R.id.content
                    if content is None:
                        try:
                            content = activity.getWindow().getDecorView()
                        except Exception:
                            content = None
                    if content is None:
                        return
                    FrameLayout = find_class("android.widget.FrameLayout")
                    FrameLayout_LayoutParams = find_class("android.widget.FrameLayout$LayoutParams")
                    ImageView = find_class("android.widget.ImageView")
                    GradientDrawable = find_class("android.graphics.drawable.GradientDrawable")
                    Orientation = find_class("android.graphics.drawable.GradientDrawable$Orientation")
                    Gravity = find_class("android.view.Gravity")
                    AndroidUtilities = find_class("org.telegram.messenger.AndroidUtilities")
                    Color = find_class("android.graphics.Color")

                    overlay = FrameLayout(activity)
                    try:
                        overlay.setClickable(False)
                    except Exception:
                        pass

                    # Garantir remoção de overlay anterior (efeito não persistente)
                    try:
                        if hasattr(self, "_aura_overlay") and self._aura_overlay:
                            parent_prev = getattr(self._aura_overlay, "getParent", None)
                            try:
                                if parent_prev:
                                    p = self._aura_overlay.getParent()
                                    if p:
                                        p.removeView(self._aura_overlay)
                            except Exception:
                                pass
                            self._aura_overlay = None
                    except Exception:
                        pass

                    # Parâmetros em tela cheia para efeito nas bordas
                    params = FrameLayout_LayoutParams(-1, -1)

                    # Criar drawable com gradiente radial para bordas
                    gd = GradientDrawable()
                    try:
                        gd.setGradientType(GradientDrawable.RADIAL_GRADIENT)
                    except Exception:
                        pass
                    try:
                        # Determinar tamanho de tela para raio
                        WindowManager = find_class("android.view.WindowManager")
                        Point = find_class("android.graphics.Point")
                        display = activity.getWindowManager().getDefaultDisplay()
                        sizePt = Point()
                        display.getSize(sizePt)
                        screen_w, screen_h = sizePt.x, sizePt.y
                        radius = float(max(screen_w, screen_h)) * 0.75
                        gd.setGradientCenter(0.5, 0.5)
                        # Centro transparente, bordas com cor
                        center_color = Color.argb(0, 123, 97, 255)
                        edge_color = Color.argb(120, 0, 194, 255)
                        gd.setColors([center_color, edge_color])
                        try:
                            gd.setGradientRadius(radius)
                        except Exception:
                            # Fallback para valor fixo
                            gd.setGradientRadius(float(AndroidUtilities.dp(420.0)))
                    except Exception:
                        try:
                            gd.setColor(Color.argb(96, 123, 97, 255))
                        except Exception:
                            pass

                    # Círculo radial central com cores gradientes (Notify)
                    circle_iv = ImageView(activity)
                    circle_gd = GradientDrawable()
                    try:
                        circle_gd.setGradientType(GradientDrawable.RADIAL_GRADIENT)
                        # gradiente do centro (roxo suave) para borda (ciano)
                        c_center = Color.argb(150, 123, 97, 255)
                        c_edge = Color.argb(150, 0, 194, 255)
                        circle_gd.setColors([c_center, c_edge])
                        circle_gd.setGradientCenter(0.5, 0.5)
                    except Exception:
                        try:
                            circle_gd.setColor(Color.argb(120, 123, 97, 255))
                        except Exception:
                            pass
                    try:
                        diameter = AndroidUtilities.dp(240.0)
                    except Exception:
                        diameter = 480
                    try:
                        circle_gd.setGradientRadius(float(diameter) / 2.0)
                    except Exception:
                        pass
                    lp_circle = FrameLayout_LayoutParams(diameter, diameter)
                    lp_circle.gravity = Gravity.CENTER
                    circle_iv.setBackground(circle_gd)
                    try:
                        circle_iv.setAlpha(0.0)
                        circle_iv.setScaleX(0.4)
                        circle_iv.setScaleY(0.4)
                    except Exception:
                        pass
                    overlay.addView(circle_iv, lp_circle)

                    parent_view = content
                    try:
                        content.addView(overlay)
                    except Exception:
                        try:
                            decor = activity.getWindow().getDecorView()
                            decor.addView(overlay)
                            parent_view = decor
                        except Exception:
                            return

                    # Guardar referência atual para remoção garantida
                    try:
                        self._aura_overlay = overlay
                    except Exception:
                        pass

                    # Disparar o mesmo ripple do Default (centro da tela)
                    try:
                        view = None
                        try:
                            view = activity.getWindow().getDecorView()
                        except Exception:
                            view = parent_view
                        try:
                            width = float(view.getWidth()) if view else 540.0
                            height = float(view.getHeight()) if view else 960.0
                        except Exception:
                            width = 540.0
                            height = 960.0
                        cx = width / 2.0
                        cy = height / 2.0
                        if not hasattr(self, "_launch_activity_jclass") or self._launch_activity_jclass is None:
                            self._launch_activity_jclass = JClass.forName("org.telegram.ui.LaunchActivity")
                            try:
                                self._launch_activity_clsobj = getattr(self._launch_activity_jclass, "class_", None)
                            except Exception:
                                self._launch_activity_clsobj = None
                        owner = self._launch_activity_clsobj or self._launch_activity_jclass
                        if owner:
                            if not hasattr(self, "_make_ripple_method") or self._make_ripple_method is None:
                                method = None
                                try:
                                    method = owner.getDeclaredMethod("makeRipple", JFloat.TYPE, JFloat.TYPE, JFloat.TYPE)
                                except Exception:
                                    try:
                                        methods = owner.getDeclaredMethods()
                                        for m in methods:
                                            try:
                                                if m.getName() != "makeRipple":
                                                    continue
                                                if len(m.getParameterTypes()) == 3:
                                                    method = m
                                                    break
                                            except Exception:
                                                method = m
                                                break
                                    except Exception:
                                        method = None
                                if method:
                                    try:
                                        method.setAccessible(True)
                                    except Exception:
                                        pass
                                    self._make_ripple_method = method
                            if getattr(self, "_make_ripple_method", None):
                                self._make_ripple_method.invoke(None, JFloat(cx), JFloat(cy), JFloat(2.5))
                    except Exception:
                        pass

                    # Animar ripple semelhante ao Default: escala do círculo + alpha
                    try:
                        DecelerateInterpolator = find_class("android.view.animation.DecelerateInterpolator")
                        AccelerateInterpolator = find_class("android.view.animation.AccelerateInterpolator")
                        interpolator_in = DecelerateInterpolator()
                        interpolator_out = AccelerateInterpolator()
                        try:
                            overlay.setAlpha(0.0)
                        except Exception:
                            pass
                        def _fade_out():
                            try:
                                a2 = overlay.animate().alpha(0.0).setDuration(220)
                                try:
                                    a2.setInterpolator(interpolator_out)
                                except Exception:
                                    pass
                                a2.withEndAction(lambda: self._remove_notify_overlay(parent_view, overlay))
                                a2.start()
                            except Exception:
                                try:
                                    self._remove_notify_overlay(parent_view, overlay)
                                except Exception:
                                    pass
                        # Fade-in + expansão do círculo
                        try:
                            a_circle = circle_iv.animate().alpha(0.9).scaleX(2.6).scaleY(2.6).setDuration(280)
                            try:
                                a_circle.setInterpolator(interpolator_in)
                            except Exception:
                                pass
                            a_circle.withEndAction(_fade_out)
                            a_circle.start()
                        except Exception:
                            _fade_out()
                        # Overlay acompanha a visibilidade
                        try:
                            overlay.animate().alpha(0.9).setDuration(140).setInterpolator(interpolator_in).start()
                        except Exception:
                            pass
                    except Exception:
                        pass

                    # Remoção com tempo limite para garantir desaparecimento
                    try:
                        AndroidUtilities.runOnUIThread(lambda: self._remove_notify_overlay(parent_view, overlay), 800)
                    except Exception:
                        try:
                            overlay.postDelayed(lambda: self._remove_notify_overlay(parent_view, overlay), 800)
                        except Exception:
                            pass
                except Exception as e:
                    log(f"[NowFy] Notify effect error: {e}")
            try:
                run_on_ui_thread(_run)
            except Exception:
                _run()
        except Exception:
            pass

    def _remove_notify_overlay(self, parent, overlay):
        try:
            if overlay:
                # Sempre garante invisibilidade imediata
                try:
                    overlay.setAlpha(0.0)
                except Exception:
                    pass
                # Remove do parent conhecido
                if parent:
                    try:
                        parent.removeView(overlay)
                    except Exception:
                        pass
                # Fallback: remove do parent real
                try:
                    real_parent = overlay.getParent()
                    if real_parent:
                        try:
                            real_parent.removeView(overlay)
                        except Exception:
                            pass
                except Exception:
                    pass
                # Limpa filhos para liberar referências
                try:
                    overlay.removeAllViews()
                except Exception:
                    pass
            try:
                if hasattr(self, "_aura_overlay") and self._aura_overlay is overlay:
                    self._aura_overlay = None
            except Exception:
                pass
        except Exception:
            pass

    def _trigger_surge_effect(self):
        try:
            # Removido: estilo SurgeWave descontinuado
            return
        except Exception:
            return

    def _compare_versions(self, v1, v2):
        try:
            def to_ints(v):
                return [int(x) for x in str(v).split('.') if x.isdigit() or x.isnumeric()]
            a, b = to_ints(v1), to_ints(v2)
            # Normalize lengths
            maxlen = max(len(a), len(b))
            a += [0] * (maxlen - len(a))
            b += [0] * (maxlen - len(b))
            for i in range(maxlen):
                if a[i] < b[i]:
                    return -1
                if a[i] > b[i]:
                    return 1
            return 0
        except Exception:
            return 0

    def _check_version_async(self, show_bulletin=False):
        try:
            import threading
            def worker():
                url = "https://raw.githubusercontent.com/soumaki/nowFy/refs/heads/main/check/version.json"
                latest = None
                update_url = None
                try:
                    resp = requests.get(url, timeout=6)
                    if resp.status_code == 200:
                        data = resp.json()
                        latest = data.get("latest_version")
                        update_url = data.get("update_url") or data.get("changelog_url")
                        # Sanitize values coming from JSON (trim spaces/backticks)
                        try:
                            latest = str(latest).strip() if latest is not None else None
                        except Exception:
                            pass
                        try:
                            if update_url:
                                update_url = str(update_url).strip().strip('`').strip()
                        except Exception:
                            pass
                except Exception as e:
                    log(f"[Nowfy] Version check request failed: {e}")

                self._latest_version = latest
                self._version_update_url = update_url
                status_text = None
                try:
                    cmp = self._compare_versions(__version__, latest) if latest else 0
                    if latest and cmp < 0:
                        self._version_is_outdated = True
                        status_text = tr("version_status_outdated")
                    elif latest:
                        self._version_is_outdated = False
                        status_text = tr("version_status_up_to_date")
                    else:
                        self._version_is_outdated = False
                        status_text = tr("version_status_unknown")
                except Exception:
                    status_text = tr("version_status_unknown")

                # Refresh settings to update About section labels
                try:
                    self.reload_settings()
                except Exception:
                    pass

                if show_bulletin:
                    try:
                        def show_bulletin_msg():
                            if latest and self._version_is_outdated:
                                msg = tr("update_available_text").format(version=latest)
                                if update_url:
                                    BulletinHelper.show_with_button(
                                        msg,
                                        getattr(R.raw, "info", R.raw.music),
                                        tr("open_update_page"),
                                        lambda: self._open_url(update_url)
                                    )
                                else:
                                    BulletinHelper.show_info(msg)
                            elif latest and not self._version_is_outdated:
                                BulletinHelper.show_info(tr("version_status_up_to_date"))
                            else:
                                BulletinHelper.show_info(tr("version_status_unknown"))
                        try:
                            run_on_ui_thread(show_bulletin_msg)
                        except Exception:
                            show_bulletin_msg()
                    except Exception as e:
                        log(f"[Nowfy] Bulletin version status failed: {e}")
            threading.Thread(target=worker, daemon=True).start()
        except Exception as e:
            log(f"[Nowfy] check_version_async failed: {e}")

    def _show_card_dialog(self):
        try:
            AlertDialogBuilder.show_info(tr("Nowfy"), tr("valid"))
        except Exception as e:
            log(f"[exteraFy] Error showing dialog: {e}")

    def _show_loading_dialog(self, fragment):
        try:
            # Mostrar o diálogo APENAS quando Quick Dismiss estiver ativado
            if not bool(self.get_setting("enable_quick_dismiss", True)):
                self._dialog = None
                return
            self._dialog = AlertDialog(fragment.getParentActivity(), 3)
            self._dialog.setMessage(tr("check"))
            self._dialog.show()
        except Exception as e:
            log(f"[exteraFy] Error showing loading dialog: {e}")

    def _dismiss_loading_dialog(self):
        try:
            if hasattr(self, "_dialog") and self._dialog and self._dialog.isShowing():
                self._dialog.dismiss()
        except Exception:
            pass
        self._dialog = None

    def _handle_now_restore_bio(self, params):
        self._last_overlay_trigger_command = ".now"
        try:
            log(f"[Nowfy] .now command started")
            fragment = get_last_fragment()
            if fragment:
                run_on_ui_thread(lambda: self._show_loading_dialog(fragment))

            # Verificar se há credenciais do Stats.fm ou Last.fm disponíveis
            statsfm_username = self.get_setting("statsfm_username", "")
            lastfm_username = self.get_setting("lastfm_username", "")
            lastfm_api_key = self.get_setting("lastfm_api_key", "")

            has_statsfm = bool(statsfm_username)
            has_lastfm = bool(lastfm_username and lastfm_api_key)

            log(f"[Nowfy] Service availability - Stats.fm: {has_statsfm}, Last.fm: {has_lastfm}")

            # 1. Tentar Stats.fm primeiro se disponível
            if has_statsfm:
                log(f"[Nowfy] Trying Stats.fm with username: {statsfm_username}")
                if self._try_statsfm_now_playing(params, statsfm_username):
                    if self.get_setting("enable_quick_dismiss", True):
                        run_on_ui_thread(self._dismiss_loading_dialog)
                    return

            # 2. Tentar Last.fm se disponível
            if has_lastfm:
                log(f"[Nowfy] Trying Last.fm with username: {lastfm_username}")
                if self._try_lastfm_now_playing(params, lastfm_username, lastfm_api_key):
                    if self.get_setting("enable_quick_dismiss", True):
                        run_on_ui_thread(self._dismiss_loading_dialog)
                    return

            # 3. Só verificar Spotify se Stats.fm e Last.fm falharam
            client_id = self.get_setting("client_id", "")
            client_secret = self.get_setting("client_secret", "")
            refresh_token = self.get_setting("refresh_token", "")

            has_spotify_creds = bool(client_id or client_secret or refresh_token)
            has_complete_spotify_creds = bool(client_id and client_secret and refresh_token)

            self._nlog(f"[Nowfy] Checking Spotify - Partial creds: {has_spotify_creds}, Complete creds: {has_complete_spotify_creds}")

            if has_complete_spotify_creds:
                self._nlog(f"[Nowfy] Trying Spotify with complete credentials")
                token = self._get_access_token(show_error_bulletin=True)
                self._nlog(f"[Nowfy] Access token obtained: {token is not None}")
                if not token:
                    self._nlog(f"[Nowfy] No access token - credentials error already shown")
                    if self.get_setting("enable_quick_dismiss", True):
                        run_on_ui_thread(self._dismiss_loading_dialog)
                    return
            elif has_spotify_creds:
                # Credenciais incompletas do Spotify - mostrar erro apenas se chegamos até aqui
                self._nlog(f"[Nowfy] Incomplete Spotify credentials detected")
                missing_creds = []
                if not client_id:
                    missing_creds.append("Client ID")
                if not client_secret:
                    missing_creds.append("Client Secret")
                if not refresh_token:
                    missing_creds.append("Refresh Token")

                if self._should_show_error_bulletin("missing_credentials"):
                    self._show_credentials_error_bulletin(
                        "missing_credentials",
                        f"[Nowfy] Missing credentials: {', '.join(missing_creds)}",
                        missing_creds
                    )
                if self.get_setting("enable_quick_dismiss", True):
                    run_on_ui_thread(self._dismiss_loading_dialog)
                return
            else:
                # Nenhum serviço configurado ou funcionando
                if not has_statsfm and not has_lastfm:
                    self._nlog(f"[Nowfy] No services configured")
                    BulletinHelper.show_info(
                        tr("no_services_configured") if "no_services_configured" in TRANSLATIONS else
                        "Nenhum serviço configurado. Configure Stats.fm, Last.fm ou Spotify nas configurações."
                    )
                else:
                    self._nlog(f"[Nowfy] Services available but no track found")
                    BulletinHelper.show_info(
                        tr("no_track_playing_generic") if "no_track_playing_generic" in TRANSLATIONS else
                        "Nenhuma música tocando no momento."
                    )
                if self.get_setting("enable_quick_dismiss", True):
                    run_on_ui_thread(self._dismiss_loading_dialog)
                return

            # Continuar apenas se chegou até aqui com credenciais completas do Spotify
            # Testar se o token é válido fazendo uma chamada simples
            test_resp = requests.get(
                "https://api.spotify.com/v1/me",
                headers={"Authorization": f"Bearer {token}"},
                timeout=5
            )
            self._nlog(f"[Nowfy] Token validation - Status: {test_resp.status_code}")
            if test_resp.status_code == 401:
                self._nlog(f"[Nowfy] Token is invalid or expired")
                if self.get_setting("enable_quick_dismiss", True):
                    run_on_ui_thread(self._dismiss_loading_dialog)
                if self._should_show_error_bulletin("invalid_token"):
                    self._show_credentials_error_bulletin(
                        "invalid_refresh_token",
                        f"[Nowfy] Token is invalid or expired - Status: {test_resp.status_code}",
                        ["Refresh Token"]
                    )
                return

            resp = requests.get(
                "https://api.spotify.com/v1/me/player/currently-playing",
                headers={"Authorization": f"Bearer {token}"},
                timeout=5
            )
            self._nlog(f"[Nowfy] API Response - Status: {resp.status_code}, Has Content: {bool(resp.content)}")

            if resp.status_code == 204:
                self._nlog(f"[Nowfy] API returned 204 - No content (nothing playing)")
                # Restore bio se não houver música tocando
                try:
                    user_full = get_messages_controller().getUserFull(get_user_config().getClientUserId())
                    current_bio = user_full.about if user_full else ""
                    restore_bio_text = self.get_setting("restore_bio_text", "").strip()

                    if current_bio and current_bio.strip():
                        restore_bio = current_bio
                    elif restore_bio_text:
                        restore_bio = restore_bio_text
                    else:
                        restore_bio = "I'm using nowFy!"
                except:
                    restore_bio_text = self.get_setting("restore_bio_text", "").strip()
                    restore_bio = restore_bio_text if restore_bio_text else "I'm using nowFy!"

                run_on_ui_thread(lambda: self._update_bio(restore_bio, show_bulletin=False, is_restore=True))
                BulletinHelper.show_info(tr("no_track_playing"))
                return
            elif resp.status_code == 200 and resp.content:
                data = resp.json()
                track = data.get("item")
                progress_ms = data.get("progress_ms", 0)
                is_playing = data.get("is_playing", False)
                log(f"[Nowfy] .now command - Track: {track is not None}, Is Playing: {is_playing}")

                if track:
                    log(f"[Nowfy] Track details - Name: {track.get('name')}, Artists: {[a.get('name') for a in track.get('artists', [])]}")
                else:
                    log(f"[Nowfy] No track data in API response")

                # Verificar se há uma faixa válida (mesmo pausada)
                track_name = track.get("name") if track else None
                track_artists = track.get("artists") if track else None
                log(f"[Nowfy] Track validation - Name: {bool(track_name)}, Artists: {bool(track_artists and len(track_artists) > 0)}")

                if track and track_name and track_artists:
                    log(f"[Nowfy] Calling _generate_card for track: {track_name} by {', '.join([a.get('name', '') for a in track_artists])}")
                    try:
                        # Atualizar ID da faixa atual para o sistema de pré-carregamento
                        self._update_current_track_id(track.get('id'))

                        self._generate_card(track, params, progress_ms, force_spotify=True)
                        log(f"[Nowfy] _generate_card completed successfully")

                        # Limpar cache antigo após gerar o card
                        self._cleanup_preload_cache()

                        # Iniciar Dynamic Island overlay de forma segura
                        try:
                            self._safe_start_dynamic_island_overlay()
                        except Exception:
                            pass

                    except Exception as e:
                        log(f"[Nowfy] Error in _generate_card: {e}")
                        import traceback
                        log(f"[Nowfy] _generate_card traceback: {traceback.format_exc()}")
                        raise e

                    if self.get_setting("enable_autobio", False) and is_playing:
                        autobio_text = self.get_setting("autobio_text", "Now Playing: {track} by {artist}")
                        bio = autobio_text.format(track=track["name"], artist=", ".join([a["name"] for a in track["artists"]]))
                        run_on_ui_thread(lambda: self._update_bio(bio, show_bulletin=False))

                    if self.get_setting("show_bio_notification", True):
                        if not self.get_setting("enable_auto_bio_update", True):
                            BulletinHelper.show_info(tr("bio_notification_disabled"))
                else:
                    # Restore bio se não houver música tocando
                    log(f"[Nowfy] .now command - No track playing or paused")
                    try:
                        user_full = get_messages_controller().getUserFull(get_user_config().getClientUserId())
                        current_bio = user_full.about if user_full else ""
                        restore_bio_text = self.get_setting("restore_bio_text", "").strip()

                        if current_bio and current_bio.strip():
                            restore_bio = current_bio
                        elif restore_bio_text:
                            restore_bio = restore_bio_text
                        else:
                            restore_bio = "I'm using nowFy!"
                    except:
                        restore_bio_text = self.get_setting("restore_bio_text", "").strip()
                        restore_bio = restore_bio_text if restore_bio_text else "I'm using nowFy!"

                    run_on_ui_thread(lambda: self._update_bio(restore_bio, show_bulletin=False, is_restore=True))
                    BulletinHelper.show_info(tr("no_track_playing"))
            else:
                # Restore bio se não houver música tocando ou resposta inválida
                log(f"[Nowfy] .now command - Invalid API response or no content - Status: {resp.status_code}")
                if resp.status_code != 200:
                    log(f"[Nowfy] API Error Response: {resp.text if hasattr(resp, 'text') else 'No response text'}")

                try:
                    user_full = get_messages_controller().getUserFull(get_user_config().getClientUserId())
                    current_bio = user_full.about if user_full else ""
                    restore_bio_text = self.get_setting("restore_bio_text", "").strip()

                    if current_bio and current_bio.strip():
                        restore_bio = current_bio
                    elif restore_bio_text:
                        restore_bio = restore_bio_text
                    else:
                        restore_bio = "I'm using nowFy!"
                except:
                    restore_bio_text = self.get_setting("restore_bio_text", "").strip()
                    restore_bio = restore_bio_text if restore_bio_text else "I'm using nowFy!"

                run_on_ui_thread(lambda: self._update_bio(restore_bio, show_bulletin=False, is_restore=True))
                BulletinHelper.show_info(tr("no_track_playing"))

        except Exception as e:
            log(f"[exteraFy] Error in now command: {e}")
            self._send_msg(params, f"Erro: {e}")
        finally:
            if self.get_setting("enable_quick_dismiss", True):
                run_on_ui_thread(self._dismiss_loading_dialog)

    def _send_now_playing_card(self, restrict_stats_now=False):
        """Envia o card Now Playing baseado na fonte selecionada; se restrict_stats_now=True, usa apenas .stats ou .now"""
        try:
            # Obter a fonte selecionada
            source_index = self.get_setting("now_card_source", 0)
            sources = ["Spotify", "Stats.fm", "Last.fm", "AyuGram", "exteraGram"]
            selected_source = sources[source_index]
            
            log(f"[Nowfy] Send Card Now - Source: {selected_source}")
            
            # Mapear source para comando
            command_map = {
                "Spotify": self.get_setting("custom_command", ".now"),
                "Stats.fm": ".stats",
                "Last.fm": ".fm",
                "AyuGram": ".ayu",
                "exteraGram": ".etg"
            }
            
            # Se restrito, usar apenas .stats (Stats.fm) ou .now (demais fontes)
            if bool(restrict_stats_now):
                command = ".stats" if selected_source == "Stats.fm" else ".now"
            else:
                command = command_map.get(selected_source, ".now")
            self._last_overlay_trigger_command = command
            log(f"[Nowfy] Sending command: {command}")
            
            # Enviar o comando como se fosse digitado pelo usuário
            # Isso garantirá que o hook de mensagem intercepte e processe corretamente
            fragment = get_last_fragment()
            if not fragment:
                BulletinHelper.show_info("Unable to get chat context")
                return
            
            # Obter o send helper e enviar o comando
            def send_command():
                try:
                    send_helper = get_send_messages_helper()
                    # Simular digitação do comando
                    from org.telegram.messenger import SendMessagesHelper
                    
                    # O comando será interceptado pelo hook antes de ser enviado
                    run_on_ui_thread(lambda: send_helper.sendMessage(
                        SendMessagesHelper.SendMessageParams.of(
                            command,
                            fragment.getDialogId()
                        )
                    ))
                except Exception as e:
                    log(f"[Nowfy] Error sending command: {e}")
                    # Fallback: tentar método direto
                    try:
                        account = get_user_config()
                        from java.util import ArrayList
                        
                        class MockParams:
                            def __init__(self):
                                self.message = command
                                self.entities = ArrayList()
                                self.photo = None
                                self.path = None
                                self.caption = None
                            
                            def __setitem__(self, key, value):
                                setattr(self, key, value)
                            
                            def __getitem__(self, key):
                                return getattr(self, key, None)
                        
                        params = MockParams()
                        
                        # Executar comando baseado na fonte selecionada
                        if selected_source == "Spotify":
                            self._handle_now_restore_bio(params)
                        elif selected_source == "Stats.fm":
                            self._handle_stats_only(account, params)
                        elif selected_source == "Last.fm":
                            self._handle_fm_only_lastfm(account, params)
                        elif selected_source == "AyuGram":
                            self._handle_ayu_command(account, params)
                        elif selected_source == "exteraGram":
                            self._handle_etg_command(account, params)
                    except Exception as fallback_error:
                        log(f"[Nowfy] Fallback error: {fallback_error}")
                        BulletinHelper.show_info(f"Error: {fallback_error}")
            
            run_on_queue(send_command)
            
        except Exception as e:
            log(f"[Nowfy] Error in _send_now_playing_card: {e}")
            BulletinHelper.show_info(f"Error: {e}")

    def _try_statsfm_now_playing(self, params, username):
        """Tenta obter música atual do Stats.fm"""
        try:
            import requests
            url = f"https://api.stats.fm/api/v1/users/{username}/streams/current"
            headers = {
                "Accept": "application/json",
                "User-Agent": "NowfyPlugin/1.0"
            }
            
            resp = requests.get(url, headers=headers, timeout=5)
            if resp.status_code == 200:
                data = resp.json()
                item = data.get("item")
                if item and item.get("isPlaying"):
                    # Criar um objeto de track compatível com o formato do Spotify
                    track_info = item.get("track", {})
                    artists_list = []
                    for artist_name in track_info.get("artists", []):
                        artists_list.append({"name": artist_name["name"]})
                    
                    album = track_info["albums"][0] if track_info.get("albums") else {}
                    album_images = []
                    if album.get("image"):
                        album_images.append({"url": album.get("image"), "width": 640, "height": 640})
                    
                    spotify_id = None
                    if track_info.get("externalIds") and track_info["externalIds"].get("spotify"):
                        spotify_id = track_info["externalIds"]["spotify"][0]
                    
                    # Criar objeto de track no formato do Spotify
                    track = {
                        "name": track_info.get("name", ""),
                        "artists": artists_list,
                        "album": {
                            "name": album.get("name", ""),
                            "images": album_images
                        },
                        "external_urls": {
                            "spotify": f"https://open.spotify.com/track/{spotify_id}" if spotify_id else None
                        },
                        "duration_ms": track_info.get("durationMs", 0)
                    }
                    
                    # Usar o _generate_card para aplicar o tema selecionado
                    # No comando .now, não devemos aplicar overlay do Last.fm
                    progress_ms = item.get("progressMs", 0)
                    self._generate_card(track, params, progress_ms, force_spotify=False, etg_cover_image=None, is_fm_command=False)
                    log(f"[Nowfy] Stats.fm track found and displayed: {track_info.get('name', '')}")
                    return True
                else:
                    log(f"[Nowfy] Stats.fm: No track currently playing")
                    return False
            else:
                log(f"[Nowfy] Stats.fm API error: {resp.status_code} - {resp.text}")
                return False
        except Exception as e:
            log(f"[Nowfy] Stats.fm connection failed: {str(e)}")
            return False
    
    def _try_lastfm_now_playing(self, params, username, api_key):
        """Tenta obter música atual do Last.fm"""
        try:
            # Usar requests em vez de pylast para evitar dependência externa
            import requests
            url = "http://ws.audioscrobbler.com/2.0/"
            params = {
                'method': 'user.getrecenttracks',
                'user': username,
                'api_key': api_key,
                'format': 'json',
                'limit': 1
            }
            
            resp = requests.get(url, params=params, timeout=5)
            if resp.status_code == 200:
                data = resp.json()
                tracks = data.get('recenttracks', {}).get('track', [])
                if tracks and isinstance(tracks, list) and len(tracks) > 0:
                    track_item = tracks[0]
                    # Considerar como tocando apenas quando o atributo nowplaying estiver presente e verdadeiro
                    nowplaying_attr = None
                    if isinstance(track_item, dict):
                        nowplaying_attr = track_item.get('@attr', {}).get('nowplaying')
                    is_playing = str(nowplaying_attr).lower() in ('true', '1', 'yes')

                    if is_playing:
                        title = track_item.get('name', '')
                        artist_name = track_item.get('artist', {}).get('#text', '') if isinstance(track_item.get('artist'), dict) else str(track_item.get('artist', ''))
                        album_name = track_item.get('album', {}).get('#text', '') if isinstance(track_item.get('album'), dict) else str(track_item.get('album', ''))

                        # Obter URL da imagem do álbum
                        image_url = None
                        images = track_item.get('image', [])
                        if images:
                            for img in images:
                                if img.get('size') == 'large':
                                    image_url = img.get('#text', '')
                                    break

                        # Criar objeto de track no formato do Spotify
                        track = {
                            "name": title,
                            "artists": [{"name": artist_name}],
                            "album": {
                                "name": album_name,
                                "images": [{"url": image_url, "width": 640, "height": 640}] if image_url else []
                            },
                            "external_urls": {
                                "spotify": None
                            },
                            "duration_ms": 0
                        }

                        # Usar o _generate_card para aplicar o tema selecionado
                        # No comando .now, não devemos aplicar overlay do Last.fm
                        self._generate_card(track, params, 0, force_spotify=False, etg_cover_image=None, is_fm_command=False)
                        log(f"[Nowfy] Last.fm track found and displayed: {title}")
                        return True
                    else:
                        log(f"[Nowfy] Last.fm: Track found but not currently playing")
                        return False
                else:
                    log(f"[Nowfy] Last.fm: No tracks found")
                    return False
        except Exception as e:
            log(f"[Nowfy] Last.fm error: {e}")
            return False

    def _search_tracks(self, account, params, query):
        try:
            token = self._get_access_token()
            if not token:
                self._send_msg(params, "bio_error")
                return

            search_type = "track"
            if query.startswith(".album "):
                search_type = "album"
                query = query[7:].strip()

            resp = requests.get(
                f"https://api.spotify.com/v1/search?q={query}&type={search_type}&limit=5",
                headers={"Authorization": f"Bearer {token}"},
                timeout=5
            )

            if resp.status_code != 200:
                self._send_msg(params, "bio_error")
                return

            data = resp.json()
            items = data.get(f"{search_type}s", {}).get("items", [])
            if not items:
                self._send_msg(params, "no_track_playing")
                return

            self._search_cache[account] = items
            # Monta mensagem
            message = f"{tr('search_results')}\n\n"
            for i, item in enumerate(items, 1):
                title = item["name"]
                artists = ", ".join([a["name"] for a in item["artists"]])
                if search_type == "track":
                    album = item["album"]["name"]
                    message += f"{i}. {title}\nby {artists} • {album}\n\n"
                else:
                    total_tracks = item["total_tracks"]
                    release_date = item["release_date"][:4]
                    message += f"{i}. {title}\nby {artists} • {total_tracks} tracks • {release_date}\n\n"
            play_type = 'a track' if search_type == 'track' else 'an album'
            message += f"\n{tr('use_play_command').format(play_type) if 'use_play_command' in TRANSLATIONS else ''}"

            # Exibe em dialog
            from ui.alert import AlertDialogBuilder
            fragment = get_last_fragment()
            ctx = fragment.getParentActivity() if fragment and fragment.getParentActivity() else ApplicationLoader.applicationContext
            builder = AlertDialogBuilder(ctx, AlertDialogBuilder.ALERT_TYPE_MESSAGE)
            builder.set_title(tr("search_results"))
            builder.set_message(message)
            # Corrigindo o callback do botão OK para não fechar o app
            builder.set_positive_button("OK", None)
            dialog = builder.create()
            run_on_ui_thread(dialog.show)

        except Exception as e:
            self._send_msg(params, f"Erro: {str(e)}")

    def _get_recently_played(self, params):
        try:
            token = self._get_access_token()
            if not token:
                self._send_msg(params, "bio_error")
                return
            resp = requests.get(
                "https://api.spotify.com/v1/me/player/recently-played?limit=5",
                headers={"Authorization": f"Bearer {token}"},
                timeout=5
            )
            if resp.status_code == 403:
                self._send_msg(params, "error_premium_required")
                return
            if resp.status_code != 200:
                self._send_msg(params, "bio_error")
                return
            data = resp.json()
            items = data.get("items", [])
            if not items:
                self._send_msg(params, "no_track_playing")
                return
            # Novo formato: título e lista numerada, indicando que são as mais recentes
            message = tr("recently_played_title") + "\n" + "\n".join([
                f"{i+1}. {item['track']['name']} — {', '.join([a['name'] for a in item['track']['artists']])}" for i, item in enumerate(items)
            ])
            fragment = get_last_fragment()
            def on_copy():
                # Usar context do fragment para compatibilidade
                if hasattr(fragment, 'getParentActivity') and fragment.getParentActivity():
                    context = fragment.getParentActivity()
                else:
                    from org.telegram.messenger import ApplicationLoader
                    context = ApplicationLoader.applicationContext
                
                # Copiar para clipboard usando context
                clipboard = context.getSystemService(Context.CLIPBOARD_SERVICE)
                clip = ClipData.newPlainText("message", message)
                clipboard.setPrimaryClip(clip)
                
                run_on_ui_thread(lambda: (BulletinHelper.show_success(tr("copied_bulletin"), fragment)))
            music_icon = getattr(R.raw, "music", R.raw.info)
            run_on_ui_thread(lambda: BulletinHelper.show_with_button(
                tr('list_bulletin_short'),
                music_icon,
                tr("copy_button"),
                on_copy,
                fragment
            ))
        except Exception as e:
            self._send_msg(params, f"Erro: {str(e)}")

    def _play_track(self, account, params, track_number):
        try:
            token = self._get_access_token()
            if not token:
                self._send_msg(params, "bio_error")
                return
            # Se for número, usa o cache da busca
            try:
                item_index = int(track_number) - 1
                if not hasattr(self, '_search_cache') or account not in self._search_cache:
                    self._send_msg(params, "no_track_playing")
                    return
                if item_index < 0 or item_index >= len(self._search_cache[account]):
                    self._send_msg(params, "error_invalid_number")
                    return
                item = self._search_cache[account][item_index]
                is_album = "total_tracks" in item
                play_request = {"context_uri": item["uri"]} if is_album else {"uris": [item["uri"]]}
            except ValueError:
                # Se não for número, tenta tocar pelo track_id
                track_id = track_number.strip()
                if not track_id or len(track_id) < 5:
                    self._send_msg(params, "error_invalid_number")
                    return
                play_request = {"uris": [f"spotify:track:{track_id}"]}
            resp = requests.put(
                "https://api.spotify.com/v1/me/player/play",
                headers={"Authorization": f"Bearer {token}"},
                json=play_request,
                timeout=5
            )
            if resp.status_code == 404:
                self._send_msg(params, "no_track_playing")
            elif resp.status_code == 403:
                self._send_msg(params, "error_premium_required")
            elif resp.status_code != 204:
                self._send_msg(params, "bio_error")
            else:
                self._send_msg(params, "bulletin_playing")
        except Exception as e:
            self._send_msg(params, f"Erro: {str(e)}")

    def _toggle_repeat(self, params):
        try:
            token = self._get_access_token()
            if not token:
                self._send_msg(params, "bio_error")
                return
            resp = requests.get(
                "https://api.spotify.com/v1/me/player",
                headers={"Authorization": f"Bearer {token}"},
                timeout=5
            )
            if resp.status_code == 401:
                self._send_msg(params, "bio_error")
                return
            elif resp.status_code == 403:
                self._send_msg(params, "error_premium_required")
                return
            elif resp.status_code == 404:
                self._send_msg(params, "no_track_playing")
                return
            data = resp.json()
            current_repeat = data.get("repeat_state", "off")
            states = {"off": "context", "context": "track", "track": "off"}
            new_repeat = states.get(current_repeat, "off")
            resp = requests.put(
                f"https://api.spotify.com/v1/me/player/repeat?state={new_repeat}",
                headers={"Authorization": f"Bearer {token}"},
                timeout=5
            )
            if resp.status_code == 204:
                self._send_msg(params, f"repeat_{new_repeat}")
            else:
                self._send_msg(params, "bio_error")
        except Exception as e:
            self._send_msg(params, f"Erro: {str(e)}")

    def _toggle_shuffle(self, params):
        try:
            token = self._get_access_token()
            if not token:
                self._send_msg(params, "bio_error")
                return
            resp = requests.get(
                "https://api.spotify.com/v1/me/player",
                headers={"Authorization": f"Bearer {token}"},
                timeout=5
            )
            if resp.status_code == 401:
                self._send_msg(params, "bio_error")
                return
            elif resp.status_code == 403:
                self._send_msg(params, "error_premium_required")
                return
            elif resp.status_code == 404:
                self._send_msg(params, "no_track_playing")
                return
            data = resp.json()
            current_shuffle = data.get("shuffle_state", False)
            new_shuffle = not current_shuffle
            resp = requests.put(
                f"https://api.spotify.com/v1/me/player/shuffle?state={str(new_shuffle).lower()}",
                headers={"Authorization": f"Bearer {token}"},
                timeout=5
            )
            if resp.status_code == 204:
                state_key = "shuffle_enabled" if new_shuffle else "shuffle_disabled"
                self._send_msg(params, state_key)
            else:
                self._send_msg(params, "bio_error")
        except Exception as e:
            self._send_msg(params, f"Erro: {str(e)}")

    def _generate_minimal_card(self, track, params=None, force_spotify=False, etg_cover_image=None):
        try:
            title = track["name"]
            artists = ", ".join([a["name"] for a in track["artists"]])
            spotify_link = track["external_urls"]["spotify"]

            # Usar song.link se habilitado
            use_song_link = self.get_setting("use_song_link", False)
            show_track_link = self.get_setting("show_track_link", True)

            if use_song_link:
                track_link = self._get_song_link(spotify_link)
            else:
                track_link = spotify_link

            # Formatar texto com markdown V2
            playing_text = tr("playing")

            if show_track_link:
                message = f"{playing_text}\n*{title}* by *{artists}* • [Spotify]({track_link})"
            else:
                message = f"{playing_text}\n*{title}* by *{artists}*"
            
            # Adicionar bot_caption se estiver no modo NowCast
            is_nowcast_mode = getattr(self, '_nowcast_mode', False)
            if is_nowcast_mode:
                bot_caption = self.get_setting("bot_caption_text", "")
                if bot_caption:
                    # Processar variáveis {track}, {artist} e {album} no bot caption
                    processed_bot_caption = bot_caption.strip()
                    if "{track}" in processed_bot_caption or "{artist}" in processed_bot_caption or "{album}" in processed_bot_caption:
                        album = track.get("album", {}).get("name", "Unknown Album") if track.get("album") else "Unknown Album"
                        processed_bot_caption = processed_bot_caption.replace("{track}", title)
                        processed_bot_caption = processed_bot_caption.replace("{artist}", artists)
                        processed_bot_caption = processed_bot_caption.replace("{album}", album)
                    message += f"\n\n{processed_bot_caption}"
            # Parse markdown
            parsed = parse_markdown(message)
            # Enviar mensagem ou preparar dados para NowCast
            if params:
                params.message = parsed.text
                params.entities = ArrayList()
                for entity in parsed.entities:
                    params.entities.add(entity.to_tlrpc_object())

                # Verificar se está no modo NowCast
                if not getattr(self, '_nowcast_mode', False):
                    send_helper = get_send_messages_helper()
                    run_on_ui_thread(lambda: send_helper.sendMessage(params))
                # No modo NowCast, apenas preparar os dados (não enviar)
        except Exception as e:
            if params:
                self._send_msg(params, f"Erro: {e}")

    def _ensure_extera_font(self, font_id):
        """Baixa e cacheia a fonte selecionada se não existir."""
        import requests
        font_dir = "/storage/emulated/0/Android/media/com.exteragram.messenger/fonts"
        if not os.path.exists(font_dir):
            os.makedirs(font_dir)
        if font_id == 1:  # NotoSansCJK
            font_path = f"{font_dir}/exteraCJK.ttc"
            url = "https://github.com/googlefonts/noto-cjk/raw/main/Sans/OTC/NotoSansCJK-Regular.ttc"
        else:  # SourceSansPro
            return "/system/fonts/SourceSansPro-Bold.ttf"
        if not os.path.exists(font_path):
            try:
                # Usar cache otimizado para download da fonte
                font_data = self._get_cached_image_enhanced(url, f"font_{font_id}_{hash(url)}")
                if font_data:
                    with open(font_path, "wb") as f:
                        f.write(font_data)
            except Exception as e:
                pass  # Se falhar, ignora e usa a fonte padrão
        return font_path

    def _resize_with_aspect_ratio(self, img, target_size):
        """Redimensiona a imagem mantendo a proporção e centralizando-a"""
        # Cria uma imagem de fundo preta
        background = Image.new("RGBA", target_size, (30, 30, 30, 255))
        
        # Verifica se a imagem é muito mais larga ou alta
        width, height = img.size
        aspect_ratio = width / height
        target_aspect_ratio = target_size[0] / target_size[1]
        
        # SEMPRE usar min() para manter a proporção original e evitar espremimento
        # Isso garante que a imagem nunca seja distorcida, mesmo que resulte em áreas vazias
        ratio = min(target_size[0] / width, target_size[1] / height)
        
        new_size = (int(width * ratio), int(height * ratio))
        # Redimensiona a imagem original
        resized_img = img.resize(new_size, Image.LANCZOS)
        # Se a imagem redimensionada for maior que o alvo, recorta o centro
        if new_size[0] > target_size[0] or new_size[1] > target_size[1]:
            left = (new_size[0] - target_size[0]) // 2 if new_size[0] > target_size[0] else 0
            top = (new_size[1] - target_size[1]) // 2 if new_size[1] > target_size[1] else 0
            right = left + target_size[0] if new_size[0] > target_size[0] else new_size[0]
            bottom = top + target_size[1] if new_size[1] > target_size[1] else new_size[1]
            
            cropped_img = resized_img.crop((left, top, right, bottom)) 
            # Ajusta o tamanho final se necessário
            if cropped_img.size != target_size:
                background = Image.new("RGBA", target_size, (30, 30, 30, 255))
                pos_x = (target_size[0] - cropped_img.size[0]) // 2
                pos_y = (target_size[1] - cropped_img.size[1]) // 2
                background.paste(cropped_img, (pos_x, pos_y), cropped_img)
                return background
            
            return cropped_img
        else:
            # Calcula posição para centralizar
            pos_x = (target_size[0] - new_size[0]) // 2
            pos_y = (target_size[1] - new_size[1]) // 2
            
            # Cola a imagem redimensionada no centro do fundo
            background.paste(resized_img, (pos_x, pos_y), resized_img)
            return background


    def _generate_apple_unified_card(self, track, params=None, progress_ms=None, force_spotify=False, etg_cover_image=None):
        """Função unificada para gerar cards Apple usando o sistema de skin."""
        try:
            # Obter skin selecionada (0=Light, 1=Dark, 2=Red)
            apple_skin = self._get_apple_skin_index_mapped()
            
            # Validar se o índice está dentro dos limites válidos
            if apple_skin not in APPLE_SKIN_STYLE:
                apple_skin = 0  # Default para Light se índice inválido
            
            # Obter configurações de estilo baseadas na skin
            skin_style = APPLE_SKIN_STYLE[apple_skin]
            
            # Carregar imagem base usando o sistema unificado
            base_path = self._ensure_card_base_image(theme=0)
            img = Image.open(base_path).convert("RGBA")
            
            title = track["name"]
            artists = ", ".join([a["name"] for a in track["artists"]])
            target_size = (298, 298)
            
            # Usar a imagem de capa do ETG se disponível
            if etg_cover_image is not None:
                # Aplicar anti-aliasing avançado do Apple UI
                cover = self._apply_apple_antialiasing(etg_cover_image, target_size)
            else:
                # Detectar player atual
                player_name = self._detect_current_player()
                
                # Lógica específica para SoundCloud (igual ao CustomFM)
                if player_name == "SoundCloud":
                    # Primeiro tentar obter capa diretamente do SoundCloud
                    soundcloud_cover_url = self.get_soundcloud_cover(title, artists)
                    if soundcloud_cover_url:
                        try:
                            resp = requests.get(soundcloud_cover_url, timeout=10)
                            resp.raise_for_status()
                            cover = Image.open(BytesIO(resp.content)).convert("RGBA")
                            # Aplicar anti-aliasing avançado do Apple UI
                            cover = self._apply_apple_antialiasing(cover, target_size)
                        except Exception as e:
                            log(f"Erro ao carregar capa do SoundCloud: {e}")
                            # Fallback para YouTube apenas se SoundCloud falhar
                            youtube_cover_url = self._get_youtube_cover(title, artists)
                            if youtube_cover_url == "https://i.postimg.cc/4yjVLFTV/icondefault.png":
                                youtube_cover_url = self._get_youtube_thumbnail_forced(title, artists)
                            try:
                                resp = requests.get(youtube_cover_url, timeout=10)
                                resp.raise_for_status()
                                cover = Image.open(BytesIO(resp.content)).convert("RGBA")
                                cover = self._apply_apple_antialiasing(cover, target_size)
                            except Exception:
                                cover = Image.new("RGBA", target_size, (30, 30, 30, 255))
                    else:
                        # Fallback para YouTube se SoundCloud não retornar capa
                        youtube_cover_url = self._get_youtube_cover(title, artists)
                        if youtube_cover_url == "https://i.postimg.cc/4yjVLFTV/icondefault.png":
                            youtube_cover_url = self._get_youtube_thumbnail_forced(title, artists)
                        try:
                            resp = requests.get(youtube_cover_url, timeout=10)
                            resp.raise_for_status()
                            cover = Image.open(BytesIO(resp.content)).convert("RGBA")
                            # Aplicar anti-aliasing avançado do Apple UI
                            cover = self._apply_apple_antialiasing(cover, target_size)
                        except Exception as e:
                            log(f"Erro ao carregar capa do YouTube para SoundCloud: {e}")
                            cover = Image.new("RGBA", target_size, (30, 30, 30, 255))
                elif player_name in ("YouTube", "YouTube Music", "Yandex Music", "FM"):
                    # Lógica dedicada: obter capa do YouTube/YouTube Music/Yandex/FMs
                    try:
                        youtube_cover_url = self._get_youtube_cover(title, artists)
                        if youtube_cover_url == "https://i.postimg.cc/4yjVLFTV/icondefault.png":
                            youtube_cover_url = self._get_youtube_thumbnail_forced(title, artists)
                        resp = requests.get(youtube_cover_url, timeout=10)
                        resp.raise_for_status()
                        cover = Image.open(BytesIO(resp.content)).convert("RGBA")
                        # Aplicar anti-aliasing avançado do Apple UI
                        cover = self._apply_apple_antialiasing(cover, target_size)
                    except Exception as e:
                        log(f"Erro ao carregar capa do YouTube: {e}")
                        # Fallback obrigatório: tentar APIs, YouTube cover ou icondefault
                        cover = self._get_fallback_cover(title, artists)
                else:
                    # Lógica original para outros players
                    images = track["album"].get("images", [])
                    cover_url = max(images, key=lambda i: i.get("width", 0))["url"] if images else None
                    if cover_url:
                        try:
                            resp = requests.get(cover_url, timeout=10)
                            cover = Image.open(BytesIO(resp.content)).convert("RGBA")
                            # Aplicar anti-aliasing avançado do Apple UI
                            cover = self._apply_apple_antialiasing(cover, target_size)
                        except Exception:
                            # Fallback obrigatório: tentar APIs, YouTube cover ou icondefault
                            cover = self._get_fallback_cover(title, artists)
                    else:
                        # Fallback obrigatório: tentar APIs, YouTube cover ou icondefault
                        cover = self._get_fallback_cover(title, artists)
            
            # Aplicar máscara arredondada
            mask = Image.new("L", (298, 298), 0)
            ImageDraw.Draw(mask).rounded_rectangle((0, 0, 298, 298), 30, fill=255)
            cover.putalpha(mask)
            img.paste(cover, (70, 153), cover)
            
            draw = ImageDraw.Draw(img)
            
            if self.get_setting("show_extera_bar", True):
                track_source = track.get("source") if isinstance(track, dict) else None
                if track_source in ("spotify", "statsfm"):
                    exterabar_fn_name = skin_style["exteraBar_fn"]
                    if exterabar_fn_name == "exteraBarSeek_light_opposite":
                        self.exteraBarSeek_light_opposite(draw, track, progress_ms)
                    elif exterabar_fn_name == "exteraBarSeek_dark_opposite":
                        self.exteraBarSeek_dark_opposite(draw, track, progress_ms)
                    elif exterabar_fn_name == "exteraBarSeek_red_opposite":
                        self.exteraBarSeek_red_opposite(draw, track, progress_ms)
                    else:
                        self.exteraBarSeek_dark_opposite(draw, track, progress_ms)
            
            # Configuração de fontes
            font_selector = self.get_setting("font_selector", 0)
            max_font_size = 54
            min_font_size = 36
            base_font_size = 42
            
            if len(title) <= 10:
                font_size = max_font_size
            elif len(title) <= 18:
                font_size = int(base_font_size + (max_font_size - base_font_size) * (18 - len(title)) / 8)
            else:
                font_size = min_font_size
            
            font_path_bold = self._get_font_path_by_selector(font_selector)
            font_path_regular = self._get_font_regular_by_selector(font_selector)
            
            # Prioridade: árabe > CJK > custom/padrão
            if self._is_arabic(artists):
                font_path_bold = "/system/fonts/NotoNaskhArabic-Bold.ttf"
                font_path_regular = "/system/fonts/NotoNaskhArabic-Regular.ttf"
            
            try:
                font_title = ImageFont.truetype(font_path_bold, font_size)
                font_artist = ImageFont.truetype(font_path_regular, 25)
                font_playing = ImageFont.truetype(font_path_regular, 26)
            except Exception as e:
                log(f"[Nowfy] Erro ao carregar fonte {font_path_bold} ou {font_path_regular}: {e}")
                font_title = ImageFont.load_default()
                font_artist = ImageFont.load_default()
                font_playing = ImageFont.load_default()
            
            # Configurações de texto baseadas na skin
            text_x = 400
            text_y = 160
            max_text_width = 600
            playing_text = tr("playing")
            
            if self._is_arabic(artists) or font_selector == 2:
                font_artist = ImageFont.truetype("/system/fonts/NotoNaskhArabic-Regular.ttf", 25)
                font_playing = ImageFont.truetype("/system/fonts/NotoNaskhArabic-Regular.ttf", 26)
            
            if font_selector == 1:
                font_artist = ImageFont.truetype(self._ensure_extera_font(1), 25)
                font_playing = ImageFont.truetype(self._ensure_extera_font(1), 26)
            
            # Desenhar textos com cores da skin
            text_y = self.draw_multiline_text(draw, playing_text, (text_x, text_y), font_playing, skin_style["playing_color"], max_text_width)
            text_y += 12
            text_y = self.draw_multiline_text(draw, title, (text_x, text_y), font_title, skin_style["title_color"], max_text_width)
            text_y += 20
            
            # Desenhar artista com quebra automática
            if not self._is_arabic(artists):
                text_y = self.draw_multiline_text(draw, artists, (text_x, text_y), font_artist, skin_style["artist_color"], max_text_width)
            else:
                draw.text((text_x, text_y), artists, font=font_artist, fill=skin_style["artist_color"])
                left, top, right, bottom = font_artist.getbbox("Ay")
                text_y += (bottom - top) + 4
            

            
            # Salvar imagem
            temp_dir = File(ApplicationLoader.getFilesDirFixed(), "exteraFy")
            if not temp_dir.exists():
                temp_dir.mkdirs()
            filename = f"{uuid.uuid4()}.png"
            temp_path = File(temp_dir, filename).getAbsolutePath()
            performance_mode = self.get_setting("performance_mode", 1)
            compress_level = 1 if performance_mode == 0 else 4 if performance_mode == 1 else 6
            img.save(temp_path, format="PNG", optimize=True, compress_level=compress_level)
            
            if params:
                self._send_card_with_caption(params, temp_path, track, force_spotify)
                
        except Exception as e:
            if params:
                self._send_msg(params, f"Erro: {e}")

    def _get_album_or_playlist_name(self, track):
        """Obtém o nome do álbum ou playlist baseado no modo selecionado."""
        try:
            mode = self.get_setting("vinify_album_playlist_mode", 0)
            
            # 0 = Desabilitado
            if mode == 0:
                return None
            
            # Obter token de acesso
            token = self._get_access_token(show_error_bulletin=False)
            if not token:
                return None
            
            # Obter informações atuais da reprodução
            resp = requests.get(
                "https://api.spotify.com/v1/me/player/currently-playing",
                headers={"Authorization": f"Bearer {token}"},
                timeout=5
            )
            
            if resp.status_code != 200 or not resp.content:
                return None
                
            data = resp.json()
            context = data.get("context")
            item = data.get("item")
            
            # 1 = Automático (detecta se é playlist ou álbum)
            if mode == 1:
                if context and context.get("type") == "playlist":
                    # É uma playlist
                    playlist_uri = context.get("uri")
                    if playlist_uri:
                        playlist_id = playlist_uri.split(":")[-1]
                        return self._get_playlist_name(playlist_id, token)
                else:
                    # É um álbum ou single
                    if item and "album" in item and "name" in item["album"]:
                        return item["album"]["name"]
            
            # 2 = Forçar Álbum
            elif mode == 2:
                if item and "album" in item and "name" in item["album"]:
                    return item["album"]["name"]
            
            # 3 = Forçar Playlist
            elif mode == 3:
                if context and context.get("type") == "playlist":
                    playlist_uri = context.get("uri")
                    if playlist_uri:
                        playlist_id = playlist_uri.split(":")[-1]
                        return self._get_playlist_name(playlist_id, token)
            
            return None
        except Exception as e:
            log(f"[Nowfy] Erro ao obter álbum/playlist: {e}")
            return None
    
    def _get_playlist_name(self, playlist_id, token):
        """Obtém o nome da playlist via API."""
        try:
            playlist_resp = requests.get(
                f"https://api.spotify.com/v1/playlists/{playlist_id}",
                headers={"Authorization": f"Bearer {token}"},
                timeout=5
            )
            if playlist_resp.status_code == 200:
                playlist_data = playlist_resp.json()
                return playlist_data.get("name")
            return None
        except Exception as e:
            log(f"[Nowfy] Erro ao obter nome da playlist: {e}")
            return None
    

    def _get_current_device_info(self):
        """Obtém informações do dispositivo atual de reprodução usando API oficial do Spotify ou Stats.fm como fallback."""
        # Tentar primeiro a API oficial do Spotify
        device_info = self._get_device_from_spotify_api()
        if device_info:
            return device_info["name"]  # Manter compatibilidade retornando apenas o nome
        
        # Se falhar, tentar a API do Stats.fm como fallback
        device_info = self._get_device_from_statsfm_api()
        if device_info:
            return device_info["name"]
        
        return None
    
    def _get_current_device_full_info(self):
        """Obtém informações completas do dispositivo (nome e tipo) usando API oficial do Spotify ou Stats.fm como fallback."""
        # Verificar se o usuário selecionou um tipo específico no seletor
        device_type_setting = self.get_setting("statsfm_device_type", 0)
        
        # Se não for "Automático" (0), usar o tipo selecionado pelo usuário
        if device_type_setting != 0:
            # Mapear seleção para tipo de dispositivo
            device_type_map = {
                1: "smartphone",  # Smartphone
                2: "computer",    # Computador
                3: "speaker",     # Alto-falante
                4: "tv",          # TV
                5: "web"          # Navegador Web
            }
            
            selected_device_type = device_type_map.get(device_type_setting, "computer")
            
            # Tentar obter o nome do dispositivo do Spotify primeiro
            spotify_device = self._get_device_from_spotify_api()
            if spotify_device:
                return {
                    "name": spotify_device["name"],
                    "type": selected_device_type  # Usar o tipo selecionado pelo usuário
                }
            
            # Se Spotify falhar, tentar Stats.fm
            statsfm_device = self._get_device_from_statsfm_api()
            if statsfm_device:
                return {
                    "name": statsfm_device["name"],
                    "type": selected_device_type  # Usar o tipo selecionado pelo usuário
                }
            
            # Se ambos falharem, retornar um dispositivo padrão com o tipo selecionado
            return {
                "name": "Unknown Device",
                "type": selected_device_type
            }
        
        # Se for "Automático" (0), usar a lógica original
        # Tentar primeiro a API oficial do Spotify
        device_info = self._get_device_from_spotify_api()
        if device_info:
            return device_info
        
        # Se falhar, tentar a API do Stats.fm como fallback
        return self._get_device_from_statsfm_api()
    
    def _get_device_from_spotify_api(self):
        """Obtém informações do dispositivo usando a API oficial do Spotify."""
        try:
            token = self._get_access_token(show_error_bulletin=False)
            if not token:
                return None
            
            # Usar o endpoint correto para obter dispositivos
            resp = requests.get(
                "https://api.spotify.com/v1/me/player/devices",
                headers={"Authorization": f"Bearer {token}"},
                timeout=5
            )
            
            if resp.status_code == 200 and resp.content:
                data = resp.json()
                devices = data.get("devices", [])
                
                # Procurar primeiro por dispositivo ativo
                for device in devices:
                    if device.get("is_active", False) and "name" in device:
                        return {
                            "name": device["name"],
                            "type": device.get("type", "computer").lower()
                        }
                
                # Se nenhum dispositivo estiver ativo, retornar o primeiro disponível
                if devices and "name" in devices[0]:
                    return {
                        "name": devices[0]["name"],
                        "type": devices[0].get("type", "computer").lower()
                    }
            
            return None
        except Exception as e:
            return None
    
    def _get_device_from_statsfm_api(self):
        """Obtém informações do dispositivo usando a API do Stats.fm."""
        try:
            # Primeiro, tentar obter o username do Stats.fm das configurações
            statsfm_username = self.get_setting("statsfm_username", "")
            if not statsfm_username:
                return None
            
            # Fazer requisição para a API do Stats.fm
            resp = requests.get(
                f"https://api.stats.fm/api/v1/users/{statsfm_username}/streams/current",
                timeout=5
            )
            
            if resp.status_code == 200 and resp.content:
                data = resp.json()
                
                # Verificar se há dados do item atual
                item = data.get("item")
                if item and "deviceName" in item:
                    device_name = item["deviceName"]
                    
                    # Obter tipo de dispositivo do seletor (Stats.fm não fornece tipo automaticamente)
                    device_type_setting = self.get_setting("statsfm_device_type", 0)
                    
                    # Mapear seleção para tipo de dispositivo
                    device_type_map = {
                        0: "computer",    # Automático (padrão)
                        1: "smartphone",  # Smartphone
                        2: "computer",    # Computador
                        3: "speaker",     # Alto-falante
                        4: "tv",          # TV
                        5: "web"          # Navegador Web
                    }
                    
                    device_type = device_type_map.get(device_type_setting, "computer")
                    
                    return {
                        "name": device_name,
                        "type": device_type
                    }
            
            return None
        except Exception as e:
            return None

    def _is_arabic(self, text):
        """Verifica se o texto contém caracteres árabes."""
        return any('\u0600' <= c <= '\u06FF' or '\u0750' <= c <= '\u077F' for c in text)

    def _get_custom_fonts_path(self):
        """Retorna o caminho da pasta de fontes customizadas."""
        return "/storage/emulated/0/Android/media/com.exteragram.messenger/fonts"

    def _list_custom_fonts(self):
        """Lista os arquivos de fontes customizadas (.ttf, .otf) na pasta padrão."""
        fonts_dir = self._get_custom_fonts_path()
        custom_fonts = []
        if os.path.exists(fonts_dir):
            for file in os.listdir(fonts_dir):
                if file.lower().endswith(('.ttf', '.otf')):
                    custom_fonts.append(file)
        return custom_fonts

    def _get_font_path_by_selector(self, font_selector):
        """Retorna o caminho da fonte de acordo com o índice do seletor, incluindo custom fonts."""
        custom_fonts = self._list_custom_fonts()
        # 0: SourceSansPro-Bold, 1: NotoSansCJK, 2: NotoNaskhArabic-Bold, 3+: custom
        if font_selector == 0:
            return "/system/fonts/SourceSansPro-Bold.ttf"
        elif font_selector == 1:
            return self._ensure_extera_font(1)
        elif font_selector == 2:
            return "/system/fonts/NotoNaskhArabic-Bold.ttf"
        elif font_selector > 2 and custom_fonts:
            idx = font_selector - 3
            if idx < len(custom_fonts):
                return os.path.join(self._get_custom_fonts_path(), custom_fonts[idx])
        return "/system/fonts/SourceSansPro-Bold.ttf"

    def _get_font_regular_by_selector(self, font_selector):
        """Retorna o caminho da fonte regular de acordo com o índice do seletor, incluindo custom fonts."""
        custom_fonts = self._list_custom_fonts()
        if font_selector == 0:
            return "/system/fonts/SourceSansPro-Regular.ttf"
        elif font_selector == 1:
            return self._ensure_extera_font(1)
        elif font_selector == 2:
            return "/system/fonts/NotoNaskhArabic-Regular.ttf"
        elif font_selector > 2 and custom_fonts:
            idx = font_selector - 3
            if idx < len(custom_fonts):
                return os.path.join(self._get_custom_fonts_path(), custom_fonts[idx])
        return "/system/fonts/SourceSansPro-Regular.ttf"

    def _get_font_for_title(self, text, selector, max_size=28, min_size=28, base_size=28, force_bold=False):
        # Notas do dev:
        # Como no default original o título é fixo em 28, deixei fixo, 
        # mas se quiser pode adaptar tamanho aqui também, mantendo 28 fixo é igual ao original
        # Se force_bold for True, sempre usa a fonte em negrito
        if force_bold:
            return ImageFont.truetype(self._get_font_path_by_selector(selector), max_size)
        else:
            return ImageFont.truetype(self._get_font_regular_by_selector(selector), max_size)

    def _get_font_for_artist(self, artist_text, selector, size=22, force_bold=False):
        if self._is_arabic(artist_text):
            # Para texto árabe, usar a fonte apropriada (regular ou bold)
            font_path = "/system/fonts/NotoNaskhArabic-Bold.ttf" if force_bold else "/system/fonts/NotoNaskhArabic-Regular.ttf"
            return ImageFont.truetype(font_path, size)
        # Para outros idiomas, usar a fonte regular ou bold conforme solicitado
        if force_bold:
            return ImageFont.truetype(self._get_font_path_by_selector(selector), size)  # Fonte em negrito
        else:
            return ImageFont.truetype(self._get_font_regular_by_selector(selector), size)  # Fonte regular

    def _get_default_font(self, size=20):
        return ImageFont.truetype("/system/fonts/SourceSansPro-Regular.ttf", size)

    # Utilitário para desenhar texto multilinha com quebra automática
    def draw_multiline_text(self, draw, text, position, font, fill, max_width, line_spacing=4):
        words = text.split() if " " in text else ([text] if len(text) <= 5 else list(text))
        lines, current_line = [], ""
        for word in words:
            test_line = current_line + " " + word if current_line else word
            if draw.textbbox((0, 0), test_line, font=font)[2] <= max_width:
                current_line = test_line
            else:
                lines.append(current_line)
                current_line = word
        if current_line:
            lines.append(current_line)
        x, y = position
        for line in lines:
            draw.text((x, y), line, font=font, fill=fill)
            left, top, right, bottom = font.getbbox("Ay")
            y += (bottom - top) + line_spacing
        return y

    def get_text_dimensions(self, text, font):
        """Função auxiliar para obter dimensões de texto de forma compatível com diferentes versões do PIL/Pillow"""
        try:
            # Método mais recente (Pillow >= 9.2.0)
            left, top, right, bottom = font.getbbox(text)
            return right - left, bottom - top
        except AttributeError:
            try:
                # Método antigo
                return font.getsize(text)
            except AttributeError:
                # Fallback para estimativa
                return len(text) * 8, font.size

    def get_multiline_height(self, draw, text, font, max_width, line_spacing=4):
        words = text.split() if " " in text else ([text] if len(text) <= 5 else list(text))
        lines, current_line = [], ""
        for word in words:
            test_line = current_line + " " + word if current_line else word
            width, _ = self.get_text_dimensions(test_line, font)
            if width <= max_width:
                current_line = test_line
            else:
                lines.append(current_line)
                current_line = word
        if current_line:
            lines.append(current_line)
        _, height = self.get_text_dimensions("Ay", font)
        return (height + line_spacing) * len(lines)

    def _about_custom_fonts_dialog(self, view=None):
        try:
            import requests
            import json
            import time

            fragment = get_last_fragment()
            ctx = fragment.getParentActivity() if fragment and fragment.getParentActivity() else ApplicationLoader.applicationContext
            
            builder = AlertDialogBuilder(ctx, AlertDialogBuilder.ALERT_TYPE_MESSAGE)
            builder.set_title(tr("about_custom_fonts"))

            try:
                timestamp = int(time.time())
                response = requests.get(f'https://raw.githubusercontent.com/soumaki/nowFy/refs/heads/main/customfonts.json?t={timestamp}')
                fonts_data = json.loads(response.text)

                if 'image_url' in fonts_data:
                    try:
                        if fonts_data['image_url'].endswith('.svg'):
                            builder.set_icon(fonts_data['image_url'], "#FFFFFF")
                        else:
                            img_response = requests.get(fonts_data['image_url'], timeout=5)
                            if img_response.status_code == 200:
                                builder.set_icon_from_bytes(img_response.content)
                    except Exception as e:
                        log(f"Error loading custom fonts image: {e}")

                try:
                    system_language = Locale.getDefault().getLanguage()
                except:
                    system_language = "en"
                fonts_info = fonts_data.get('custom_fonts_info', {})
                
                lang_content = fonts_info.get(system_language) or fonts_info.get('en')
                
                if lang_content:
                    message = lang_content['description'] + '\n\n'
                    for step in lang_content['steps']:
                        message += f'• {step}\n'
                else:
                    message = 'Information not available in your language.'

                builder.set_message(message)
            except Exception as e:
                builder.set_message(f"Error loading custom fonts info: {str(e)}\n\nPlease try again later.")
            builder.set_positive_button("OK", None)
            run_on_ui_thread(lambda: builder.show())
        except Exception as e:
            log(f"Error showing custom fonts dialog: {e}")

    def _show_custom_fonts_help(self):
        # Alias para manter compatibilidade
        self._about_custom_fonts_dialog()

    def _show_premium_emoji_help(self):
        """Mostra dialog com informações sobre como usar Premium Emoji"""
        try:
            fragment = get_last_fragment()
            if fragment:
                from ui.alert import AlertDialogBuilder
                ctx = fragment.getParentActivity() if fragment and fragment.getParentActivity() else ApplicationLoader.applicationContext
                builder = AlertDialogBuilder(ctx)
                builder.set_title(tr("premium_emoji_help_title"))
                builder.set_message(tr("premium_emoji_help_content"))
                builder.set_positive_button("OK", lambda b, w: b.dismiss())
                run_on_ui_thread(builder.show)
        except Exception as e:
            log(f"[Nowfy] Erro ao mostrar Premium Emoji Help: {e}")

    def _show_youtube_api_dialog(self):
        try:
            fragment = get_last_fragment()
            if fragment:
                from ui.alert import AlertDialogBuilder
                ctx = fragment.getParentActivity() if fragment and fragment.getParentActivity() else ApplicationLoader.applicationContext
                builder = AlertDialogBuilder(ctx)
                builder.set_title(tr("youtube_api_title"))
                builder.set_message(tr("youtube_api_guide"))
                builder.set_positive_button("OK", lambda b, w: b.dismiss())
                builder.set_neutral_button(tr("get_api_key"), lambda b, w: self._open_youtube_api_guide())
                run_on_ui_thread(builder.show)
        except Exception as e:
            log(f"[Nowfy] Erro ao abrir YouTube API Dialog: {e}")

    def _show_lastfm_api_dialog(self):
        try:
            fragment = get_last_fragment()
            if fragment:
                from ui.alert import AlertDialogBuilder
                ctx = fragment.getParentActivity() if fragment and fragment.getParentActivity() else ApplicationLoader.applicationContext
                builder = AlertDialogBuilder(ctx)
                builder.set_title(tr("lastfm_title"))
                builder.set_message(tr("lastfm_content"))
                builder.set_positive_button(tr("lastfm_get_api_key"), lambda b, w: self._open_lastfm_api_guide())
                builder.set_negative_button(tr("cancel"), None)
                run_on_ui_thread(builder.show)
        except Exception as e:
            log(f"[Nowfy] Error showing LastFM API dialog: {e}")

    def _show_spotify_search_dialog(self):
        """Mostra diálogo de pesquisa do Spotify com input e resultados"""
        try:
            log("[Nowfy] Opening Spotify search dialog")
            
            # Verificar se tem credenciais do Spotify
            if not self._has_spotify_credentials():
                from ui.bulletin import BulletinHelper
                BulletinHelper.show_error(tr("spotify_api_not_configured"))
                return
            
            fragment = get_last_fragment()
            if not fragment:
                log("[Nowfy] No fragment available for search dialog")
                return
            
            from ui.alert import AlertDialogBuilder
            ctx = fragment.getParentActivity() if fragment and fragment.getParentActivity() else ApplicationLoader.applicationContext
            
            # Criar campo de input
            from org.telegram.ui.Components import EditTextBoldCursor
            from android.text import InputType
            from android.util import TypedValue
            from org.telegram.ui.ActionBar import Theme
            
            input_field = EditTextBoldCursor(ctx)
            input_field.setHint(tr("spotify_search_hint"))
            input_field.setInputType(InputType.TYPE_CLASS_TEXT)
            input_field.setMaxLines(1)
            input_field.setSingleLine(True)
            input_field.setTextSize(TypedValue.COMPLEX_UNIT_DIP, 16)
            try:
                input_field.setTextColor(Theme.getColor(Theme.key_dialogTextBlack))
                input_field.setHintTextColor(Theme.getColor(Theme.key_dialogTextHint))
                input_field.setCursorColor(Theme.getColor(Theme.key_dialogTextLink))
            except Exception:
                pass
            input_field.setBackground(None)
            input_field.setPadding(AndroidUtilities.dp(12), AndroidUtilities.dp(12), AndroidUtilities.dp(12), AndroidUtilities.dp(12))
            
            # Criar diálogo com input
            builder = AlertDialogBuilder(ctx)
            builder.set_title(tr("spotify_search_title"))
            builder.set_message(tr("spotify_search_message"))
            builder.set_view(input_field)
            
            def on_search(dialog, widget):
                try:
                    query = str(input_field.getText().toString()).strip()
                    if not query:
                        return
                    
                    log(f"[Nowfy] Searching Spotify for: {query}")
                    
                    # Fechar diálogo de input
                    dialog.dismiss()
                    
                    # Fazer busca em thread separada
                    def search_thread():
                        try:
                            results = self._search_spotify_tracks(query)
                            if results:
                                # Mostrar resultados na UI thread
                                run_on_ui_thread(lambda: self._show_search_results_dialog(results))
                            else:
                                run_on_ui_thread(lambda: BulletinHelper.show_info(tr("no_results_found")))
                        except Exception as e:
                            log(f"[Nowfy] Search error: {e}")
                            run_on_ui_thread(lambda: BulletinHelper.show_error(f"{tr('search_error')}: {e}"))
                    
                    threading.Thread(target=search_thread, daemon=True).start()
                    
                except Exception as e:
                    log(f"[Nowfy] Search dialog error: {e}")
            
            builder.set_positive_button(tr("search_button"), on_search)
            builder.set_negative_button(tr("cancel_button"), None)
            
            run_on_ui_thread(builder.show)
            
        except Exception as e:
            log(f"[Nowfy] Error showing Spotify search dialog: {e}")
    
    def _has_spotify_credentials(self):
        """Verifica se as credenciais do Spotify estão configuradas"""
        try:
            client_id = self.get_setting("client_id", "")
            client_secret = self.get_setting("client_secret", "")
            refresh_token = self.get_setting("refresh_token", "")
            return bool(client_id and client_secret and refresh_token)
        except Exception:
            return False
    
    def _search_spotify_tracks(self, query, limit=10):
        """Busca faixas no Spotify usando a API"""
        try:
            # Obter token de acesso
            access_token = self._get_access_token()
            if not access_token:
                raise Exception("Não foi possível obter token de acesso do Spotify")
            
            # Fazer busca na API do Spotify
            search_url = "https://api.spotify.com/v1/search"
            headers = {
                "Authorization": f"Bearer {access_token}",
                "Content-Type": "application/json"
            }
            params = {
                "q": query,
                "type": "track",
                "limit": limit,
                "market": "BR"
            }
            
            response = requests.get(search_url, headers=headers, params=params, timeout=10)
            
            if response.status_code == 200:
                data = response.json()
                tracks = data.get("tracks", {}).get("items", [])
                
                # Formatar resultados
                results = []
                for track in tracks:
                    try:
                        track_info = {
                            "id": track["id"],
                            "name": track["name"],
                            "artist": ", ".join([artist["name"] for artist in track["artists"]]),
                            "album": track["album"]["name"],
                            "uri": track["uri"],
                            "preview_url": track.get("preview_url"),
                            "external_url": track["external_urls"].get("spotify", "")
                        }
                        results.append(track_info)
                    except Exception as e:
                        log(f"[Nowfy] Error processing track: {e}")
                        continue
                
                return results
            else:
                raise Exception(f"Spotify API error: {response.status_code}")
                
        except Exception as e:
            log(f"[Nowfy] Spotify search error: {e}")
            raise e
    
    def _show_search_results_dialog(self, results):
        """Mostra diálogo com resultados da pesquisa (como .player)"""
        try:
            fragment = get_last_fragment()
            if not fragment:
                return
            
            from ui.alert import AlertDialogBuilder
            ctx = fragment.getParentActivity() if fragment and fragment.getParentActivity() else ApplicationLoader.applicationContext
            
            # Preparar lista de opções
            options = []
            for track in results:
                option_text = f"{track['name']}\n{track['artist']}\n{track['album']}"
                options.append(option_text)
            
            def on_track_selected(dialog, index):
                try:
                    selected_track = results[index]
                    log(f"[Nowfy] Selected track: {selected_track['name']} by {selected_track['artist']}")
                    
                    # Reproduzir faixa imediatamente
                    self._play_spotify_track(selected_track["uri"])
                    
                    # Fechar diálogo
                    dialog.dismiss()
                    
                    # Mostrar confirmação
                    from ui.bulletin import BulletinHelper
                    BulletinHelper.show_success(f"{tr('playing_track')}: {selected_track['name']}")
                    
                except Exception as e:
                    log(f"[Nowfy] Error playing selected track: {e}")
                    from ui.bulletin import BulletinHelper
                    BulletinHelper.show_error(f"{tr('play_error')}: {e}")
            
            # Criar diálogo de seleção
            builder = AlertDialogBuilder(ctx)
            builder.set_title(f"{tr('search_results_title')} ({len(results)} {tr('results_found')})")
            builder.set_items(options, on_track_selected)
            builder.set_negative_button(tr("cancel_button"), None)
            
            builder.show()
            
        except Exception as e:
            log(f"[Nowfy] Error showing search results: {e}")
    
    def _play_spotify_track(self, track_uri):
        """Reproduz uma faixa específica no Spotify"""
        try:
            # Obter token de acesso
            access_token = self._get_access_token()
            if not access_token:
                raise Exception("Token de acesso não disponível")
            
            # Reproduzir faixa
            play_url = "https://api.spotify.com/v1/me/player/play"
            headers = {
                "Authorization": f"Bearer {access_token}",
                "Content-Type": "application/json"
            }
            data = {
                "uris": [track_uri]
            }
            
            response = requests.put(play_url, headers=headers, json=data, timeout=10)
            
            if response.status_code in [200, 204]:
                log(f"[Nowfy] Successfully started playing: {track_uri}")
            else:
                raise Exception(f"Spotify play error: {response.status_code} - {response.text}")
                
        except Exception as e:
            log(f"[Nowfy] Error playing Spotify track: {e}")
            raise e

    def _show_integration_info_dialog(self):
        try:
            fragment = get_last_fragment()
            if fragment:
                from ui.alert import AlertDialogBuilder
                ctx = fragment.getParentActivity() if fragment and fragment.getParentActivity() else ApplicationLoader.applicationContext
                builder = AlertDialogBuilder(ctx)
                builder.set_title(tr("integration_media_source_info"))
                builder.set_message(tr("integration_media_source_dialog"))
                builder.set_positive_button("OK", None)
                run_on_ui_thread(builder.show)
        except Exception as e:
            log(f"[Nowfy] Error showing integration info dialog: {e}")

    def _show_credentials_info_dialog(self):
        try:
            fragment = get_last_fragment()
            if fragment:
                from ui.alert import AlertDialogBuilder
                ctx = fragment.getParentActivity() if fragment and fragment.getParentActivity() else ApplicationLoader.applicationContext
                builder = AlertDialogBuilder(ctx)
                builder.set_title(tr("credentials_info"))
                builder.set_message(tr("credentials_info_dialog"))
                builder.set_positive_button("OK", None)
                run_on_ui_thread(builder.show)
        except Exception as e:
            log(f"[Nowfy] Error showing credentials info dialog: {e}")

    def _show_spotify_control_dialog(self):
        try:
            fragment = get_last_fragment()
            if fragment:
                from ui.alert import AlertDialogBuilder
                ctx = fragment.getParentActivity() if fragment and fragment.getParentActivity() else ApplicationLoader.applicationContext
                builder = AlertDialogBuilder(ctx)
                builder.set_title(tr("spotify_control"))
                builder.set_message(tr("spotify_control_dialog"))
                builder.set_positive_button("OK", None)
                run_on_ui_thread(builder.show)
        except Exception as e:
            log(f"[Nowfy] Error showing Spotify Control dialog: {e}")

    def _show_bio_command_info_dialog(self):
        try:
            fragment = get_last_fragment()
            if fragment:
                from ui.alert import AlertDialogBuilder
                ctx = fragment.getParentActivity() if fragment and fragment.getParentActivity() else ApplicationLoader.applicationContext
                builder = AlertDialogBuilder(ctx)
                builder.set_title(tr("bio_command_info"))
                builder.set_message(tr("bio_command_info_dialog"))
                builder.set_positive_button("OK", None)
                run_on_ui_thread(builder.show)
        except Exception as e:
            log(f"[Nowfy] Error showing bio command info dialog: {e}")

    def _on_player_changed(self, value):
        """Callback chamado quando o player ativo é alterado"""
        try:
            players = ["Spotify", "YouTube", "YouTube Music", "exteraGram", "AyuGram", "SoundCloud", "Apple Music", "Yandex Music", "FM"]
            if 0 <= value < len(players) and players[value] == "Yandex Music":
                # Mostrar dialog informativo sobre Yandex Music
                self._show_yandex_music_dialog()
        except Exception as e:
            log(f"[Nowfy] Error in _on_player_changed: {e}")

    def _show_yandex_music_dialog(self):
        """Mostra dialog informativo sobre Yandex Music"""
        try:
            fragment = get_last_fragment()
            if fragment:
                ctx = fragment.getParentActivity() if fragment and fragment.getParentActivity() else ApplicationLoader.applicationContext
                
                def show_dialog():
                    try:
                        builder = AlertDialogBuilder(ctx)
                        builder.set_title(tr("yandex_music_dialog_title"))
                        builder.set_message(tr("yandex_music_dialog_content"))
                        builder.set_positive_button("OK", lambda b, w: b.dismiss())
                        builder.show()
                    except Exception as e:
                        log(f"[Nowfy] Error creating Yandex Music dialog: {e}")
                
                run_on_ui_thread(show_dialog)
        except Exception as e:
            log(f"[Nowfy] Error showing Yandex Music dialog: {e}")

    def _open_youtube_api_guide(self):
        try:
            fragment = get_last_fragment()
            if fragment:
                ctx = fragment.getParentActivity() if fragment and fragment.getParentActivity() else ApplicationLoader.applicationContext
                intent = Intent(Intent.ACTION_VIEW, Uri.parse("https://github.com/soumaki/nowFy/blob/main/ytkey/guide.md#youtube-api-key-youtube-data-api-v3"))
                run_on_ui_thread(lambda: ctx.startActivity(intent))
        except Exception as e:
            log(f"[Nowfy] Erro ao abrir YouTube API Guide: {e}")

    def _open_lastfm_api_guide(self):
        try:
            fragment = get_last_fragment()
            if fragment:
                ctx = fragment.getParentActivity() if fragment and fragment.getParentActivity() else ApplicationLoader.applicationContext
                intent = Intent(Intent.ACTION_VIEW, Uri.parse("https://www.last.fm/api/account/create"))
                run_on_ui_thread(lambda: ctx.startActivity(intent))
        except Exception as e:
            log(f"[Nowfy] Erro ao abrir LastFM API Guide: {e}")

    def _resume_playback_only(self, params):
        try:
            # Original Spotify logic
            token = self._get_access_token()
            if not token:
                if self._should_show_error_bulletin("auth_error"):
                    BulletinHelper.show_info(tr("error_auth"))
                return
            resp = requests.put(
                "https://api.spotify.com/v1/me/player/play",
                headers={"Authorization": f"Bearer {token}"},
                timeout=5
            )
            if resp.status_code in (200, 202, 204):
                BulletinHelper.show_success(tr("bulletin_resumed"))
            elif resp.status_code == 403:
                BulletinHelper.show_info(tr("error_premium_required"))
            elif resp.status_code == 404:
                BulletinHelper.show_info(tr("error_no_active_device"))
            else:
                BulletinHelper.show_error(tr("error_unknown"))
        except Exception:
            BulletinHelper.show_error(tr("error_unknown"))

    def _pause_playback_only(self, params):
        try:
            # Original Spotify logic
            token = self._get_access_token()
            if not token:
                if self._should_show_error_bulletin("auth_error"):
                    BulletinHelper.show_info(tr("error_auth"))
                return
            resp = requests.put(
                "https://api.spotify.com/v1/me/player/pause",
                headers={"Authorization": f"Bearer {token}"},
                timeout=5
            )
            if resp.status_code in (200, 202, 204):
                BulletinHelper.show_info(tr("bulletin_paused"))
            elif resp.status_code == 403:
                BulletinHelper.show_info(tr("error_premium_required"))
            elif resp.status_code == 404:
                BulletinHelper.show_info(tr("error_no_active_device"))
            else:
                BulletinHelper.show_info(tr("error_unknown"))
        except Exception:
            BulletinHelper.show_info(tr("error_unknown"))

    def _skip_track(self, params):
        try:
            # Branch to Telegram MediaController if Pop Island source is Telegram
            try:
                data_source = int(self.get_setting("pop_data_source_selector", 0) or 0)
            except Exception:
                data_source = 0
            if data_source == 1:
                try:
                    from org.telegram.messenger import MediaController
                    mc = MediaController.getInstance()
                    success = False
                    try:
                        for method_name in ("playNextMessage", "nextAudio", "playNext"):
                            if hasattr(mc, method_name):
                                getattr(mc, method_name)()
                                success = True
                                break
                    except Exception:
                        success = False
                    try:
                        BulletinHelper.show_info(tr("bulletin_skipped") if success else tr("no_track_playing_generic"))
                    except Exception:
                        pass
                    return
                except Exception:
                    # Fallback to Spotify logic below if Telegram control fails
                    pass
            # Original Spotify logic
            token = self._get_access_token()
            if not token:
                if self._should_show_error_bulletin("auth_error"):
                    BulletinHelper.show_info(tr("error_auth"))
                return
            resp = requests.post(
                "https://api.spotify.com/v1/me/player/next",
                headers={"Authorization": f"Bearer {token}"},
                timeout=5
            )
            if resp.status_code in (200, 202, 204):
                BulletinHelper.show_info(tr("bulletin_skipped"))
                # Ativar pré-carregamento após pular faixa
                if self.get_setting("enable_preload", False):
                    # Aguardar um pouco para a nova faixa começar
                    def delayed_preload():
                        time.sleep(1)
                        self._preload_next_track_cover()
                    threading.Thread(target=delayed_preload, daemon=True).start()
            elif resp.status_code == 403:
                BulletinHelper.show_info(tr("error_premium_required"))
            elif resp.status_code == 404:
                BulletinHelper.show_info(tr("error_no_active_device"))
            else:
                BulletinHelper.show_info(tr("error_unknown"))
        except Exception:
            BulletinHelper.show_info(tr("error_unknown"))

    def _previous_track(self, params):
        try:
            # Original Spotify logic
            token = self._get_access_token()
            if not token:
                if self._should_show_error_bulletin("auth_error"):
                    BulletinHelper.show_info(tr("error_auth"))
                return
            resp = requests.post(
                "https://api.spotify.com/v1/me/player/previous",
                headers={"Authorization": f"Bearer {token}"},
                timeout=5
            )
            if resp.status_code in (200, 202, 204):
                BulletinHelper.show_info(tr("bulletin_previous"))
            elif resp.status_code == 403:
                BulletinHelper.show_info(tr("error_premium_required"))
            elif resp.status_code == 404:
                BulletinHelper.show_info(tr("error_no_active_device"))
            else:
                BulletinHelper.show_info(tr("error_unknown"))
        except Exception:
            BulletinHelper.show_info(tr("error_unknown"))

    def _set_volume(self, params, value):
        try:
            if not isinstance(value, int) or value < 0 or value > 100:
                BulletinHelper.show_info(tr("error_invalid_volume"))
                return
            token = self._get_access_token()
            if not token:
                if self._should_show_error_bulletin("auth_error"):
                    BulletinHelper.show_info(tr("error_auth"))
                return
            resp = requests.put(
                f"https://api.spotify.com/v1/me/player/volume?volume_percent={value}",
                headers={"Authorization": f"Bearer {token}"},
                timeout=5
            )
            if resp.status_code in (200, 202, 204):
                BulletinHelper.show_info(tr("bulletin_volume_set").format(value=value))
            elif resp.status_code == 403:
                BulletinHelper.show_info(tr("error_premium_required"))
            elif resp.status_code == 404:
                BulletinHelper.show_info(tr("error_no_active_device"))
            else:
                BulletinHelper.show_info(tr("error_unknown"))
        except Exception as e:
            BulletinHelper.show_info(tr("error_unknown"))

    def _set_repeat(self, params, mode):
        try:
            if mode not in ("off", "context", "track"):
                BulletinHelper.show_info(tr("error_invalid_repeat"))
                return
            token = self._get_access_token()
            if not token:
                if self._should_show_error_bulletin("auth_error"):
                    BulletinHelper.show_info(tr("error_auth"))
                return
            resp = requests.put(
                f"https://api.spotify.com/v1/me/player/repeat?state={mode}",
                headers={"Authorization": f"Bearer {token}"},
                timeout=5
            )
            if resp.status_code in (200, 202, 204):
                BulletinHelper.show_info(tr(f"bulletin_repeat_{mode}"))
            elif resp.status_code == 403:
                BulletinHelper.show_info(tr("error_premium_required"))
            elif resp.status_code == 404:
                BulletinHelper.show_info(tr("error_no_active_device"))
            else:
                BulletinHelper.show_info(tr("error_unknown"))
        except Exception as e:
            BulletinHelper.show_info(tr("error_unknown"))

    def _like_track(self, params, track_id):
        try:
            if not track_id or len(track_id) < 5:
                BulletinHelper.show_info(tr("error_missing_like"))
                return
            token = self._get_access_token()
            if not token:
                if self._should_show_error_bulletin("auth_error"):
                    BulletinHelper.show_info(tr("error_auth"))
                return
            resp = requests.put(
                "https://api.spotify.com/v1/me/tracks",
                headers={"Authorization": f"Bearer {token}"},
                json={"ids": [track_id]},
                timeout=5
            )
            if resp.status_code in (200, 202, 204):
                BulletinHelper.show_info(tr("bulletin_liked"))
            elif resp.status_code == 403:
                BulletinHelper.show_info(tr("error_premium_required"))
            elif resp.status_code == 404:
                BulletinHelper.show_info(tr("error_no_active_device"))
            else:
                BulletinHelper.show_info(tr("error_unknown"))
        except Exception as e:
            BulletinHelper.show_info(tr("error_unknown"))

    def _like_current_track(self, params):
        try:
            token = self._get_access_token()
            if not token:
                if self._should_show_error_bulletin("auth_error"):
                    BulletinHelper.show_info(tr("error_auth"))
                return
            resp = requests.get(
                "https://api.spotify.com/v1/me/player/currently-playing",
                headers={"Authorization": f"Bearer {token}"},
                timeout=5
            )
            if resp.status_code != 200 or not resp.content:
                BulletinHelper.show_info(tr("error_no_track_playing"))
                return
            data = resp.json()
            track = data.get("item")
            if not track or not track.get("id"):
                BulletinHelper.show_info(tr("error_no_track_playing"))
                return
            track_id = track["id"]
            # Verifica se já está curtida
            check = requests.get(
                f"https://api.spotify.com/v1/me/tracks/contains?ids={track_id}",
                headers={"Authorization": f"Bearer {token}"},
                timeout=5
            )
            if check.status_code == 200 and check.json()[0]:
                BulletinHelper.show_info(tr("bulletin_already_liked"))
                return
            # Curtir a música
            like = requests.put(
                "https://api.spotify.com/v1/me/tracks",
                headers={"Authorization": f"Bearer {token}"},
                json={"ids": [track_id]},
                timeout=5
            )
            if like.status_code in (200, 202, 204):
                BulletinHelper.show_info(tr("bulletin_liked"))
            elif like.status_code == 403:
                BulletinHelper.show_info(tr("error_premium_required"))
            elif like.status_code == 404:
                BulletinHelper.show_info(tr("error_no_active_device"))
            else:
                BulletinHelper.show_info(tr("error_unknown"))
        except Exception as e:
            BulletinHelper.show_info(tr("error_unknown"))

    def _search_spotify(self, params, query):
        try:
            token = self._get_access_token()
            if not token:
                if self._should_show_error_bulletin("auth_error"):
                    BulletinHelper.show_info(tr("error_auth"))
                return
            resp = requests.get(
                f"https://api.spotify.com/v1/search?q={query}&type=track&limit=5",
                headers={"Authorization": f"Bearer {token}"},
                timeout=5
            )
            if resp.status_code != 200:
                BulletinHelper.show_info(tr("error_unknown"))
                return
            data = resp.json()
            items = data.get("tracks", {}).get("items", [])
            if not items:
                BulletinHelper.show_info(tr("no_track_playing"))
                return
            # Salva o resultado em cache para o usuário poder usar .play N
            account = getattr(params, 'account', None)
            if account is not None:
                self._search_cache[account] = items
            # Monta mensagem markdown
            message = tr("search_results") + "\n\n"
            for i, item in enumerate(items, 1):
                title = item["name"]
                artists = ", ".join([a["name"] for a in item["artists"]])
                track_id = item["id"]
                message += f"{i}. *{title}* — _{artists}_\nID: `{track_id}`\n\n"
            message += tr("use_play_command") if "use_play_command" in TRANSLATIONS else ""
            try:
                from java.util import ArrayList
                parsed = parse_markdown(message)
                params.message = parsed.text
                params.entities = ArrayList()
                for entity in parsed.entities:
                    params.entities.add(entity.to_tlrpc_object())
                run_on_ui_thread(lambda: get_send_messages_helper().sendMessage(params))
            except Exception as e:
                BulletinHelper.show_info(tr("error_generic").format(error=str(e)) if "error_generic" in TRANSLATIONS else f"Markdown error: {str(e)}")
        except Exception as e:
            BulletinHelper.show_info(tr("error_generic").format(error=str(e)) if "error_generic" in TRANSLATIONS else f"Search error: {str(e)}")

    def _get_current_track_soundcloud(self, account):
        # Usa o símbolo global `log` (com wrapper) para respeitar o mute
        log("[Nowfy] _get_current_track_soundcloud chamado, mas não implementado.")
        # TODO: Implementar integração real com SoundCloud
        return None

    def _get_current_track_lastfm(self, account, params, progress_dialog=None, show_bulletins=True):
        try:
            log(f"[DEBUG] _get_current_track_lastfm: current_player setting: {self.get_setting('current_player', 0)}")
            log(f"[Nowfy] Starting LastFM track fetch...")

            player = self._detect_current_player()
            log(f"[Nowfy] Player detected: {player}")

            # --- Segue fluxo normal para LastFM/etg/YouTube ---
            user = self.get_setting("lastfm_username", "")
            api_key = self.get_setting("lastfm_api_key", "")
            youtube_api_key = self.get_setting("youtube_api_key", "")
            if not user or not api_key:
                log(f"[Nowfy] LastFM credentials missing - User: {bool(user)}, API Key: {bool(api_key)}")
                if show_bulletins:
                    BulletinHelper.show_info(tr("error_lastfm_credentials") if "error_lastfm_credentials" in TRANSLATIONS else "LastFM credentials missing.")
                return

            resp = requests.get(
                "https://ws.audioscrobbler.com/2.0/",
                params={
                    "method": "user.getrecenttracks",
                    "user": user,
                    "api_key": api_key,
                    "format": "json",
                    "limit": 1
                },
                timeout=3
            )
            data = resp.json()
            tracks = data.get("recenttracks", {}).get("track", [])
            if not tracks:
                if show_bulletins:
                    if player in ["exteraGram", "AyuGram", "Telegram"]:
                        BulletinHelper.show_info(tr("no_track_playing_generic"))
                    else:
                        self._show_no_track_playing_bulletin()
                return

            track = tracks[0]
            title = track["name"]
            artist = track["artist"]["#text"]
            album = track.get("album", {}).get("#text", "")
            image_url = track.get("image", [{}])[-1].get("#text", "")
            theme_style = self.get_setting("lastfm_theme_style", 0)
            youtube_url = None
            etg_cover_image = None

            is_playing = False
            # Last.fm nem sempre inclui @attr.nowplaying - assumir que está tocando se não tiver o atributo
            if "@attr" in track:
                is_playing = track["@attr"].get("nowplaying") == "true"
            else:
                # Se não tem o atributo @attr, assumir que a música mais recente está tocando
                is_playing = True

            if player == "SoundCloud":
                soundcloud_url = None
                if "url" in track:
                    soundcloud_url = track["url"]
                    if "soundcloud.com" not in soundcloud_url:
                        search_query = f"{title} {artist}"
                        soundcloud_url = f"https://soundcloud.com/search?q={quote(search_query)}"
                else:
                    search_query = f"{title} {artist}"
                    soundcloud_url = f"https://soundcloud.com/search?q={quote(search_query)}"
                if "external_urls" not in track or not isinstance(track["external_urls"], dict):
                    track["external_urls"] = {}
                track["external_urls"]["soundcloud"] = soundcloud_url

                youtube_url = soundcloud_url

            # Detectar música do Telegram se for o player selecionado
            telegram_cover_image = None
            if player in ["exteraGram", "AyuGram", "Telegram"]:
                log(f"[Nowfy] Processing {player} player...")
                from org.telegram.messenger import MediaController
                media_controller = MediaController.getInstance()
                playing_song = media_controller.getPlayingMessageObject()
                
                log(f"[Nowfy] Playing song object: {playing_song}")
                
                telegram_track = self.get_current_track_etg(account)
                log(f"[Nowfy] Telegram track data: {telegram_track}")
                
                if telegram_track:
                    title = telegram_track["title"]
                    artist = telegram_track["artist"]
                    log(f"[Nowfy] Using {player} track - Title: '{title}', Artist: '{artist}'")
                    
                    # Buscar capa do Telegram
                    telegram_cover_image = self.get_etg_cover(playing_song)
                    log(f"[Nowfy] {player} cover search result: {'Found' if telegram_cover_image else 'Not found'}")
                else:
                    log(f"[Nowfy] No {player} track found")
                    if show_bulletins:
                        BulletinHelper.show_info(tr("no_track_playing_generic"))
                    return

            elif player in ("YouTube", "YouTube Music") and youtube_api_key:
                youtube_url = self._search_youtube_url(title, artist, youtube_api_key)

            log(f"[Nowfy] Final data - Title: '{title}', Artist: '{artist}', Player: '{player}', Telegram cover: {'Available' if telegram_cover_image else 'None'}")

            if self.get_setting("enable_autobio", False):
                autobio_text = self.get_setting("autobio_text", "Now Playing: {track} by {artist}")
                bio = autobio_text.format(track=title, artist=artist)
                run_on_ui_thread(lambda: self._update_bio(bio, show_bulletin=False))
                if self.get_setting("show_bio_notification", True):
                    if self.get_setting("enable_auto_bio_update", True):
                        BulletinHelper.show_info(tr("bio_updated_short"))
                    else:
                        BulletinHelper.show_info(tr("bio_notification_disabled"))

            # Usar o tema selecionado pelo usuário
            theme = self.get_setting("theme_selector", 0)
            random_theme = self.get_setting("random_theme_mode", False)
            
            if random_theme:
                external_themes = self._get_external_themes()
                # Calcular índices dos temas
                vinni_index = 3 + len(external_themes)
                customfm_index = vinni_index + 1
                minimal_index = customfm_index + 1
                
                theme_options = [0, 1, 2]  # Temas Apple
                if external_themes:
                    theme_options.extend(range(3, 3 + len(external_themes)))  # Temas externos
                theme_options.extend([vinni_index, customfm_index, minimal_index])  # Vinni, CustomFM, Minimal
                theme = random.choice(theme_options)
            
            # Buscar capa do SoundCloud se necessário (antes de criar track_obj)
            if player == "SoundCloud":
                soundcloud_cover_url = self.get_soundcloud_cover(title, artist)
                if soundcloud_cover_url:
                    image_url = soundcloud_cover_url
                    log(f"[Nowfy] Using SoundCloud cover: {soundcloud_cover_url}")

            # Buscar link do Spotify se necessário
            spotify_url = None
            if player != "SoundCloud":
                try:
                    spotify_url = self._search_spotify_url(title, artist)
                except Exception as e:
                    log(f"[Nowfy] Error searching Spotify URL: {e}")
            
            # Track para compatibilidade (criado após busca de capa do SoundCloud)
            track_obj = {
                "name": title,
                "artists": [{"name": artist}],
                "album": {
                    "name": album,
                    "images": [{"url": image_url, "width": 640, "height": 640}] if image_url else []
                },
                "external_urls": {
                    "spotify": youtube_url if player == "SoundCloud" else spotify_url
                },
                "duration_ms": 0
            }
            # Sistema de geração de cards baseado no tema selecionado
            if theme >= 5:  # Tema externo
                external_themes = self._get_external_themes()
                if external_themes:
                    external_theme_index = theme - 5
                    external_theme_ids = list(external_themes.keys())
                    if external_theme_index < len(external_theme_ids):
                        theme_id = external_theme_ids[external_theme_index]
                        self._generate_external_theme_card(track_obj, params, 0, theme_id, 
                                                          external_themes[theme_id], 
                                                          force_spotify=False, 
                                                          telegram_cover_image=telegram_cover_image)
                        return True
            
            # Temas internos
            if theme == 4:  # CustomFM
                self._get_current_track_lastfm_customfm(title, artist, album, image_url, params, progress_dialog, player, youtube_url, telegram_cover_image)
            elif theme == 3:  # Default (LastFM-StatsFM)
                if theme_style == 0:
                    self._get_current_track_lastfm_default(title, artist, album, image_url, params, progress_dialog, player, youtube_url, telegram_cover_image)
                else:
                    self._get_current_track_lastfm_customfm(title, artist, album, image_url, params, progress_dialog, player, youtube_url, telegram_cover_image)
            elif theme in [0, 1, 2]:  # Temas Apple para Last.FM
                # Usar o sistema de geração de cards padrão com temas Apple para todos os players
                self._generate_card(track_obj, params, theme, force_spotify=True, etg_cover_image=telegram_cover_image, is_fm_command=True)
            else:
                # Calcular índices dos temas
                external_themes = self._get_external_themes()
                vinni_index = 3 + len(external_themes)
                customfm_index = vinni_index + 1
                minimal_index = customfm_index + 1
                
                if theme == minimal_index:  # Tema Minimal
                    self._generate_card(track_obj, params, theme, force_spotify=True, etg_cover_image=telegram_cover_image, is_fm_command=True)
                else:  # Usar o sistema de geração de cards padrão
                    self._generate_card(track_obj, params, 0, force_spotify=False, etg_cover_image=telegram_cover_image, is_fm_command=False)
            return True

        except Exception as e:
            if show_bulletins:
                BulletinHelper.show_info(tr("error_lastfm").format(error=str(e)) if "error_lastfm" in TRANSLATIONS else f"LastFM error: {str(e)}")

    def _search_youtube_url(self, title, artist, api_key):
        try:
            query = f"{title} {artist}"
            resp = requests.get(
                "https://www.googleapis.com/youtube/v3/search",
                params={
                    "part": "snippet",
                    "q": query,
                    "key": api_key,
                    "type": "video",
                    "maxResults": 1
                },
                timeout=5
            )
            data = resp.json()
            items = data.get("items", [])
            if items:
                video_id = items[0]["id"]["videoId"]
                return f"https://youtu.be/{video_id}"
        except Exception:
            pass
        return None

    # --- CUSTOMFM LASTFM-STATSFM THEME ---
    def _generate_gradient_background(self, card_width, card_height, album_cover=None):
        """Gera background com gradiente dinâmico baseado nas configurações do Visual Avançado"""
        try:
            # Verificar se gradientes estão habilitados
            if not self.get_setting("visual_avancado_gradiente_enable", False):
                return None
                
            # Obter configurações de gradiente
            gradient_mode = self.get_setting("visual_avancado_gradiente_modo", 0)  # 0=Automático, 1=Personalizado
            gradient_style = self.get_setting("visual_avancado_gradiente_style", 0)  # 0=Linear, 1=Radial, 2=Diagonal
            gradient_direction = self.get_setting("visual_avancado_gradiente_direction", 0)  # 0=Cima para Baixo, 1=Esquerda para Direita, 2=Diagonal
            gradient_intensity = self.get_setting("visual_avancado_gradiente_intensity", 1)  # 0=Suave, 1=Médio, 2=Intenso
            gradient_extraction = self.get_setting("visual_avancado_color_extraction", 0)  # 0=Dominante, 1=Complementares, 2=Análogas
            
            # Definir cores do gradiente
            if gradient_mode == 0 and album_cover:  # Automático - extrair da capa
                colors = self._extract_colors_from_cover(album_cover, gradient_extraction)
                log(f"[NowFy] Usando cores extraídas da capa: {colors}")
            else:  # Personalizado
                color1 = self.get_setting("visual_avancado_gradiente_cor1", "#FF6B6B")
                color2 = self.get_setting("visual_avancado_gradiente_cor2", "#4ECDC4")
                colors = [color1, color2]
                log(f"[NowFy] Usando cores personalizadas: {color1} -> {color2}")
            
            # Criar gradiente
            gradient_img = Image.new("RGBA", (card_width, card_height))
            
            if gradient_style == 0:  # Linear
                gradient_img = self._create_linear_gradient(card_width, card_height, colors, gradient_direction, gradient_intensity)
            elif gradient_style == 1:  # Radial
                gradient_img = self._create_radial_gradient(card_width, card_height, colors, gradient_intensity)
            elif gradient_style == 2:  # Diagonal
                gradient_img = self._create_diagonal_gradient(card_width, card_height, colors, gradient_direction, gradient_intensity)
            
            return gradient_img
            
        except Exception as e:
            log(f"[NowFy] Erro ao gerar gradiente: {e}")
            return None
    
    def _extract_colors_from_cover(self, album_cover, extraction_mode):
        """Extrai cores da capa do álbum para gradientes automáticos"""
        try:
            from collections import Counter
            import colorsys
            
            # Redimensionar para análise mais rápida
            small_cover = album_cover.resize((50, 50), Image.LANCZOS)
            pixels = list(small_cover.getdata())
            
            # Filtrar pixels muito escuros ou muito claros
            filtered_pixels = []
            for pixel in pixels:
                if len(pixel) >= 3:
                    r, g, b = pixel[:3]
                    brightness = (r + g + b) / 3
                    if 30 < brightness < 225:  # Evitar preto/branco puros
                        filtered_pixels.append((r, g, b))
            
            if not filtered_pixels:
                return ["#FF6B6B", "#4ECDC4"]  # Fallback
            
            # Encontrar cor dominante
            color_counts = Counter(filtered_pixels)
            dominant_color = color_counts.most_common(1)[0][0]
            
            if extraction_mode == 0:  # Dominante + variação
                r, g, b = dominant_color
                # Criar segunda cor com variação de matiz
                h, s, v = colorsys.rgb_to_hsv(r/255, g/255, b/255)
                h2 = (h + 0.3) % 1.0  # Rotacionar matiz
                r2, g2, b2 = colorsys.hsv_to_rgb(h2, s, v)
                color2 = (int(r2*255), int(g2*255), int(b2*255))
                
            elif extraction_mode == 1:  # Complementares
                r, g, b = dominant_color
                h, s, v = colorsys.rgb_to_hsv(r/255, g/255, b/255)
                h2 = (h + 0.5) % 1.0  # Cor complementar
                r2, g2, b2 = colorsys.hsv_to_rgb(h2, s, v)
                color2 = (int(r2*255), int(g2*255), int(b2*255))
                
            else:  # Análogas
                r, g, b = dominant_color
                h, s, v = colorsys.rgb_to_hsv(r/255, g/255, b/255)
                h2 = (h + 0.15) % 1.0  # Cor análoga
                r2, g2, b2 = colorsys.hsv_to_rgb(h2, s, v)
                color2 = (int(r2*255), int(g2*255), int(b2*255))
            
            # Converter para hex
            color1_hex = f"#{r:02x}{g:02x}{b:02x}"
            color2_hex = f"#{color2[0]:02x}{color2[1]:02x}{color2[2]:02x}"
            
            return [color1_hex, color2_hex]
            
        except Exception as e:
            log(f"[NowFy] Erro ao extrair cores: {e}")
            return ["#FF6B6B", "#4ECDC4"]
    
    def _create_linear_gradient(self, width, height, colors, direction, intensity):
        """Cria gradiente linear"""
        gradient = Image.new("RGBA", (width, height))
        
        # Converter cores hex para RGB
        def hex_to_rgb(hex_color):
            hex_color = hex_color.lstrip('#')
            return tuple(int(hex_color[i:i+2], 16) for i in (0, 2, 4))
        
        color1_rgb = hex_to_rgb(colors[0])
        color2_rgb = hex_to_rgb(colors[1])
        
        # Definir intensidade (alpha)
        alpha_values = [128, 180, 255]  # Suave, Médio, Intenso
        alpha = alpha_values[intensity] if intensity < len(alpha_values) else 180
        
        for i in range(width if direction == 1 else height):
            if direction == 0:  # Cima para Baixo
                ratio = i / height
                for x in range(width):
                    r = int(color1_rgb[0] * (1 - ratio) + color2_rgb[0] * ratio)
                    g = int(color1_rgb[1] * (1 - ratio) + color2_rgb[1] * ratio)
                    b = int(color1_rgb[2] * (1 - ratio) + color2_rgb[2] * ratio)
                    gradient.putpixel((x, i), (r, g, b, alpha))
            else:  # Esquerda para Direita
                ratio = i / width
                for y in range(height):
                    r = int(color1_rgb[0] * (1 - ratio) + color2_rgb[0] * ratio)
                    g = int(color1_rgb[1] * (1 - ratio) + color2_rgb[1] * ratio)
                    b = int(color1_rgb[2] * (1 - ratio) + color2_rgb[2] * ratio)
                    gradient.putpixel((i, y), (r, g, b, alpha))
        
        return gradient
    
    def _create_radial_gradient(self, width, height, colors, intensity):
        """Cria gradiente radial"""
        gradient = Image.new("RGBA", (width, height))
        
        def hex_to_rgb(hex_color):
            hex_color = hex_color.lstrip('#')
            return tuple(int(hex_color[i:i+2], 16) for i in (0, 2, 4))
        
        color1_rgb = hex_to_rgb(colors[0])
        color2_rgb = hex_to_rgb(colors[1])
        
        alpha_values = [128, 180, 255]
        alpha = alpha_values[intensity] if intensity < len(alpha_values) else 180
        
        center_x, center_y = width // 2, height // 2
        max_distance = ((width/2)**2 + (height/2)**2)**0.5
        
        for x in range(width):
            for y in range(height):
                distance = ((x - center_x)**2 + (y - center_y)**2)**0.5
                ratio = min(distance / max_distance, 1.0)
                
                r = int(color1_rgb[0] * (1 - ratio) + color2_rgb[0] * ratio)
                g = int(color1_rgb[1] * (1 - ratio) + color2_rgb[1] * ratio)
                b = int(color1_rgb[2] * (1 - ratio) + color2_rgb[2] * ratio)
                gradient.putpixel((x, y), (r, g, b, alpha))
        
        return gradient
    
    def _create_diagonal_gradient(self, width, height, colors, direction, intensity):
        """Cria gradiente diagonal"""
        gradient = Image.new("RGBA", (width, height))
        
        def hex_to_rgb(hex_color):
            hex_color = hex_color.lstrip('#')
            return tuple(int(hex_color[i:i+2], 16) for i in (0, 2, 4))
        
        color1_rgb = hex_to_rgb(colors[0])
        color2_rgb = hex_to_rgb(colors[1])
        
        alpha_values = [128, 180, 255]
        alpha = alpha_values[intensity] if intensity < len(alpha_values) else 180
        
        max_distance = (width + height)
        
        for x in range(width):
            for y in range(height):
                if direction == 2:  # Diagonal ↗
                    distance = x + (height - y)
                else:  # Diagonal ↘ (padrão)
                    distance = x + y
                
                ratio = min(distance / max_distance, 1.0)
                
                r = int(color1_rgb[0] * (1 - ratio) + color2_rgb[0] * ratio)
                g = int(color1_rgb[1] * (1 - ratio) + color2_rgb[1] * ratio)
                b = int(color1_rgb[2] * (1 - ratio) + color2_rgb[2] * ratio)
                gradient.putpixel((x, y), (r, g, b, alpha))
        
        return gradient

    def _get_current_track_lastfm_customfm(
        self, title, artist, album, image_url, params,
        progress_dialog=None, player=None, youtube_url=None,
        telegram_cover_image=None, font_name=None, font_size=None
    ):
        try:
            # Importar todas as dependências da PIL no início
            from PIL import Image, ImageDraw, ImageFont, ImageFilter, ImageOps
            from io import BytesIO
            import requests
            
            log(f"[Nowfy] CustomFM theme - Starting with title: '{title}', artist: '{artist}', player: '{player}', telegram_cover: {telegram_cover_image is not None}")
            if progress_dialog:
                run_on_ui_thread(lambda: progress_dialog.set_progress(50))

            player_name = self._detect_current_player()
            send_helper = get_send_messages_helper()
            base_dir = ApplicationLoader.getFilesDirFixed()
            temp_dir = File(base_dir, "nowFy")
            if not temp_dir.exists():
                temp_dir.mkdirs()
            # Verificar se alta resolução está ativada
            use_high_res = self.get_setting("customfm_high_resolution", False)
            if use_high_res:
                card_width, card_height = 1920, 1080
            else:
                card_width, card_height = 1012, 512
            
            # Cache key para otimização de performance
            cache_key = f"customfm_{title}_{artist}_{use_high_res}_{self.get_setting('lastfm_customfm_background_color', '#d2d2d2')}_{self.get_setting('lastfm_customfm_text_color', '#000000')}_{self.get_setting('lastfm_customfm_cover_position', 0)}"
            cache_key = hashlib.md5(cache_key.encode()).hexdigest()
            
            # Verificar cache primeiro para melhor performance
            cached_path = self._get_cached_customfm_image(cache_key, temp_dir)
            if cached_path and File(cached_path).exists():
                log(f"[Nowfy] CustomFM cache hit - usando imagem em cache: {cached_path}")
                return cached_path
            
            filename = f"customfm_{cache_key}.png"
            temp_path = File(temp_dir, filename).getAbsolutePath()
                
            use_bg = self.get_setting("lastfm_customfm_use_background", True)
            bg_color = self.get_setting("lastfm_customfm_background_color", "#d2d2d2")
            text_color = self.get_setting("lastfm_customfm_text_color", "#000000")
            # Ajustar tamanho da mini capa baseado na resolução
            if use_high_res:
                mini_cover_size = 570  # Proporcionalmente maior para 1920x1080
            else:
                mini_cover_size = 300
            
            # Verificar a posição da mini capa (esquerda ou direita)
            cover_position = self.get_setting("lastfm_customfm_cover_position", 0)  # 0 = Esquerda, 1 = Direita
            
            # Definir padding com base na posição da capa e resolução
            base_padding = 95 if use_high_res else 50
            text_spacing = 75 if use_high_res else 40
            
            if cover_position == 0:  # Esquerda (padrão)
                padding_left = base_padding
                text_start_x = padding_left + mini_cover_size + text_spacing  # Texto à direita da capa
            else:  # Direita
                padding_left = card_width - mini_cover_size - base_padding  # Capa à direita
                text_start_x = base_padding  # Texto à esquerda
                
            padding_top = (card_height - mini_cover_size) // 2
            # --- CAPA (OTIMIZADA) ---
            album_cover = None
            cover_cache_key = f"cover_{title}_{artist}_{mini_cover_size}"
            
            # Tentar cache primeiro para melhor performance
            try:
                from PIL import Image, ImageOps
                if telegram_cover_image and player_name in ["exteraGram", "AyuGram", "Telegram"]:
                    album_cover = telegram_cover_image.resize((mini_cover_size, mini_cover_size), Image.LANCZOS)
                elif player_name in ["YouTube", "YouTube Music", "Yandex Music"]:
                    # Usar cache para YouTube covers
                    cached_image = self._get_cached_image_enhanced(
                        self._get_youtube_cover(title, artist), 
                        cache_key=cover_cache_key,
                        force_size=(mini_cover_size, mini_cover_size)
                    )
                    if cached_image:
                        # Converter bytes para PIL Image se necessário
                        if isinstance(cached_image, bytes):
                            try:
                                album_cover = Image.open(BytesIO(cached_image)).convert("RGBA")
                                # Usar ImageOps.fit para manter proporção sem distorção
                                from PIL import ImageOps
                                album_cover = ImageOps.fit(album_cover, (mini_cover_size, mini_cover_size), method=Image.LANCZOS, centering=(0.5, 0.5))
                                album_cover = album_cover.convert("RGBA")
                            except Exception as e:
                                log(f"[Nowfy] Error converting cached bytes to PIL Image: {e}")
                                album_cover = self._get_icondefault_cached(mini_cover_size)
                        else:
                            # Mesmo quando o cache retorna uma Image, garantir corte consistente
                            try:
                                album_cover = ImageOps.fit(cached_image, (mini_cover_size, mini_cover_size), method=Image.LANCZOS, centering=(0.5, 0.5))
                            except Exception:
                                album_cover = cached_image
                    else:
                        album_cover = self._get_icondefault_cached(mini_cover_size)
                elif player_name == "SoundCloud":
                    # Processamento específico para SoundCloud com fallback para YouTube
                    try:
                        # Primeiro tentar obter capa diretamente do SoundCloud
                        soundcloud_cover_url = self.get_soundcloud_cover(title, artist)
                        cover_url = None
                        
                        if soundcloud_cover_url:
                            cover_url = soundcloud_cover_url
                            log(f"[Nowfy] CustomFM: Using SoundCloud cover: {soundcloud_cover_url}")
                        else:
                            # Fallback para YouTube se SoundCloud não retornar capa
                            youtube_cover_url = self._get_youtube_cover(title, artist)
                            if youtube_cover_url and youtube_cover_url != "https://i.postimg.cc/4yjVLFTV/icondefault.png":
                                cover_url = youtube_cover_url
                                log(f"[Nowfy] CustomFM: SoundCloud fallback to YouTube cover: {youtube_cover_url}")
                        
                        if cover_url:
                            log(f"[Nowfy] CustomFM: Processing SoundCloud cover URL: {cover_url}")
                            
                            # Tentar baixar a imagem diretamente primeiro
                            try:
                                import requests
                                from PIL import Image, ImageOps
                                from io import BytesIO
                                
                                response = requests.get(cover_url, timeout=10)
                                if response.status_code == 200:
                                    album_cover = Image.open(BytesIO(response.content)).convert("RGBA")
                                    album_cover = ImageOps.fit(album_cover, (mini_cover_size, mini_cover_size), method=Image.LANCZOS, centering=(0.5, 0.5))
                                    # Upgrade de qualidade: se a capa for pequena, substituir por YouTube
                                    try:
                                        if album_cover.width < mini_cover_size or album_cover.height < mini_cover_size:
                                            yt_url_up = self._get_youtube_cover(title, artist)
                                            if yt_url_up == "https://i.postimg.cc/4yjVLFTV/icondefault.png":
                                                yt_url_up = self._get_youtube_thumbnail_forced(title, artist)
                                            yt_cached = self._get_cached_image_enhanced(yt_url_up, cache_key=cover_cache_key, force_size=(mini_cover_size, mini_cover_size))
                                            if yt_cached:
                                                if isinstance(yt_cached, bytes):
                                                    album_cover = Image.open(BytesIO(yt_cached)).convert("RGBA")
                                                else:
                                                    album_cover = yt_cached
                                                album_cover = ImageOps.fit(album_cover, (mini_cover_size, mini_cover_size), method=Image.LANCZOS, centering=(0.5, 0.5))
                                    except Exception as _e:
                                        log(f"[Nowfy] CustomFM: Upgrade YouTube falhou: {_e}")
                                    log(f"[Nowfy] CustomFM: SoundCloud cover downloaded and processed successfully")
                                else:
                                    log(f"[Nowfy] CustomFM: Failed to download SoundCloud cover, status: {response.status_code}")
                                    album_cover = self._get_icondefault_cached(mini_cover_size)
                            except Exception as e:
                                log(f"[Nowfy] CustomFM: Error downloading SoundCloud cover directly: {e}")
                                
                                # Fallback para o sistema de cache
                                try:
                                    cached_image = self._get_cached_image_enhanced(
                                        cover_url, 
                                        cache_key=cover_cache_key,
                                        force_size=(mini_cover_size, mini_cover_size)
                                    )
                                    if cached_image:
                                        if isinstance(cached_image, bytes):
                                            try:
                                                album_cover = Image.open(BytesIO(cached_image)).convert("RGBA")
                                                album_cover = ImageOps.fit(album_cover, (mini_cover_size, mini_cover_size), method=Image.LANCZOS, centering=(0.5, 0.5))
                                                # Upgrade de qualidade: se a capa for pequena, substituir por YouTube
                                                try:
                                                    if album_cover.width < mini_cover_size or album_cover.height < mini_cover_size:
                                                        yt_url_up = self._get_youtube_cover(title, artist)
                                                        if yt_url_up == "https://i.postimg.cc/4yjVLFTV/icondefault.png":
                                                            yt_url_up = self._get_youtube_thumbnail_forced(title, artist)
                                                        yt_cached = self._get_cached_image_enhanced(yt_url_up, cache_key=cover_cache_key, force_size=(mini_cover_size, mini_cover_size))
                                                        if yt_cached:
                                                            if isinstance(yt_cached, bytes):
                                                                album_cover = Image.open(BytesIO(yt_cached)).convert("RGBA")
                                                            else:
                                                                album_cover = yt_cached
                                                            album_cover = ImageOps.fit(album_cover, (mini_cover_size, mini_cover_size), method=Image.LANCZOS, centering=(0.5, 0.5))
                                                except Exception as _e:
                                                    log(f"[Nowfy] CustomFM: Upgrade YouTube falhou: {_e}")
                                                log(f"[Nowfy] CustomFM: SoundCloud cover processed from cache")
                                            except Exception as cache_e:
                                                log(f"[Nowfy] Error processing cached SoundCloud cover: {cache_e}")
                                                album_cover = self._get_icondefault_cached(mini_cover_size)
                                        else:
                                            # Garantir corte consistente também quando vier como Image
                                            try:
                                                album_cover = ImageOps.fit(cached_image, (mini_cover_size, mini_cover_size), method=Image.LANCZOS, centering=(0.5, 0.5))
                                            except Exception:
                                                album_cover = cached_image
                                    else:
                                        log(f"[Nowfy] CustomFM: No cached image returned for SoundCloud")
                                        album_cover = self._get_icondefault_cached(mini_cover_size)
                                except Exception as cache_error:
                                    log(f"[Nowfy] CustomFM: Cache system error for SoundCloud: {cache_error}")
                                    album_cover = self._get_icondefault_cached(mini_cover_size)
                        else:
                            log(f"[Nowfy] CustomFM: No cover URL found for SoundCloud")
                            album_cover = self._get_icondefault_cached(mini_cover_size)
                    except Exception as e:
                        log(f"[Nowfy] CustomFM: Error loading SoundCloud cover: {e}")
                        album_cover = self._get_icondefault_cached(mini_cover_size)
                elif player_name == "FM":
                    # FM deve se comportar como YouTube Music: priorizar thumbnail do YouTube e aplicar crop
                    try:
                        from PIL import ImageOps, Image
                        cover_url = self._get_youtube_cover(title, artist)
                        cached_image = self._get_cached_image_enhanced(
                            cover_url,
                            cache_key=cover_cache_key,
                            force_size=(mini_cover_size, mini_cover_size)
                        )
                        if cached_image:
                            if isinstance(cached_image, bytes):
                                try:
                                    album_cover = Image.open(BytesIO(cached_image)).convert("RGBA")
                                    album_cover = ImageOps.fit(album_cover, (mini_cover_size, mini_cover_size), method=Image.LANCZOS, centering=(0.5, 0.5))
                                    album_cover = album_cover.convert("RGBA")
                                except Exception as e:
                                    log(f"[Nowfy] FM: Error converting cached bytes to PIL Image: {e}")
                                    album_cover = self._get_icondefault_cached(mini_cover_size)
                            else:
                                # Aplicar ImageOps.fit também quando já for Image
                                try:
                                    album_cover = ImageOps.fit(cached_image, (mini_cover_size, mini_cover_size), method=Image.LANCZOS, centering=(0.5, 0.5))
                                except Exception:
                                    album_cover = cached_image
                        else:
                            # Fallback para ícone padrão se a capa do YouTube não estiver disponível
                            album_cover = self._get_icondefault_cached(mini_cover_size)
                    except Exception as e:
                        log(f"[Nowfy] FM: Error loading YouTube cover: {e}")
                        album_cover = self._get_icondefault_cached(mini_cover_size)
                else:
                    # Para Spotify e outros players, usar sistema otimizado de artwork
                    try:
                        from PIL import Image, ImageOps
                        album_cover = self._search_music_artwork(artist, title)
                        if album_cover:
                            # Aplicar crop consistente mantendo proporção, igual ao YouTube
                            album_cover = ImageOps.fit(album_cover, (mini_cover_size, mini_cover_size), method=Image.LANCZOS, centering=(0.5, 0.5))
                            log(f"[Nowfy] CustomFM: Using artwork from priority system")
                        else:
                            album_cover = self._get_icondefault_cached(mini_cover_size)
                    except Exception as e:
                        log(f"[Nowfy] CustomFM: Error using priority artwork system: {e}")
                        album_cover = self._get_icondefault_cached(mini_cover_size)
            except Exception as e:
                log(f"[Nowfy] CustomFM: Error loading cover: {e}")
                album_cover = self._get_icondefault_cached(mini_cover_size)
            
            # Fallback: tentar image_url do Last.fm se ainda não temos capa
            if not album_cover and image_url:
                try:
                    resp = requests.get(image_url, timeout=10)
                    if resp.status_code == 200:
                        album_cover = Image.open(BytesIO(resp.content)).convert("RGBA")
                        album_cover = ImageOps.fit(album_cover, (mini_cover_size, mini_cover_size), method=Image.LANCZOS, centering=(0.5, 0.5))
                        # Upgrade de qualidade: se a imagem do Last.fm for pequena, substituir por YouTube
                        try:
                            if album_cover.width < mini_cover_size or album_cover.height < mini_cover_size:
                                yt_url_up = self._get_youtube_cover(title, artist)
                                if yt_url_up == "https://i.postimg.cc/4yjVLFTV/icondefault.png":
                                    yt_url_up = self._get_youtube_thumbnail_forced(title, artist)
                                yt_cached = self._get_cached_image_enhanced(yt_url_up, cache_key=cover_cache_key, force_size=(mini_cover_size, mini_cover_size))
                                if yt_cached:
                                    if isinstance(yt_cached, bytes):
                                        album_cover = Image.open(BytesIO(yt_cached)).convert("RGBA")
                                    else:
                                        album_cover = yt_cached
                                    album_cover = ImageOps.fit(album_cover, (mini_cover_size, mini_cover_size), method=Image.LANCZOS, centering=(0.5, 0.5))
                        except Exception as _e:
                            log(f"[Nowfy] CustomFM: YouTube upgrade on Last.fm fallback failed: {_e}")
                except Exception as e:
                    log(f"[Nowfy] CustomFM: Last.fm image_url fallback failed: {e}")
            
            # Garantir que sempre temos uma capa
            if not album_cover:
                album_cover = self._get_icondefault_cached(mini_cover_size)
                log(f"[Nowfy] CustomFM: Using default icon as final fallback")
            # --- BLUR DE FUNDO (OTIMIZADO) ---
            if use_bg:
                from PIL import Image
                bg_cover = album_cover.copy()
                # Aumentar ligeiramente o fator de escala para evitar tarjas pretas
                bg_ratio = max(card_width / bg_cover.width, card_height / bg_cover.height) * 1.05
                new_size = (int(bg_cover.width * bg_ratio), int(bg_cover.height * bg_ratio))
                bg_cover = bg_cover.resize(new_size, Image.LANCZOS)              
                # Verificar se o blur está ativado
                use_blur = self.get_setting("lastfm_customfm_blur", True)
                if use_blur:
                    # Otimizar blur para alta resolução - usar blur menor em imagem menor e depois redimensionar
                    if use_high_res:
                        temp_bg = bg_cover.resize((new_size[0]//2, new_size[1]//2), Image.LANCZOS)
                        blur_bg = temp_bg.filter(ImageFilter.GaussianBlur(15))
                        blur_bg = blur_bg.resize(new_size, Image.LANCZOS)
                    else:
                        blur_bg = bg_cover.filter(ImageFilter.GaussianBlur(30))
                else:
                    blur_bg = bg_cover
                    
                from PIL import Image
                background = Image.new("RGBA", (card_width, card_height))
                # Centralizar melhor a imagem de fundo
                x_offset = -(new_size[0] - card_width) // 2
                y_offset = -(new_size[1] - card_height) // 2
                background.paste(blur_bg, (x_offset, y_offset))
                
                # Verificar se o escurecimento está ativado
                use_darken = self.get_setting("lastfm_customfm_darken_background", False)
                if use_darken:
                    from PIL import Image
                    overlay = Image.new("RGBA", (card_width, card_height), (0, 0, 0, 150))
                    background = Image.alpha_composite(background.convert("RGBA"), overlay)
                
                # --- GRADIENTES DINÂMICOS (Visual Avançado) ---
                gradient_bg = self._generate_gradient_background(card_width, card_height, album_cover)
                if gradient_bg:
                    from PIL import Image
                    background = Image.alpha_composite(background.convert("RGBA"), gradient_bg)
                    log(f"[NowFy] Gradiente dinâmico aplicado ao background com capa")
                
                # --- DYNAMIC SKINS ---
                dynamic_skin_selection = self.get_setting("dynamic_skins_selector", 0)
                dynamic_skin_url = None
                
                if dynamic_skin_selection == 1:  # Aleatório
                    import random
                    random_choice = random.choice([2, 3, 4, 5, 6, 7, 8, 9, 10])  # Sortear entre todos os skins disponíveis
                    dynamic_skin_selection = random_choice
                
                if dynamic_skin_selection == 2:  # Midnight Pulse
                    dynamic_skin_url = "https://i.postimg.cc/8CX52pBX/customov.png"
                elif dynamic_skin_selection == 3:  # Sunset Rhythm
                    dynamic_skin_url = "https://i.postimg.cc/W41zYFrJ/customov2.png"
                elif dynamic_skin_selection == 4:  # Spcy
                    dynamic_skin_url = "https://i.postimg.cc/MK6DDtH6/Spcy.png"
                elif dynamic_skin_selection == 5:  # Purpl
                    dynamic_skin_url = "https://i.postimg.cc/ZYFHpXTs/Purpl.png"
                elif dynamic_skin_selection == 6:  # Ardente
                    dynamic_skin_url = "https://i.postimg.cc/zf5tjsR7/Ardente.png"
                elif dynamic_skin_selection == 7:  # Manifest
                    dynamic_skin_url = "https://i.postimg.cc/FKZPnTy4/Manifest.png"
                elif dynamic_skin_selection == 8:  # Moment
                    dynamic_skin_url = "https://i.postimg.cc/65k172WD/Moment.png"
                elif dynamic_skin_selection == 9:  # Moment Redd
                    dynamic_skin_url = "https://i.postimg.cc/Sxc1cSjj/Redd.png"
                elif dynamic_skin_selection == 10:  # Moment Variant
                    dynamic_skin_url = "https://i.postimg.cc/k4gjrWst/Variant.png"
                
                # Aplicar Dynamic Skin se selecionado
                if dynamic_skin_url:
                    try:
                        # Usar sistema de cache avançado
                        cache_key = f"dynamic_skin_{dynamic_skin_selection}"
                        cached_image_data = self._get_cached_image_enhanced(dynamic_skin_url, cache_key)
                        
                        if cached_image_data:
                            from PIL import Image
                            dynamic_skin_image = Image.open(BytesIO(cached_image_data)).convert("RGBA")
                            dynamic_skin_image = dynamic_skin_image.resize((card_width, card_height), Image.LANCZOS)
                            log(f"[NowFy] Dynamic Skin carregado do cache: {cache_key}")
                        else:
                            dynamic_skin_image = None
                            log(f"[NowFy] Erro ao carregar Dynamic Skin: {cache_key}")
                        
                        # Aplicar efeitos apenas se a imagem foi carregada com sucesso
                        if dynamic_skin_image:
                            # Aplicar blur no Dynamic Skin se ativado
                            if use_blur:
                                dynamic_skin_image = dynamic_skin_image.filter(ImageFilter.GaussianBlur(15))
                            
                            # Aplicar escurecimento no Dynamic Skin se ativado
                            if use_darken:
                                from PIL import Image
                                overlay_dark = Image.new("RGBA", (card_width, card_height), (0, 0, 0, 100))
                                dynamic_skin_image = Image.alpha_composite(dynamic_skin_image, overlay_dark)
                            
                            from PIL import Image
                            background = Image.alpha_composite(background.convert("RGBA"), dynamic_skin_image)
                    except Exception as e:
                        log(f"Erro ao carregar Dynamic Skin: {e}")
                
                # --- CUSTOM OVERLAY COMO BACKGROUND (fallback se Dynamic Skin não estiver ativo) ---
                if not dynamic_skin_url:
                    use_custom_overlay = self.get_setting("lastfm_customfm_use_overlay", False)
                    custom_overlay_url = self.get_setting("lastfm_customfm_overlay_url", "")
                    statsfm_username = self.get_setting("statsfm_username", "")
                    # Aplicar overlay apenas quando a origem for Last.fm (evitar StatsFM)
                    apply_overlay = use_custom_overlay and custom_overlay_url and (player_name == "FM") and not statsfm_username
                    if apply_overlay:
                        try:
                            overlay_resp = requests.get(custom_overlay_url, stream=True, timeout=10)
                            overlay_resp.raise_for_status()
                            from PIL import Image
                            custom_overlay_image = Image.open(BytesIO(overlay_resp.content)).convert("RGBA")
                            custom_overlay_image = custom_overlay_image.resize((card_width, card_height), Image.LANCZOS)
                            
                            # Aplicar blur no overlay se ativado
                            if use_blur:
                                custom_overlay_image = custom_overlay_image.filter(ImageFilter.GaussianBlur(15))
                            
                            # Aplicar escurecimento no overlay se ativado
                            if use_darken:
                                from PIL import Image
                                overlay_dark = Image.new("RGBA", (card_width, card_height), (0, 0, 0, 100))
                                custom_overlay_image = Image.alpha_composite(custom_overlay_image, overlay_dark)
                            
                            from PIL import Image
                            background = Image.alpha_composite(background.convert("RGBA"), custom_overlay_image)
                        except Exception as e:
                            log(f"Erro ao carregar overlay personalizado: {e}")
                
                # --- CAPA NÍTIDA COM MÁSCARA (apenas se use_bg estiver ativado) ---
                # Obter configuração de radius
                radius_setting = self.get_setting("lastfm_customfm_radius", 0)
                radius_values = [23, 10, 35, 50, 150]  # Standard, Small, Medium, Large, Circle
                radius = radius_values[radius_setting] if radius_setting < len(radius_values) else 23
                
                from PIL import Image, ImageDraw
                mask = Image.new("L", (mini_cover_size, mini_cover_size), 0)
                ImageDraw.Draw(mask).rounded_rectangle((0, 0, mini_cover_size, mini_cover_size), radius, fill=255)
                album_cover.putalpha(mask)
                background.paste(album_cover, (padding_left, padding_top), album_cover)
            else:
                # Usar apenas cores quando Cover BG estiver desativado
                from PIL import Image
                background = Image.new("RGBA", (card_width, card_height), bg_color)
                
                # --- GRADIENTES DINÂMICOS (Visual Avançado) ---
                gradient_bg = self._generate_gradient_background(card_width, card_height, album_cover)
                if gradient_bg:
                    from PIL import Image
                    background = Image.alpha_composite(background.convert("RGBA"), gradient_bg)
                    log(f"[NowFy] Gradiente dinâmico aplicado ao background sem capa")
                
                # --- DYNAMIC SKINS (sem blur de fundo) ---
                dynamic_skin_selection = self.get_setting("dynamic_skins_selector", 0)
                dynamic_skin_url = None
                
                if dynamic_skin_selection == 1:  # Aleatório
                    import random
                    random_choice = random.choice([2, 3, 4, 5, 6, 7, 8, 9, 10])  # Sortear entre todos os skins disponíveis
                    dynamic_skin_selection = random_choice
                
                if dynamic_skin_selection == 2:  # Midnight Pulse
                    dynamic_skin_url = "https://i.postimg.cc/GtRhnHVR/customov.png"
                elif dynamic_skin_selection == 3:  # Sunset Rhythm
                    dynamic_skin_url = "https://i.postimg.cc/3NZr83Qv/customov2.png"
                elif dynamic_skin_selection == 4:  # Spcy
                    dynamic_skin_url = "https://i.postimg.cc/MK6DDtH6/Spcy.png"
                elif dynamic_skin_selection == 5:  # Purpl
                    dynamic_skin_url = "https://i.postimg.cc/ZYFHpXTs/Purpl.png"
                elif dynamic_skin_selection == 6:  # Ardente
                    dynamic_skin_url = "https://i.postimg.cc/zf5tjsR7/Ardente.png"
                elif dynamic_skin_selection == 7:  # Manifest
                    dynamic_skin_url = "https://i.postimg.cc/FKZPnTy4/Manifest.png"
                elif dynamic_skin_selection == 8:  # Moment
                    dynamic_skin_url = "https://i.postimg.cc/65k172WD/Moment.png"
                elif dynamic_skin_selection == 9:  # Moment Redd
                    dynamic_skin_url = "https://i.postimg.cc/Sxc1cSjj/Redd.png"
                elif dynamic_skin_selection == 10:  # Moment Variant
                    dynamic_skin_url = "https://i.postimg.cc/k4gjrWst/Variant.png"
                
                # Aplicar Dynamic Skin se selecionado
                if dynamic_skin_url:
                    try:
                        # Verificar cache primeiro
                        cache_key = f"dynamic_skin_{dynamic_skin_selection}"
                        cached_image_data = self._get_cached_image_enhanced(dynamic_skin_url, cache_key)
                        
                        if cached_image_data:
                            from PIL import Image
                            dynamic_skin_image = Image.open(BytesIO(cached_image_data)).convert("RGBA")
                            dynamic_skin_image = dynamic_skin_image.resize((card_width, card_height), Image.LANCZOS)
                            log(f"[NowFy] Dynamic Skin carregado do cache: {cache_key}")
                        else:
                            dynamic_skin_image = None
                            log(f"[NowFy] Erro ao carregar Dynamic Skin: {cache_key}")
                        
                        # Aplicar efeitos apenas se a imagem foi carregada com sucesso
                        if dynamic_skin_image:
                            # Verificar configurações de blur e escurecimento
                            use_blur = self.get_setting("lastfm_customfm_blur", True)
                            use_darken = self.get_setting("lastfm_customfm_darken_background", False)
                            
                            # Aplicar blur no Dynamic Skin se ativado
                            if use_blur:
                                dynamic_skin_image = dynamic_skin_image.filter(ImageFilter.GaussianBlur(15))
                            
                            # Aplicar escurecimento no Dynamic Skin se ativado
                            if use_darken:
                                from PIL import Image
                                overlay_dark = Image.new("RGBA", (card_width, card_height), (0, 0, 0, 100))
                                dynamic_skin_image = Image.alpha_composite(dynamic_skin_image, overlay_dark)
                            
                            background = Image.alpha_composite(background.convert("RGBA"), dynamic_skin_image)
                    except Exception as e:
                        log(f"Erro ao carregar Dynamic Skin: {e}")
                
                # --- CUSTOM OVERLAY COMO BACKGROUND (fallback se Dynamic Skin não estiver ativo) ---
                if not dynamic_skin_url:
                    use_custom_overlay = self.get_setting("lastfm_customfm_use_overlay", False)
                    custom_overlay_url = self.get_setting("lastfm_customfm_overlay_url", "")
                    statsfm_username = self.get_setting("statsfm_username", "")
                    # Aplicar overlay apenas quando a origem for Last.fm (evitar StatsFM)
                    apply_overlay = use_custom_overlay and custom_overlay_url and (player_name == "FM") and not statsfm_username
                    if apply_overlay:
                        try:
                            overlay_resp = requests.get(custom_overlay_url, stream=True, timeout=10)
                            overlay_resp.raise_for_status()
                            custom_overlay_image = Image.open(BytesIO(overlay_resp.content)).convert("RGBA")
                            custom_overlay_image = custom_overlay_image.resize((card_width, card_height), Image.LANCZOS)
                            
                            # Verificar configurações de blur e escurecimento
                            use_blur = self.get_setting("lastfm_customfm_blur", True)
                            use_darken = self.get_setting("lastfm_customfm_darken_background", False)
                            
                            # Aplicar blur no overlay se ativado
                            if use_blur:
                                custom_overlay_image = custom_overlay_image.filter(ImageFilter.GaussianBlur(15))
                            
                            # Aplicar escurecimento no overlay se ativado
                            if use_darken:
                                overlay_dark = Image.new("RGBA", (card_width, card_height), (0, 0, 0, 100))
                                custom_overlay_image = Image.alpha_composite(custom_overlay_image, overlay_dark)
                            
                            background = Image.alpha_composite(background.convert("RGBA"), custom_overlay_image)
                        except Exception as e:
                            log(f"Erro ao carregar overlay personalizado: {e}")
                
                # --- CAPA NÍTIDA COM MÁSCARA (apenas se use_bg estiver ativado) ---
                # Obter configuração de radius
                radius_setting = self.get_setting("lastfm_customfm_radius", 0)
                radius_values = [23, 10, 35, 50, 150]  # Standard, Small, Medium, Large, Circle
                radius = radius_values[radius_setting] if radius_setting < len(radius_values) else 23
                
                mask = Image.new("L", (mini_cover_size, mini_cover_size), 0)
                ImageDraw.Draw(mask).rounded_rectangle((0, 0, mini_cover_size, mini_cover_size), radius, fill=255)
                album_cover.putalpha(mask)
                background.paste(album_cover, (padding_left, padding_top), album_cover)

            # --- FONTES E TEXTO ---
            # Usa fontes customizadas da classe, ajustando tamanho para alta resolução
            font_selector = self.get_setting("font_selector", 0)
            title_size = 53 if use_high_res else 28
            artist_size = 42 if use_high_res else 22
            regular_size = 38 if use_high_res else 20
            
            font_title = self._get_font_for_title(title, font_selector, max_size=title_size, min_size=title_size, base_size=title_size)
            font_artist = self._get_font_for_artist(artist, font_selector, size=artist_size)
            font_regular = self._get_default_font(size=regular_size)
            
            # Verificar se o texto deve ser em negrito
            use_bold_text = self.get_setting("lastfm_customfm_bold_text", False)
            if use_bold_text:
                # Usar fontes em negrito para título e artista
                font_title = self._get_font_for_title(title, font_selector, max_size=title_size, min_size=title_size, base_size=title_size, force_bold=True)
                font_artist = self._get_font_for_artist(artist, font_selector, size=artist_size, force_bold=True)

            draw = ImageDraw.Draw(background)
            text_x = text_start_x  # Usar a posição calculada com base na posição da capa
            text_y_offset = 57 if use_high_res else 30
            text_y = padding_top + text_y_offset
            max_text_width = 1140 if use_high_res else 600
            # 'Listening to' (regular)
            text_y = self.draw_multiline_text(draw, "Listening to", (text_x, text_y), font_regular, text_color, max_text_width)
            text_y += 15 if use_high_res else 8
            # Título (negrito ou regular, dependendo da configuração)
            text_y = self.draw_multiline_text(draw, title, (text_x, text_y), font_title, text_color, max_text_width)
            text_y += 11 if use_high_res else 6
            # Desenhar nome do artista (negrito ou regular, dependendo da configuração)
            text_y = self.draw_multiline_text(draw, artist, (text_x, text_y), font_artist, text_color, max_text_width)
            text_y += 38 if use_high_res else 20

            # --- ICON DO PLAYER ---
            icon_size = 85 if use_high_res else 45
            icon_x = text_x
            icon_y = text_y
            icon_url = self._get_service_icon(player_name, use_custom_color=True)
            if icon_url:
                try:
                    response = requests.get(icon_url, stream=True)
                    if response.status_code == 200:
                        icon_image = Image.open(BytesIO(response.content)).convert('RGBA')
                        icon_image = icon_image.resize((icon_size, icon_size), Image.LANCZOS)
                        background.paste(icon_image, (icon_x, icon_y), icon_image)
                except Exception:
                    pass

            # --- MASK FINAL ---
            corner_radius = 95 if use_high_res else 50
            rounded_mask = Image.new("L", (card_width, card_height), 0)
            draw_round = ImageDraw.Draw(rounded_mask)
            draw_round.rounded_rectangle((0, 0, card_width, card_height), corner_radius, fill=255)
            background.putalpha(rounded_mask)

            if progress_dialog:
                run_on_ui_thread(lambda: progress_dialog.set_progress(90))
            # Salvar como PNG (lossless) mantendo RGBA; compress_level baseado em performance_mode
            performance_mode = self.get_setting("performance_mode", 1)
            compress_level = 1 if performance_mode == 0 else (4 if performance_mode == 1 else 6)
            background.save(temp_path, format='PNG', optimize=True, compress_level=compress_level)
            
            # Definir track_data com base nos parâmetros do método
            track_data = {
                "name": title or "Unknown Track",
                "artist": artist or "Unknown Artist", 
                "album": album or "Unknown Album"
            }
            
            # Caption personalizada baseada no player
            footer = self.get_setting("custom_footer_text", "")
            custom_caption = self.get_setting("custom_footer_text", "")
            caption_parts = []
            # Verificar se deve mostrar a legenda
            show_caption = self.get_setting("show_caption", True)
            if show_caption:
                # Obter o estilo de caption selecionado
                caption_style_index = self.get_setting("caption_style", 0)
                caption_style_items = ["Custom", "Apple Based", "Pepe", "Minim", "Spoty"]
                caption_style = caption_style_items[caption_style_index] if caption_style_index < len(caption_style_items) else "Custom"
                
                if caption_style == "Custom":
                    # Usar caption personalizado (comportamento original)
                    footer = self.get_setting("custom_footer_text", "")
                    if footer:
                        # Processar variáveis {track}, {artist} e {album} no custom caption
                        processed_footer = footer.strip()
                        if "{track}" in processed_footer or "{artist}" in processed_footer or "{album}" in processed_footer:
                            album_name = track_data.get("album", "Unknown Album") if track_data else "Unknown Album"
                            processed_footer = processed_footer.replace("{track}", title or "Unknown Track")
                            processed_footer = processed_footer.replace("{artist}", artist or "Unknown Artist")
                            processed_footer = processed_footer.replace("{album}", album_name)
                        caption_parts.append(processed_footer)
                else:
                    # Usar template predefinido
                    track_info = {
                        "name": title or "Unknown Track",
                        "artist": artist or "Unknown Artist",
                        "album": track_data.get("album", "Unknown Album") if track_data else "Unknown Album"
                    }
                    
                    template_caption = self._get_caption_template(caption_style, track_info)
                    if template_caption:
                        caption_parts.append(template_caption)
            # Verificar configurações de Link Options
            show_track_link = self.get_setting("show_track_link", True)
            platform_links = self.get_setting("platform_links", 0)  # 0=Spotify, 1=Universal, 2=Both
            
            if show_caption == "ON" and show_track_link:
                # Lógica de Link Options baseada nas configurações
                if show_track_link and player_name == "Spotify":
                    # Lógica baseada no novo Platform Links selector
                    if platform_links == 0:  # Spotify only
                        if youtube_url and "open.spotify.com" in youtube_url:
                            caption_parts.append(f"[Spotify]({youtube_url})")
                        else:
                            spotify_url = self._search_spotify_url(title, artist)
                            if spotify_url:
                                caption_parts.append(f"[Spotify]({spotify_url})")
                    elif platform_links == 1:  # Universal only
                        if youtube_url and "open.spotify.com" in youtube_url:
                            song_link_url = self._get_song_link(youtube_url)
                        else:
                            spotify_url = self._search_spotify_url(title, artist)
                            song_link_url = self._get_song_link(spotify_url) if spotify_url else None
                        
                        if song_link_url:
                            caption_parts.append(f"[song.link]({song_link_url})")
                        elif youtube_url and "open.spotify.com" in youtube_url:
                            caption_parts.append(f"[Spotify]({youtube_url})")
                        elif spotify_url:
                            caption_parts.append(f"[Spotify]({spotify_url})")
                    elif platform_links == 2:  # Both
                        # Adicionar ambos os links
                        if youtube_url and "open.spotify.com" in youtube_url:
                            caption_parts.append(f"[Spotify]({youtube_url})")
                            song_link_url = self._get_song_link(youtube_url)
                            if song_link_url:
                                caption_parts.append(f"[song.link]({song_link_url})")
                        else:
                            spotify_url = self._search_spotify_url(title, artist)
                            if spotify_url:
                                caption_parts.append(f"[Spotify]({spotify_url})")
                                song_link_url = self._get_song_link(spotify_url)
                                if song_link_url:
                                    caption_parts.append(f"[song.link]({song_link_url})")
                elif player_name == "YouTube" or player_name == "YouTube Music":
                    search_query = f"{title} {artist}"
                    youtube_search_url = f"https://www.youtube.com/results?search_query={quote(search_query)}"
                    service_name = "YouTube Music" if player_name == "YouTube Music" else "YouTube"
                    caption_parts.append(f"[{service_name}]({youtube_search_url})")
                elif player_name == "SoundCloud":
                    # Adicionar link para SoundCloud
                    search_query = f"{title} {artist}"
                    soundcloud_url = f"https://soundcloud.com/search?q={quote(search_query)}"
                    caption_parts.append(f"[SoundCloud]({soundcloud_url})")
                elif player_name == "Apple Music":
                    # Adicionar link para Apple Music
                    search_query = f"{title} {artist}"
                    apple_music_url = f"https://music.apple.com/search?term={quote(search_query)}"
                    caption_parts.append(f"[Apple Music]({apple_music_url})")
                elif player_name in ["exteraGram", "AyuGram"]:
                    display_name = "AyuGram" if player_name == "AyuGram" else "exteraGram"
                    username = self.get_setting("exteragram_username", "").strip()
                    if username.startswith("@"):
                        username = username[1:]
                    if not username:
                        link = "https://t.me/exteraGram" if player_name == "exteraGram" else "https://t.me/ayugram"
                    else:
                        link = f"https://t.me/{username}"
                    caption_parts.append(f"[{display_name}]({link})")
                elif player_name == "FM":
                    # Para FM, verificar se há Custom Link configurado
                    custom_link_url = self.get_setting("fm_custom_link_url", "").strip()
                    if custom_link_url:
                        # Usar nome personalizado do player se configurado
                        custom_player_name = self.get_setting("fm_custom_player_name", "Custom Player")
                        caption_parts.append(f"[{custom_player_name}]({custom_link_url})")
                    else:
                        # Para FM, usar Last.fm se disponível
                        lastfm_username = self.get_setting("lastfm_user", "")
                        if lastfm_username:
                            lastfm_profile_url = f"https://www.last.fm/user/{lastfm_username}"
                            caption_parts.append(f"[Last.FM]({lastfm_profile_url})")
                        else:
                            # Usar nome personalizado do player se configurado
                            custom_player_name = self.get_setting("fm_custom_player_name", "Custom Player")
                            caption_parts.append(f"{custom_player_name}")

            # Verificar se deve mostrar o link FM baseado na seleção do usuário
            fm_link_option = self.get_setting("fm_link_option", 0)
            if fm_link_option == 1:  # LastFM
                lastfm_username = self.get_setting("lastfm_user", "")
                if lastfm_username:
                    lastfm_profile_url = f"https://www.last.fm/user/{lastfm_username}"
                    caption_parts.append(f"[Last.FM]({lastfm_profile_url})")
            elif fm_link_option == 2:  # StatsFM
                statsfm_username = self.get_setting("statsfm_username", "")
                if statsfm_username:
                    statsfm_profile_url = f"https://stats.fm/{statsfm_username}"
                    caption_parts.append(f"[Stats.FM]({statsfm_profile_url})")
            elif fm_link_option == 3:  # Custom Link
                custom_url = self.get_setting("fm_custom_link_url", "")
                custom_name = self.get_setting("fm_custom_player_name", "Custom Player")
                if custom_url:
                    caption_parts.append(f"[{custom_name}]({custom_url})")
            elif fm_link_option == 3:  # Custom Link
                custom_link_url = self.get_setting("fm_custom_link_url", "").strip()
                if custom_link_url:
                    custom_player_name = self.get_setting("fm_custom_player_name", "Custom Player")
                    caption_parts.append(f"[{custom_player_name}]({custom_link_url})")

            caption = " • ".join(caption_parts) if caption_parts else ""
            
            # Verificar se está no modo NowCast
            if getattr(self, '_nowcast_mode', False):
                # No modo NowCast, usar bot_caption se disponível
                bot_caption = self.get_setting("bot_caption_text", "")
                if bot_caption:
                    # Processar variáveis {track}, {artist} e {album} no bot caption
                    processed_bot_caption = bot_caption.strip()
                    if "{track}" in processed_bot_caption or "{artist}" in processed_bot_caption or "{album}" in processed_bot_caption:
                        album_name = album or "Unknown Album"  # Usar parâmetro album diretamente
                        processed_bot_caption = processed_bot_caption.replace("{track}", title)
                        processed_bot_caption = processed_bot_caption.replace("{artist}", artist)
                        processed_bot_caption = processed_bot_caption.replace("{album}", album_name)
                    
                    # Combinar caption original com bot_caption
                    if caption:
                        final_caption = f"{caption} • {processed_bot_caption}"
                    else:
                        final_caption = processed_bot_caption
                    self._nowcast_caption = final_caption
                else:
                    # Usar caption original se não houver bot_caption
                    self._nowcast_caption = caption
                return temp_path
            
            if params:
                # Verificar se params é um objeto com atributo caption ou um dict
                if hasattr(params, 'caption'):
                    # Processar emojis premium (sempre habilitado)
                    if caption:
                        caption = self._process_premium_emojis(caption)
                    
                    caption_md = parse_markdown(caption)
                    params.caption = caption_md.text
                    params.entities = ArrayList()
                    for entity in caption_md.entities:
                        params.entities.add(entity.to_tlrpc_object())
                    photo = send_helper.generatePhotoSizes(temp_path, None)
                    params.photo = photo
                    params.path = temp_path
                    params.message = None
                    run_on_ui_thread(lambda: send_helper.sendMessage(params))
                else:
                    # Se params é um dict ou não tem atributo caption, apenas retornar o caminho da imagem
                    log(f"[Nowfy] CustomFM - params is dict or missing caption attribute, returning image path: {temp_path}")
                    return temp_path
                # Atualizar bio após o envio do card
                if self.get_setting("enable_autobio", False):
                    autobio_text = self.get_setting("autobio_text", "Now Playing: {track} by {artist}")
                    bio = autobio_text.format(track=title, artist=artist)
                    run_on_ui_thread(lambda: self._update_bio(bio, show_bulletin=False))
                if bool(self.get_setting("enable_quick_dismiss", True)):
                    run_on_ui_thread(self._dismiss_loading_dialog)

        except Exception as e:
            if progress_dialog:
                try: progress_dialog.dismiss()
                except Exception: pass
            BulletinHelper.show_info(tr("error_lastfm").format(error=str(e)) if "error_lastfm" in TRANSLATIONS else f"LastFM error: {str(e)}")
            # Fechar o dialog de loading mesmo em caso de erro
            if bool(self.get_setting("enable_quick_dismiss", True)):
                run_on_ui_thread(self._dismiss_loading_dialog)

    def _detect_current_player(self):
        try:
            # Verificar se há um player forçado (para comandos .etg e .ayu)
            if hasattr(self, '_forced_player'):
                forced_player = self._forced_player
                log(f"[Nowfy] Using forced player: {forced_player}")
                return forced_player
                
            player_index = self.get_setting("current_player", 0)
            players = ["Spotify", "YouTube", "YouTube Music", "AyuGram", "exteraGram", "SoundCloud", "Apple Music", "Yandex Music", "FM"]
            # Se vier como string numérica, converte para int
            if isinstance(player_index, str) and player_index.isdigit():
                player_index = int(player_index)
            # Se vier como índice, retorna o player correspondente
            if isinstance(player_index, int):
                if player_index >= len(players):
                    detected_player = "Spotify"
                else:
                    detected_player = players[player_index]
            # Se vier como string com nome do player, retorna direto
            elif isinstance(player_index, str) and player_index in players:
                detected_player = player_index
            else:
                detected_player = "Spotify"
            log(f"[Nowfy] Detected player: {detected_player} (index: {player_index})")
            return detected_player
        except Exception as e:
            log(f"[Nowfy] Error detecting player: {e}")
            return "Spotify"
    
    def _get_apple_skin_selector(self):
        """Retorna o seletor Apple Skin com lógica para ocultar 'Light' quando SoundCloud estiver ativo e 'Red' removido por problemas de compatibilidade"""
        current_player = self._detect_current_player()
        
        # Se SoundCloud estiver ativo, usar apenas Dark (Red removido por problemas)
        if current_player == "SoundCloud":
            items = ["Dark"]
            default = 0  # Dark será o único índice disponível
        else:
            items = ["Light", "Dark"]  # Red removido por problemas de compatibilidade
            default = 0  # Light como padrão
        
        return Selector(
             key="apple_skin",
             text=tr("apple_skin"),
             default=default,
             items=items,
             icon="msg_palette",
             on_change=lambda v: self.reload_settings()
         )
    
    def _get_platform_logo_selector(self):
        """Retorna o seletor Platform Logo com opções baseadas no player atual"""
        current_player = self._detect_current_player()
        
        # Opção "None" sempre disponível como primeira opção
        items = [tr("platform_logo_none")]
        
        if current_player in ("AyuGram", "exteraGram"):
            # Para AyuGram/exteraGram: apenas None e Default
            items.append(tr("platform_logo_default"))
        elif current_player == "Apple Music":
            items.extend([
                tr("platform_logo_apple_red_white"),
                tr("platform_logo_apple_white_red"),
                tr("platform_logo_apple_black_white"),
                tr("platform_logo_apple_white_black")
            ])
        else:  # Spotify ou outros (usar opções do Spotify como padrão)
            items.extend([
                tr("platform_logo_spotify_green_white"),
                tr("platform_logo_spotify_white_green"),
                tr("platform_logo_spotify_black_white"),
                tr("platform_logo_spotify_white_black")
            ])
        
        return Selector(
            key="vinify_platform_logo",
            text=tr("vinify_platform_logo"),
            default=0,  # "None" como padrão
            items=items,
            icon="menu_feature_custombg"
        )

    def _get_logo_position_selector(self):
        """Retorna o seletor de posição do logo, restringindo para bottom em AyuGram/exteraGram"""
        current_player = self._detect_current_player()
        if current_player in ("AyuGram", "exteraGram"):
            # Apenas posição inferior disponível e default=1 (inferior)
            return Selector(
                key="vinify_logo_position",
                text=tr("logo_position"),
                default=1,
                items=[
                    tr("logo_position_inferior")
                ],
                icon="photo_expand",
                on_change=lambda v: self.reload_settings()
            )
        # Demais players: superior e inferior
        return Selector(
            key="vinify_logo_position",
            text=tr("logo_position"),
            default=0,
            items=[
                tr("logo_position_superior"),
                tr("logo_position_inferior")
            ],
            icon="photo_expand",
            on_change=lambda v: self.reload_settings()
        )
    
    def _get_spotlight_skin_selector(self):
        """Retorna o seletor Spotlight Skin com as opções Light, Dark e Blur"""
        items = ["Light", "Dark", "Blur"]
        default = 0  # Light como padrão
        
        return Selector(
             key="spotlight_skin",
             text="Spotlight Skin",
             default=default,
             items=items,
             icon="msg_palette",
             on_change=lambda v: self.reload_settings()
         )
    
    def _get_apple_skin_index_mapped(self):
        """Mapeia o índice do apple_skin considerando se SoundCloud está ativo"""
        current_player = self._detect_current_player()
        apple_skin_setting = self.get_setting("apple_skin", 0)  # Padrão Light (0)
        
        if current_player == "SoundCloud":
            # Para SoundCloud: apenas Dark e Red são suportados
            # O seletor mostra ["Dark", "Red"] com índices 0 e 1
            # Precisamos mapear para o sistema original: Dark=1, Red=2
            if apple_skin_setting == 0:  # Dark (primeiro item no seletor SoundCloud)
                return 1  # Mapear para Dark no sistema original
            elif apple_skin_setting == 1:  # Red (segundo item no seletor SoundCloud)
                return 2  # Mapear para Red no sistema original
            else:
                return 1  # Default para Dark
        else:
            # Para outros players: Light=0, Dark=1, Red=2 (sistema original)
            # Garantir que o valor está dentro dos limites válidos
            if apple_skin_setting < 0 or apple_skin_setting > 2:
                return 0  # Default para Light se valor inválido
            return apple_skin_setting

    def create_lastfm_customfm_options(self):
        # Opções fixas de Icon Colors
        icon_color_items = [
            "Normal",
            "Black", 
            "White"
        ]     
        # Opções para posição da mini capa
        cover_position_items = [
            tr("customfm_position_left"),   # Posição padrão
            tr("customfm_position_right")   # Nova posição
        ]
        
        # Verificar qual player está selecionado
        current_player_setting = self.get_setting("current_player", 0)
        is_fm_player = current_player_setting == 7  # FM
        
        options = [
            Divider(text=tr("customfm_background_section")),
            Switch(
                key="lastfm_customfm_use_background",
                text=tr("customfm_use_background"),
                default=True,
                icon="msg_copy_photo",
                subtext=tr("customfm_use_background_sub")
            ),
            Input(
                key="lastfm_customfm_background_color",
                text=tr("customfm_background_color"),
                default="#d2d2d2",
                icon="ic_colorpicker_solar",
                subtext=tr("customfm_background_color_sub")
            ),
            # Opção para ativar/desativar blur de fundo
            Switch(
                key="lastfm_customfm_blur",
                text=tr("customfm_blur"),
                default=True,
                icon="msg_copy_photo",
                subtext=tr("customfm_blur_sub")
            ),
            # Opção para ativar/desativar escurecimento de fundo
            Switch(
                key="lastfm_customfm_darken_background",
                text=tr("customfm_darken_background"),
                default=False,
                icon="msg_copy_photo",
                subtext=tr("customfm_darken_background_sub")
            ),

            Divider(text=tr("customfm_text_section")),
            Input(
                key="lastfm_customfm_text_color",
                text=tr("customfm_text_color"),
                default="#000000",
                icon="menu_feature_color_name",
                subtext=tr("customfm_text_color_sub")
            ),
            # Opção para ativar/desativar negrito no título e artista
            Switch(
                key="lastfm_customfm_bold_text",
                text=tr("customfm_bold_text"),
                default=False,
                icon="msg_photo_text_framed2",
                subtext=tr("customfm_bold_text_sub")
            ),

            Divider(text=tr("customfm_style_section")),
            # Opção para escolher a posição da mini capa
            Selector(
                key="lastfm_customfm_cover_position",
                text=tr("customfm_cover_position"),
                default=0,  # Esquerda como padrão
                items=cover_position_items,
                icon="menu_feature_cover"
            ),
            Selector(
                key="lastfm_customfm_radius",
                text=tr("customfm_radius"),
                default=0,
                items=[tr("customfm_radius_standard"), tr("customfm_radius_small"), tr("customfm_radius_medium"), tr("customfm_radius_large"), tr("customfm_radius_circle")],
                icon="menu_cover_stories"
            ),
            # Mostrar Icon Colors apenas quando FM NÃO estiver selecionado
            *([Selector(
                key="customfm_icon_color",
                text=tr("customfm_icon_colors"),
                default=0,
                items=icon_color_items,
                icon="msg_colors"
            )] if not is_fm_player else []),
            
            # Mostrar Ícone Personalizado apenas quando FM estiver selecionado
            *([Input(
                key="fm_custom_icon_url",
                text=tr("customfm_custom_icon_url"),
                default="",
                icon="msg_link2_remix",
                subtext=tr("customfm_custom_icon_url_sub")
            )] if is_fm_player else []),
            
            # Mostrar Link Personalizado apenas quando FM estiver selecionado
            *([Input(
                key="fm_custom_link_url",
                text=tr("customfm_custom_link_url"),
                default="",
                icon="msg_link2_remix",
                subtext=tr("customfm_custom_link_url_sub")
            )] if is_fm_player else []),
            
            # Mostrar Nome Personalizado do Player apenas quando FM estiver selecionado
            *([Input(
                key="fm_custom_player_name",
                text=tr("customfm_custom_player_name"),
                default="Custom Player",
                icon="msg_photo_text_framed3",
                subtext=tr("customfm_custom_player_name_sub")
            )] if is_fm_player else []),
        ]
        
        # Adicionar as demais opções
        options.extend([
            Divider(text=tr("quality_options_section")),
            Switch(
                key="customfm_high_resolution",
                text=tr("customfm_high_resolution"),
                default=True,
                icon="menu_quality_hd_filled",
                subtext=tr("customfm_high_resolution_sub")
            ),
            Divider(text=tr("customfm_overlay_section")),
            Switch(
                key="lastfm_customfm_use_overlay",
                text=tr("customfm_use_overlay"),
                default=False,
                icon="msg_copy_photo",
                subtext=tr("customfm_use_overlay_sub")
            ),
            Input(
                key="lastfm_customfm_overlay_url",
                text=tr("customfm_overlay_url"),
                default="",
                icon="msg_link2_remix",
                subtext=tr("customfm_overlay_url_enhanced_sub")
            ),
            Divider(text=tr("dynamic_skins_section")),
            Selector(
                key="dynamic_skins_selector",
                text=tr("dynamic_skins_selector"),
                default=0,
                items=[
                    tr("dynamic_skins_none"),
                    tr("dynamic_skins_random"),
                    "Midnight Pulse",
                    "Sunset Rhythm",
                    tr("dynamic_skins_spcy"),
                    tr("dynamic_skins_purpl"),
                    tr("dynamic_skins_ardente"),
                    tr("dynamic_skins_manifest"),
                    tr("dynamic_skins_moment"),
                    tr("dynamic_skins_moment_redd"),
                    tr("dynamic_skins_moment_variant")
                ],
                icon="msg_fave",
            ),
            # Visual Avançado Subfragment
            Text(
                text=tr("visual_avancado_section"),
                icon="msg_mini_customize_remix",
                create_sub_fragment=self.create_visual_avancado_subfragment
            ),
            Divider(text=tr("read_docs_theme"))
        ])
        
        return options

    
    def _get_apple_cache_key(self, image_data, settings):
        """Gera uma chave única para o cache baseada na imagem e configurações"""
        import hashlib
        # Criar hash da imagem
        if hasattr(image_data, 'tobytes'):
            image_hash = hashlib.md5(image_data.tobytes()).hexdigest()[:16]
        else:
            image_hash = hashlib.md5(str(image_data).encode()).hexdigest()[:16]
        
        # Criar hash das configurações - VERSÃO CORRIGIDA
        
        # Construir string de configurações de forma explícita e segura
        settings_str = (
            f"{settings['antialiasing_quality']}_"
            f"{settings['resize_algorithm']}_"
            f"{settings['cover_quality']}_"
            f"{settings['enhanced_smoothing']}_"
            f"{settings['edge_enhancement']}_"
            f"{settings['color_enhancement']}_"
        )
        
        settings_hash = hashlib.md5(settings_str.encode()).hexdigest()[:8]
        
        # Log para diagnóstico
        log(f"[RADIUS DEBUG] Cache key settings_str: {settings_str}")
        log(f"[RADIUS DEBUG] Cache key generated: apple_cache_{image_hash}_{settings_hash}")
        
        return f"apple_cache_{image_hash}_{settings_hash}"
    
    def _apply_apple_antialiasing(self, image, target_size):
        """Aplica anti-aliasing baseado nas configurações do Apple UI"""
        try:
            # Obter configurações do Apple UI
            antialiasing_quality = self.get_setting("apple_antialiasing_quality", 1)
            resize_algorithm = self.get_setting("apple_resize_algorithm", 0)
            cover_quality = self.get_setting("apple_cover_quality", 0)
            enhanced_smoothing = self.get_setting("apple_enhanced_smoothing", True)
            edge_enhancement = self.get_setting("apple_edge_enhancement", False)
            color_enhancement = self.get_setting("apple_color_enhancement", False)
            cache_enabled = self.get_setting("apple_cache_processed_covers", True)
            async_processing = self.get_setting("apple_async_processing", True)
            
            # Verificar cache se habilitado
            if cache_enabled:
                settings_dict = {
                    'antialiasing_quality': antialiasing_quality,
                    'resize_algorithm': resize_algorithm,
                    'cover_quality': cover_quality,
                    'enhanced_smoothing': enhanced_smoothing,
                    'edge_enhancement': edge_enhancement,
                    'color_enhancement': color_enhancement
                }
                cache_key = self._get_apple_cache_key(image, settings_dict)
                
                # Log para diagnóstico de cache
                log(f"[RADIUS DEBUG] Checking cache with key: {cache_key}")
                log(f"[RADIUS DEBUG] Cache exists: {hasattr(self, '_apple_cache')}")
                if hasattr(self, '_apple_cache'):
                    log(f"[RADIUS DEBUG] Cache contains key: {cache_key in self._apple_cache}")
                    log(f"[RADIUS DEBUG] Cache size: {len(self._apple_cache)}")
                
                # Tentar obter do cache
                if hasattr(self, '_apple_cache') and cache_key in self._apple_cache:
                    log(f"[RADIUS DEBUG] Using cached image")
                    return self._apple_cache[cache_key]
                else:
                    log(f"[RADIUS DEBUG] Cache miss, will process new image")
                
                # Inicializar cache se não existir
                if not hasattr(self, '_apple_cache'):
                    self._apple_cache = {}
                
                # Limitar tamanho do cache (máximo 50 itens)
                if len(self._apple_cache) > 50:
                    # Remover itens mais antigos
                    oldest_keys = list(self._apple_cache.keys())[:10]
                    for key in oldest_keys:
                        del self._apple_cache[key]
            
            # Determinar tamanho baseado na qualidade (melhorado para Apple Music)
            if cover_quality == 1:  # Alta
                process_size = (600, 600)
            elif cover_quality == 2:  # Ultra
                process_size = (800, 800)
            else:  # Normal - aumentado para melhor qualidade mantendo proporções
                process_size = (512, 512) if target_size == (298, 298) else target_size
            
            # Determinar algoritmo de redimensionamento (otimizado para qualidade)
            algorithms = [Image.LANCZOS, Image.BICUBIC, Image.BILINEAR, Image.NEAREST]
            # Usar LANCZOS por padrão para melhor qualidade
            algorithm = algorithms[resize_algorithm] if resize_algorithm < len(algorithms) else Image.LANCZOS
            
            # Para Apple Music, sempre usar LANCZOS para máxima qualidade
            current_player = self._detect_current_player()
            if current_player == "Apple Music":
                algorithm = Image.LANCZOS
            
            # Redimensionar para tamanho de processamento
            if process_size != target_size:
                processed_image = ImageOps.fit(image, process_size, method=algorithm, centering=(0.5, 0.5))
            else:
                processed_image = ImageOps.fit(image, target_size, method=algorithm, centering=(0.5, 0.5))
            
            # Aplicar filtros baseados na qualidade do anti-aliasing (otimizado)
            if antialiasing_quality >= 1:  # Suave ou superior
                processed_image = processed_image.filter(ImageFilter.SMOOTH_MORE)
            
            if antialiasing_quality >= 2:  # Ultra Suave ou superior
                processed_image = processed_image.filter(ImageFilter.SMOOTH)
                # Aplicar nitidez leve para compensar a suavização
                processed_image = processed_image.filter(ImageFilter.SHARPEN)
            
            if antialiasing_quality >= 3:  # Máxima Qualidade
                # Aplicar filtro UnsharpMask para melhor nitidez
                processed_image = processed_image.filter(ImageFilter.UnsharpMask(radius=1, percent=120, threshold=3))
            
            # Para Apple Music, aplicar sempre filtros de alta qualidade
            if current_player == "Apple Music":
                processed_image = processed_image.filter(ImageFilter.SMOOTH_MORE)
                processed_image = processed_image.filter(ImageFilter.UnsharpMask(radius=1, percent=110, threshold=2))
            
            # Aplicar suavização aprimorada se habilitada
            if enhanced_smoothing:
                processed_image = processed_image.filter(ImageFilter.SMOOTH_MORE)
            
            # Aplicar realce de bordas se habilitado
            if edge_enhancement:
                processed_image = processed_image.filter(ImageFilter.EDGE_ENHANCE)
            
            # Aplicar realce de cores se habilitado
            if color_enhancement:
                from PIL import ImageEnhance
                enhancer = ImageEnhance.Color(processed_image)
                processed_image = enhancer.enhance(1.2)  # Aumentar saturação em 20%
                enhancer = ImageEnhance.Contrast(processed_image)
                processed_image = enhancer.enhance(1.1)  # Aumentar contraste em 10%
            
            # Redimensionar para tamanho final se necessário
            if process_size != target_size:
                processed_image = ImageOps.fit(processed_image, target_size, method=algorithm, centering=(0.5, 0.5))
            
            # Processamento finalizado
            
            # Salvar no cache se habilitado
            if cache_enabled:
                self._apple_cache[cache_key] = processed_image.copy()
            
            return processed_image
            
        except Exception as e:
            log(f"Erro ao aplicar anti-aliasing Apple: {e}")
            # Fallback para método padrão
            return ImageOps.fit(image, target_size, method=Image.LANCZOS, centering=(0.5, 0.5)).filter(ImageFilter.SMOOTH_MORE)
    
    def _get_dynamic_ui_options(self, theme_items):
        """Retorna as opções de UI baseadas no tema selecionado"""
        ui_options = []
        
        # Obter o tema selecionado atual
        current_theme = self.get_setting("theme_selector", 0)
        
        # Verificar se é o tema Apple (índice 0)
        if current_theme == 0:  # Apple
            ui_options.extend([
                Text(
                    text="Apple UI",
                    icon="msg_theme_remix",
                    create_sub_fragment=self.create_apple_ui_options
                )
            ])
        
        # Verificar se é CustomFM (penúltimo na lista)
        customfm_index = len(theme_items) - 2  # CustomFM é sempre penúltimo
        if current_theme == customfm_index:
            ui_options.append(
                Text(
                    text="CustomFM UI",
                    icon="msg_theme_solar",
                    create_sub_fragment=self.create_lastfm_customfm_options
                )
            )
        
        # Verificar se é Vinify (4º último na lista: Vinify, Nowv, CustomFM, Minimal)
        vinify_index = len(theme_items) - 4  # Vinify é o 4º último
        if current_theme == vinify_index:
            ui_options.append(
                Text(
                    text="Vinify UI",
                    icon="msg_theme_remix",
                    create_sub_fragment=self.create_vinify_ui_options
                )
            )
        
        # Verificar se é Nowv (3º último na lista)
        nowv_index = len(theme_items) - 3  # Nowv é o 3º último
        if current_theme == nowv_index:
            ui_options.append(
                Text(
                    text="Nowv UI",
                    icon="msg_theme_remix",
                    create_sub_fragment=self.create_nowv_ui_options
                )
            )
        
        # Para Minimal, não mostrar nenhuma UI específica
        
        return ui_options
    
    def create_apple_ui_options(self):
        """Cria as opções avançadas para os temas Apple (Experimental)
        
        Funcionalidades implementadas:
        - Radius configurável para mini capas
        - Anti-aliasing configurável (Padrão, Suave, Ultra Suave, Máxima Qualidade)
        - Algoritmos de redimensionamento (LANCZOS, BICUBIC, BILINEAR, NEAREST)
        - Qualidade da mini capa (Normal 298x298, Alta 400x400, Ultra 500x500)
        - Suavização aprimorada com filtros adicionais
        - Realce de bordas para melhor definição
        - Realce de cores com saturação e contraste
        - Cache inteligente para mini capas processadas
        - Processamento assíncrono para melhor performance
        """
        

        
        # Opções de qualidade de anti-aliasing
        antialiasing_quality_items = [
            tr("apple_antialiasing_standard"),
            tr("apple_antialiasing_smooth"),
            tr("apple_antialiasing_ultra_smooth"),
            tr("apple_antialiasing_high_quality")
        ]
        
        # Opções de algoritmo de redimensionamento
        resize_algorithm_items = [
            "LANCZOS (Default)",
            "BICUBIC",
            "BILINEAR",
            "NEAREST"
        ]
        
        # Opções de qualidade da mini capa
        cover_quality_items = [
            "Normal (298x298)",
            "Alta (400x400)",
            "Ultra (500x500)"
        ]
        
        return [
            Divider(text=tr("apple_ui_warning")),
            

            
            Divider(text=tr("apple_quality_antialiasing_section")),
            Selector(
                key="apple_antialiasing_quality",
                text=tr("apple_antialiasing_quality"),
                default=1,  # Suave como padrão
                items=antialiasing_quality_items,
                icon="msg_photo_curve_remix"
            ),
            Selector(
                key="apple_resize_algorithm",
                text=tr("apple_resize_algorithm"),
                default=0,  # LANCZOS como padrão
                items=resize_algorithm_items,
                icon="media_crop"
            ),
            Selector(
                key="apple_cover_quality",
                text=tr("apple_cover_quality"),
                default=1,  # Alta qualidade como padrão
                items=cover_quality_items,
                icon="menu_feature_cover"
            ),
            
            Divider(text=tr("apple_visual_optimizations_section")),
            Switch(
                key="apple_enhanced_smoothing",
                text=tr("apple_enhanced_smoothing"),
                default=True,
                icon="msg_forward_replace_remix"
            ),
            Switch(
                key="apple_edge_enhancement",
                text=tr("apple_edge_enhancement"),
                default=True,
                icon="msg_gallery"
            ),
            Switch(
                key="apple_color_enhancement",
                text=tr("apple_color_enhancement"),
                default=True,
                icon="msg_brightness_low"
            ),
            
            Divider(text=tr("apple_performance_section")),
            Switch(
                key="apple_cache_processed_covers",
                text=tr("apple_cache_processed_covers"),
                default=True,
                icon="menu_feature_hourglass"
            ),
            Switch(
                key="apple_async_processing",
                text=tr("apple_async_processing"),
                default=False,
                icon="msg2_folder"
            )
        ]

    def create_vinify_ui_options(self):
        """Cria as opções de UI para o tema Vinify"""
        
        # Opções de cores para a ViniBar com nomes traduzidos
        color_options = [
            tr("color_default"),  # Padrão (Branco)
            tr("color_red"),      # Vermelho
            tr("color_orange"),   # Laranja
            tr("color_yellow"),   # Amarelo
            tr("color_green"),    # Verde
            tr("color_blue"),     # Azul
            tr("color_indigo"),   # Índigo
            tr("color_violet")    # Violeta
        ]
        
        # Opções de cores de fundo com nomes traduzidos
        bg_color_options = [
            tr("color_default"),  # Padrão (Cinza)
            tr("color_red"),      # Vermelho escuro
            tr("color_orange"),   # Laranja escuro
            tr("color_yellow"),   # Amarelo escuro
            tr("color_green"),    # Verde escuro
            tr("color_blue"),     # Azul escuro
            tr("color_indigo"),   # Índigo escuro
            tr("color_violet")    # Violeta escuro
        ]
        
        # Verificar configuração atual do Display Information
        device_profile_mode = self.get_setting("vinify_device_profile_mode", 0)
        
        options = [
            # Seção Informações do Card
            Divider(text=tr("card_info_section")),
            
            # Seletor para mostrar dispositivo, perfil do usuário, nome personalizado, profile & device ou nenhum
            Selector(
                key="vinify_device_profile_mode",
                text=tr("device_profile_selector"),
                default=0,  # Show Device
                items=[
                    tr("show_device"),
                    tr("my_profile"),
                    tr("custom_name"),
                    tr("profile_and_device"),
                    tr("display_none")
                ],
                icon="msg_openprofile",
                on_change=lambda v: self.reload_settings()
            )
        ]
        
        # Input para nome personalizado (aparece apenas quando Custom Name está selecionado)
        if device_profile_mode == 2:  # Custom Name
            options.append(
                Input(
                    key="vinify_custom_display_name",
                    text=tr("custom_display_name"),
                    default="",
                    icon="menu_tag_rename",
                    subtext=tr("custom_display_name_sub")
                )
            )
        
        options.extend([
            # Exibir nome do álbum ou playlist no card
            Selector(
                key="vinify_album_playlist_mode",
                text=tr("album_playlist_mode"),
                default=0,  # Desabilitado
                items=[
                    tr("album_playlist_disabled"),
                    tr("album_playlist_auto"),
                    tr("album_playlist_album"),
                    tr("album_playlist_playlist")
                ],
                icon="files_music"
            ),
            
            # Seção ViniBar Settings
            Divider(text=tr("vinibar_settings_section")),
            
            # Cor principal da ViniBar
            Selector(
                key="vinify_bar_color",
                text=tr("vinibar_color"),
                default=0,  # Padrão como padrão
                items=color_options,
                icon="photo_paint_brush_solar"
            ),
            
            # Cor de fundo da ViniBar
            Selector(
                key="vinify_bar_bg_color",
                text=tr("vinibar_bg_color"),
                default=0,  # Padrão como padrão
                items=bg_color_options,
                icon="photo_paint_brush"
            ),
            
            # Switch para ativar o gradiente
            Switch(
                key="vinify_bar_gradient",
                text=tr("vinibar_gradient"),
                default=False,
                icon="gradient_right",
                subtext=tr("vinibar_gradient_sub")
            ),
            
            # Switch para ativar o efeito de blur/vidro (ativado por padrão)
            Switch(
                key="vinify_bar_blur",
                text=tr("vinibar_blur"),
                default=True,
                icon="gradient_left",
                subtext=tr("vinibar_blur_sub")
            ),

            # Seção de Fundo do Vinify
            Divider(text=tr("vinify_background_section")),
            Switch(
                key="vinify_custom_bg_enable",
                text=tr("vinify_custom_bg"),
                default=False,
                icon="widgets_light_badgebg",
                subtext=tr("vinify_custom_bg_sub")
            ),
            Input(
                key="vinify_custom_bg_url",
                text=tr("vinify_custom_bg_url"),
                default="",
                icon="menu_feature_links",
                subtext=tr("vinify_custom_bg_url_sub")
            ),
            Selector(
                key="vinify_bg_style",
                text=tr("vinify_bg_styles"),
                default=0,
                items=[
                    tr("vinify_bg_style_none"),
                    tr("vinify_bg_style_obsidian"),
                    tr("vinify_bg_style_morph"),
                    tr("vinify_bg_style_noir"),
                    tr("vinify_bg_style_ethereal"),
                    tr("vinify_bg_style_ethereal_mirage"),
                    tr("vinify_bg_style_silken"),
                    tr("vinify_bg_style_mock"),
                    tr("vinify_bg_style_random")
                ],
                icon="msg_copy_photo"
            ),
            Selector(
                key="vinify_shadow_style",
                text=tr("vinify_shadow"),
                default=0,
                items=[
                    tr("vinify_shadow_none"),
                    tr("vinify_shadow_black"),
                    tr("vinify_shadow_white"),
                    tr("vinify_shadow_gradient")
                ],
                icon="photo_rectangle"
            ),
            
            # Seção Efeitos Visuais
            Divider(text=tr("visual_effects_section")),
            
            # Platform Logo Selector (com suporte a AyuGram/exteraGram)
            self._get_platform_logo_selector(),
            
            # Logo Position Selector (omit for AyuGram/exteraGram)
            *([] if self._detect_current_player() in ("AyuGram", "exteraGram") else [self._get_logo_position_selector()]),
            
            # Switch para inverter horizontalmente a imagem de fundo
            Switch(
                key="vinify_flip_background",
                text=tr("vinify_flip_background"),
                default=False,
                icon="media_flip",
                subtext=tr("vinify_flip_background_sub")
            ),
            
            # Seletor de efeitos de fundo baseado na capa da música
            Selector(
                key="vinify_background_effect",
                text=tr("vinify_background_effect"),
                default=0,  # None como padrão
                items=[
                    tr("background_effect_none"),
                    tr("background_effect_album_colors"),
                    tr("background_effect_blur"),
                    tr("background_effect_darker"),
                    tr("background_effect_both")
                ],
                icon="menu_feature_custombg",
                on_change=lambda v: self.reload_settings()
            ),
            
            # Color Effects: aparece apenas quando Album Colors está selecionado
            *([
                Selector(
                    key="vinify_colors_effect",
                    text=tr("colors_effects_selector"),
                    default=0,
                    items=[
                        tr("color_effect_random"),
                        tr("color_effect_diagonal"),
                        tr("color_effect_top_to_bottom")
                    ],
                    icon="msg_photo_cropfix"
                )
            ] if self.get_setting("vinify_background_effect", 0) == 1 else []) ,
            
            # Seção Configurações Avançadas
            Divider(text=tr("advanced_settings_section")),
            
            # Escolher ícone do dispositivo para Stats.fm
            Selector(
                key="statsfm_device_type",
                text=tr("statsfm_device_selector"),
                default=0,
                items=[
                    tr("device_auto"),
                    tr("device_smartphone"),
                    tr("device_computer"),
                    tr("device_speaker"),
                    tr("device_tv"),
                    tr("device_web")
                ],
                icon="msg_devices_remix"
            ),
            
            # Nome personalizado do dispositivo
            Input(
                key="vinify_device_name",
                text=tr("device_name"),
                default="",
                icon="menu_tag_rename",
                subtext=tr("device_name_sub")
            ),
            
            # Switch para trocar o lado da capa e textos
            Switch(
                key="vinify_swap_layout",
                text=tr("vinify_swap_layout"),
                default=False,
                icon="msg_replace",
                subtext=tr("vinify_swap_layout_sub")
            )
        ])
        
        return options
    
    def create_nowv_ui_options(self):
        """Cria as opções de UI para o tema Nowv"""
        try:
            # Verificar se Banner Style está ativado para controlar visibilidade
            banner_style_enabled = self.get_setting("nowv_banner_style", False)
            
            options = [
                # Seção Estilo do Tema
                Divider(text=tr("nowv_theme_style")),
                
                # Banner Style Switch
                Switch(
                    key="nowv_banner_style",
                    text="Banner Style",
                    default=False,
                    icon="msg_photos",
                    on_change=lambda v: self.reload_settings()
                )
            ]
            
            # Só mostrar Background Effect se Banner Style estiver desativado
            if not banner_style_enabled:
                options.extend([
                    # Seção Aparência Visual
                    Divider(text=tr("nowv_visual_appearance")),
                    
                    # Efeito de fundo baseado na capa
                    Selector(
                        key="nowv_background_effect",
                        text=tr("vinify_background_effect"),
                        default=0,  # None como padrão
                        items=[
                            tr("background_effect_none"),
                            tr("background_effect_blur"),
                            tr("background_effect_darker"),
                            tr("background_effect_both")
                        ],
                        icon="menu_feature_custombg"
                    ),
                    
                    # Inverter horizontalmente a imagem de fundo
                    Switch(
                        key="nowv_flip_background",
                        text=tr("vinify_flip_background"),
                        default=False,
                        icon="media_flip",
                        subtext=tr("vinify_flip_background_sub")
                    )
                ])
            
            # Seção Barra de Progresso sempre visível
            options.extend([
                # Seção Barra de Progresso
                Divider(text=tr("nowv_progress_bar")),
                
                # Seletor de estilo da NowvBar
                Selector(
                    key="nowv_bar_style",
                    text="NowvBar Style",
                    default=0,  # Style 1 como padrão
                    items=[
                        "Style 1",
                        "Style 2"
                    ],
                    icon="photo_star"
                )
            ])
            
            return options
        except Exception:
            return []
    
    def create_visual_avancado_subfragment(self):
        """Cria o subfragment Visual Avançado com recursos de gradientes dinâmicos"""
        
        # Opções para estilo do gradiente
        gradient_style_items = [
            tr("gradiente_linear"),
            tr("gradiente_radial"),
            tr("gradiente_diagonal")
        ]
        
        # Opções para direção do gradiente
        gradient_direction_items = [
            tr("gradiente_top_bottom"),
            tr("gradiente_left_right"),
            tr("gradiente_diagonal_tl_br"),
            tr("gradiente_diagonal_tr_bl")
        ]
        
        # Opções para intensidade do gradiente
        gradient_intensity_items = [
            tr("gradiente_suave"),
            tr("gradiente_medio"),
            tr("gradiente_intenso")
        ]
        
        # Opções para extração de cores
        color_extraction_items = [
            tr("gradiente_dominante"),
            tr("gradiente_complementar"),
            tr("gradiente_analogas")
        ]
        
        return [
            Divider(text=tr("gradientes_dinamicos_section")),
            Switch(
                key="visual_avancado_gradiente_enable",
                text=tr("gradiente_enable"),
                default=False,
                icon="media_button_restore",
                subtext=tr("gradiente_enable_sub")
            ),
            Selector(
                key="visual_avancado_gradiente_modo",
                text=tr("gradiente_modo"),
                default=0,
                items=[tr("gradiente_modo_auto"), tr("gradiente_modo_custom")],
                icon="msg_photo_settings"
            ),
            Selector(
                key="visual_avancado_gradiente_style",
                text=tr("gradiente_style"),
                default=0,
                items=gradient_style_items,
                icon="menu_tag_edit"
            ),
            Selector(
                key="visual_avancado_gradiente_direction",
                text=tr("gradiente_direction"),
                default=0,
                items=gradient_direction_items,
                icon="msg_call_minimize"
            ),
            Selector(
                key="visual_avancado_gradiente_intensity",
                text=tr("gradiente_intensity"),
                default=1,
                items=gradient_intensity_items,
                icon="menu_edit_appearance_remix"
            ),
            Selector(
                key="visual_avancado_color_extraction",
                text=tr("gradiente_color_extraction"),
                default=0,
                items=color_extraction_items,
                icon="ic_colorpicker_solar"
            ),
            Divider(text=tr("cores_personalizadas_section")),
            Input(
                key="visual_avancado_gradiente_cor1",
                text=tr("gradiente_cor1"),
                default="#FF6B6B",
                icon="msg_edit_solar"
            ),
            Input(
                key="visual_avancado_gradiente_cor2",
                text=tr("gradiente_cor2"),
                default="#4ECDC4",
                icon="msg_edit_solar"
            )
        ]

    def _get_service_icon(self, player, use_custom_color=False):
        try:
            # Dicionário de ícones com cores personalizadas
            icon_colors = {
                "spotify": {
                    "normal": "https://i.postimg.cc/MZg52Vkb/spfynow.png",
                    "black": "https://i.postimg.cc/5NzH8DcQ/spfynowblack.png",
                    "white": "https://i.postimg.cc/GmJH5Ymc/spfynowwhite.png"
                },
                "youtube": {
                    "normal": "https://i.postimg.cc/sgrJ1zgM/yt.png",
                    "black": "https://i.postimg.cc/L8MJDvRC/ytblack.png",
                    "white": "https://i.postimg.cc/Twh114qw/ytwhite.png"
                },
                "youtubemusic": {
                    "normal": "https://i.postimg.cc/nhGGDWX0/ytm.png",
                    "black": "https://i.postimg.cc/wBq78v1D/ytmblack.png",
                    "white": "https://i.postimg.cc/vm0DQsnk/ytmwhite.png"
                },
                "soundcloud": {
                    "normal": "https://i.postimg.cc/nc7kHrp8/soundcloudicon.png",
                    "black": "https://i.postimg.cc/6qkyDfZQ/soundcloudiconblack.png",
                    "white": "https://i.postimg.cc/7PdGGwRy/soundcloudiconwhite.png"
                },
                "exteragram": {
                    "normal": "https://i.postimg.cc/PfCyRK75/exteragram.png",
                    "black": "https://i.postimg.cc/nL29Cmyd/exteragramblack.png",
                    "white": "https://i.postimg.cc/gjXxSTn5/exteragramwhite.png"
                },
                "ayugram": {
                    "normal": "https://i.postimg.cc/c6qr9dbw/ayugram.png",
                    "black": "https://i.postimg.cc/sX0BJrD7/ayugramblack.png",
                    "white": "https://i.postimg.cc/DZzJsZF7/ayugramwhite.png"
                },
                "applemusic": {
                    "normal": "https://i.postimg.cc/V6ppw48x/applemusic.png",
                    "black": "https://i.postimg.cc/1tf2b2L0/applemusicblack.png",
                    "white": "https://i.postimg.cc/GpM67dSh/applemusicwhite.png"
                },
                "fm": {
                    "normal": self.get_setting("fm_custom_icon_url", ""),
                    "black": self.get_setting("fm_custom_icon_url", ""),
                    "white": self.get_setting("fm_custom_icon_url", "")
                }
            }
            
            # Se usar cor personalizada, verificar configuração
            if use_custom_color:
                icon_color_setting = self.get_setting("customfm_icon_color", 0)
                log(f"[Nowfy] Icon color setting: {icon_color_setting}")
                
                # Usar o Media Source (current_player) configurado pelo usuário
                media_source_player = self._detect_current_player()
                log(f"[Nowfy] Media Source detected: {media_source_player}")
                
                # Mapear o Media Source para a chave do dicionário
                player_lower = media_source_player.lower().replace(" ", "")
                if player_lower == "youtubemusic":
                    current_source = "youtubemusic"
                elif player_lower in ["exteragram", "telegram"]:
                    current_source = "exteragram"
                elif player_lower == "ayugram":
                    current_source = "ayugram"
                elif player_lower == "applemusic":
                    current_source = "applemusic"
                elif player_lower == "fm":
                    current_source = "fm"
                else:
                    current_source = player_lower
                
                log(f"[Nowfy] Media Source: {media_source_player}, Mapped source: {current_source}")
                
                color_options = ["normal", "black", "white"]
                selected_color = color_options[icon_color_setting] if icon_color_setting < len(color_options) else "normal"
                log(f"[Nowfy] Selected color: {selected_color}")
                
                if current_source in icon_colors and selected_color in icon_colors[current_source]:
                    icon_url = icon_colors[current_source][selected_color]
                    log(f"[Nowfy] Using custom color icon for Media Source: {icon_url}")
                    return icon_url
                else:
                    log(f"[Nowfy] Custom color not found for {current_source}/{selected_color}, using fallback")
            
            # Fallback para ícones padrão
            icon_urls = {
                "Spotify": "https://i.postimg.cc/MZg52Vkb/spfynow.png",
                "YouTube": "https://i.postimg.cc/sgrJ1zgM/yt.png",
                "YouTube Music": "https://i.postimg.cc/nhGGDWX0/ytm.png",
                "Telegram": "https://i.postimg.cc/PfCyRK75/exteragram.png",
                "exteraGram": "https://i.postimg.cc/PfCyRK75/exteragram.png",
                "AyuGram": "https://i.postimg.cc/c6qr9dbw/ayugram.png",
                "SoundCloud": "https://i.postimg.cc/nc7kHrp8/soundcloudicon.png",
                "Apple Music": "https://i.postimg.cc/V6ppw48x/applemusic.png",
                "FM": self.get_setting("fm_custom_icon_url", "")
            }
            return icon_urls.get(player)
        except Exception as e:
            print(f"Error getting service icon: {e}")
            return None

    def _get_youtube_cover(self, song_title, artists=''):
        try:
            # Usar chave universal se não houver chave configurada pelo usuário
            youtube_api_key = self.get_setting('youtube_api_key', '') or self._get_universal_youtube_key()
            if not youtube_api_key:
                raise Exception(tr('error_youtube_api_key'))

            search_query = f"{song_title} {artists} official music video"
            # Buscar mais resultados para aumentar a chance de maxresdefault
            search_url = f"https://www.googleapis.com/youtube/v3/search?part=snippet&q={quote(search_query)}&type=video&maxResults=5&key={youtube_api_key}"

            response = requests.get(search_url, timeout=10)
            data = response.json()

            if 'error' in data:
                raise Exception(tr('error_youtube_api').format(data['error'].get('message', tr('error_unknown'))))

            if 'items' in data and data['items']:
                video_ids = [item['id']['videoId'] for item in data['items'] if 'id' in item and 'videoId' in item['id']]
                quality_order = ['maxresdefault', 'hq720', 'sddefault', 'hqdefault', 'mqdefault', 'default']
                # Prioriza a melhor qualidade disponível entre até 5 resultados, validando resolução
                for quality in quality_order:
                    for video_id in video_ids:
                        for base in ["https://img.youtube.com", "https://i.ytimg.com"]:
                            thumb_url = f"{base}/vi/{video_id}/{quality}.jpg"
                            try:
                                # HEAD rápida; se não suportado, tentar GET
                                head_resp = requests.head(thumb_url, timeout=5)
                                if head_resp.status_code != 200:
                                    get_resp = requests.get(thumb_url, timeout=8, stream=True)
                                    if get_resp.status_code != 200:
                                        continue
                                # Validar qualidade real com GET
                                data_resp = requests.get(thumb_url, timeout=8)
                                if data_resp.status_code == 200 and self._is_high_quality_thumbnail(data_resp.content):
                                    return thumb_url
                            except Exception:
                                continue
            # Fallback Nowfy
            return "https://i.postimg.cc/4yjVLFTV/icondefault.png"
        except Exception as e:
            print(tr('error_unknown').format(str(e)))
            if 'quota' in str(e).lower():
                print(tr('error_youtube_quota'))
            return "https://i.postimg.cc/4yjVLFTV/icondefault.png"

    def _get_youtube_thumbnail_forced(self, song_title, artists=''):
        """Busca thumbnails do YouTube priorizando o primeiro resultado (oficial)"""
        try:
            import re
            from urllib.parse import quote_plus
            
            # Limpar e melhorar a query de busca
            clean_title = self._clean_search_term(song_title)
            clean_artist = self._clean_search_term(artists) if artists else ''
            
            # Estratégia SIMPLES: priorizar busca oficial
            if clean_artist:
                # Busca mais precisa: Artista + Título + "official"
                search_query = f"{clean_artist} {clean_title} official"
            else:
                # Sem artista: Título + "official"
                search_query = f"{clean_title} official"
            
            headers = {
                'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36'
            }
            
            try:
                search_url = f"https://www.youtube.com/results?search_query={quote_plus(search_query)}"
                log(f"[CustomFM] YouTube search: {search_query}")
                
                response = requests.get(search_url, headers=headers, timeout=10)
                if response.status_code == 200:
                    # Buscar video IDs na página (pegar os primeiros resultados)
                    video_ids = re.findall(r'"videoId":"([a-zA-Z0-9_-]{11})"', response.text)
                    
                    if video_ids:
                        # SEMPRE usar o PRIMEIRO resultado (geralmente é o oficial)
                        video_id = video_ids[0]
                        log(f"[CustomFM] Using FIRST result (official): {video_id}")
                        
                        # Tentar diferentes qualidades com validação de resolução e domínios alternativos
                        quality_order = ['maxresdefault', 'hq720', 'sddefault', 'hqdefault', 'mqdefault', 'default']
                        bases = ["https://img.youtube.com", "https://i.ytimg.com"]
                        for quality in quality_order:
                            for base in bases:
                                thumb_url = f"{base}/vi/{video_id}/{quality}.jpg"
                                try:
                                    # HEAD rápida; se não suportado, tentar GET
                                    head_resp = requests.head(thumb_url, timeout=5)
                                    if head_resp.status_code != 200:
                                        get_resp = requests.get(thumb_url, timeout=8, stream=True)
                                        if get_resp.status_code != 200:
                                            continue
                                    # Validar qualidade real com GET
                                    data_resp = requests.get(thumb_url, timeout=8)
                                    if data_resp.status_code == 200 and self._is_high_quality_thumbnail(data_resp.content):
                                        log(f"[CustomFM] Found YouTube thumbnail: {thumb_url}")
                                        return thumb_url
                                except Exception:
                                    continue
                    
                    # Fallback: tentar busca sem "official"
                    if clean_artist:
                        fallback_query = f"{clean_artist} {clean_title}"
                    else:
                        fallback_query = clean_title
                    
                    fallback_url = f"https://www.youtube.com/results?search_query={quote_plus(fallback_query)}"
                    log(f"[CustomFM] Fallback search: {fallback_query}")
                    
                    fallback_response = requests.get(fallback_url, headers=headers, timeout=10)
                    if fallback_response.status_code == 200:
                        video_ids = re.findall(r'"videoId":"([a-zA-Z0-9_-]{11})"', fallback_response.text)
                        
                        if video_ids:
                            video_id = video_ids[0]  # Primeiro resultado sempre
                            log(f"[CustomFM] Using fallback FIRST result: {video_id}")
                            
                            # Tentar diferentes qualidades com validação e domínios alternativos
                            quality_order = ['maxresdefault', 'hq720', 'sddefault', 'hqdefault', 'mqdefault', 'default']
                            bases = ["https://img.youtube.com", "https://i.ytimg.com"]
                            for quality in quality_order:
                                for base in bases:
                                    thumb_url = f"{base}/vi/{video_id}/{quality}.jpg"
                                    try:
                                        head_resp = requests.head(thumb_url, timeout=5)
                                        if head_resp.status_code != 200:
                                            get_resp = requests.get(thumb_url, timeout=8, stream=True)
                                            if get_resp.status_code != 200:
                                                continue
                                        data_resp = requests.get(thumb_url, timeout=8)
                                        if data_resp.status_code == 200 and self._is_high_quality_thumbnail(data_resp.content):
                                            log(f"[CustomFM] Found fallback thumbnail: {thumb_url}")
                                            return thumb_url
                                    except Exception:
                                        continue
                        
            except Exception as e:
                log(f"[CustomFM] Error in YouTube search: {e}")
            
            log(f"[CustomFM] No YouTube thumbnail found, using icondefault")
            return "https://i.postimg.cc/4yjVLFTV/icondefault.png"
            
        except Exception as e:
            log(f"[CustomFM] Error in forced YouTube thumbnail search: {e}")
            return "https://i.postimg.cc/4yjVLFTV/icondefault.png"

    def _is_lastfm_placeholder_image(self, url):
        """Detecta se a URL de imagem do Last.fm é um placeholder padrão (baixa qualidade)."""
        try:
            if not url:
                return True
            u = str(url).lower()
            # '2a96c' é um hash comum em imagens default do Last.fm; também checar palavras-chaves genéricas
            return ("2a96c" in u) or ("noimage" in u) or ("default" in u and "last" in u)
        except Exception:
            return False

    def _find_best_youtube_match(self, matches, title, artist):
        """Encontra o melhor match do YouTube baseado em relevância"""
        try:
            import re
            
            # Normalizar termos para comparação
            title_lower = title.lower() if title else ''
            artist_lower = artist.lower() if artist else ''
            
            scored_matches = []
            
            for video_id, video_title in matches:
                video_title_lower = video_title.lower()
                score = 0
                
                # Pontuação baseada na presença de termos
                if title_lower and title_lower in video_title_lower:
                    score += 50
                
                if artist_lower and artist_lower in video_title_lower:
                    score += 40
                
                # Bonus para vídeos oficiais
                if any(term in video_title_lower for term in ['official', 'oficial']):
                    score += 20
                
                # Bonus para music videos
                if any(term in video_title_lower for term in ['music video', 'mv', 'clipe']):
                    score += 15
                
                # Penalizar covers, remixes, etc.
                penalty_terms = ['cover', 'remix', 'karaoke', 'instrumental', 'live', 'ao vivo', 'reaction', 'tutorial']
                for term in penalty_terms:
                    if term in video_title_lower:
                        score -= 25
                        break
                
                # Penalizar vídeos muito longos (provavelmente playlists)
                if any(term in video_title_lower for term in ['playlist', 'mix', 'compilation', 'hours', 'horas']):
                    score -= 30
                
                # Bonus para correspondência exata de palavras
                title_words = re.findall(r'\b\w+\b', title_lower)
                video_words = re.findall(r'\b\w+\b', video_title_lower)
                
                matching_words = len(set(title_words) & set(video_words))
                if title_words:
                    word_match_ratio = matching_words / len(title_words)
                    score += int(word_match_ratio * 30)
                
                scored_matches.append((video_id, video_title, score))
            
            # Ordenar por pontuação (maior primeiro)
            scored_matches.sort(key=lambda x: x[2], reverse=True)
            
            # Retornar o melhor match se tiver pontuação positiva
            if scored_matches and scored_matches[0][2] > 0:
                best_match = scored_matches[0]
                log(f"[CustomFM] Best match score: {best_match[2]} for '{best_match[1]}'")
                return (best_match[0], best_match[1])
            
            # Se nenhum match bom, retornar o primeiro da lista original
            if matches:
                log(f"[CustomFM] No good matches, using first result: '{matches[0][1]}'")
                return matches[0]
            
            return None
            
        except Exception as e:
            log(f"[CustomFM] Error in YouTube match filtering: {e}")
            # Fallback para o primeiro resultado
            return matches[0] if matches else None

    def _search_spotify_url(self, title, artist):
        """Busca o link do Spotify para uma música específica"""
        try:
            token = self._get_access_token()
            if not token:
                return None
            
            query = f"{title} {artist}"
            resp = requests.get(
                f"https://api.spotify.com/v1/search?q={query}&type=track&limit=1",
                headers={"Authorization": f"Bearer {token}"},
                timeout=5
            )
            
            if resp.status_code == 200:
                data = resp.json()
                items = data.get("tracks", {}).get("items", [])
                if items:
                    return items[0]["external_urls"]["spotify"]
        except Exception:
            pass
        return None

    def _search_spotify_url_public(self, title, artist):
        try:
            import re
            import requests
            from urllib.parse import quote
            headers = {
                "User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/124.0 Safari/537.36",
                "Accept": "text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,*/*;q=0.8",
            }
            query = f"site:open.spotify.com track {title} {artist}"
            url = f"https://duckduckgo.com/html/?q={quote(query)}"
            resp = requests.get(url, timeout=8, headers=headers)
            if resp.status_code == 200:
                body = resp.text
                m = re.search(r"https://open\.spotify\.com/track/[A-Za-z0-9]+", body)
                if m:
                    return m.group(0)
        except Exception as e:
            log(f"[Nowfy] Public Spotify search failed: {e}")
        return None

    def _get_spotify_oembed_thumbnail(self, spotify_url):
        try:
            import re
            import requests
            from urllib.parse import quote
            headers = {
                "User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/124.0 Safari/537.36",
                "Accept": "application/json,text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8",
            }
            oembed_url = f"https://open.spotify.com/oembed?url={quote(spotify_url)}"
            r = requests.get(oembed_url, timeout=8, headers=headers)
            if r.status_code == 200:
                data = r.json()
                thumb = data.get("thumbnail_url")
                if thumb:
                    return thumb
            # Fallback: parse OG image da página
            page = requests.get(spotify_url, timeout=8, headers=headers)
            if page.status_code == 200:
                m = re.search(r'<meta property="og:image" content="([^"]+)"', page.text)
                if m:
                    return m.group(1)
        except Exception as e:
            log(f"[Nowfy] Spotify oEmbed/OG thumbnail failed: {e}")
        return None

    def _get_spotify_cover_fallback(self, title, artists):
        try:
            primary_artist = artists.split(",")[0].strip() if isinstance(artists, str) else artists
            # Tentar via API com token
            spotify_url = self._search_spotify_url(title, primary_artist)
            if not spotify_url:
                # Tentar via busca pública sem credenciais
                spotify_url = self._search_spotify_url_public(title, primary_artist)
            if spotify_url:
                return self._get_spotify_oembed_thumbnail(spotify_url)
        except Exception as e:
            log(f"[Nowfy] Spotify cover fallback failed: {e}")
        return None

    def get_current_track_etg(self, account):
    # Detecta música tocando no exteraGram/AyuGram usando MediaController"""
        try:
            from org.telegram.messenger import MediaController
            media_controller = MediaController.getInstance()
            playing_song = media_controller.getPlayingMessageObject()

            if playing_song is None or not playing_song.isMusic():
                return None

            title = playing_song.getMusicTitle()
            artist = playing_song.getMusicAuthor()
            duration = playing_song.getDuration()
            progress = media_controller.getPlayingMessageObject().audioProgressSec

            return {
                "title": title,
                "artist": artist,
                "duration": duration,
                "progress": progress,
                "is_playing": True
            }
        except Exception as e:
            log(f"[Nowfy] Error detecting Telegram music: {e}")
            return None

    def get_etg_cover(self, message_object):
        ## Busca capa da música do etg usando múltiplas APIs
        try:
            debug_mode = self.get_setting("artwork_debug", False)
            
            # Verificação segura do objeto de mensagem
            if not message_object or not hasattr(message_object, '__dict__'):
                if debug_mode:
                    log("[Nowfy] No valid message object provided for etg cover")
                return None
                
            # Verificação segura dos métodos necessários
            if not all(hasattr(message_object, attr) for attr in ['getMusicTitle', 'getMusicAuthor']):
                if debug_mode:
                    log("[Nowfy] Message object doesn't have required music methods")
                return None
                
            # Verificação segura do atributo caption (se existir)
            if hasattr(message_object, 'caption'):
                caption = message_object.caption
                if debug_mode:
                    log(f"[Nowfy] Message caption: {caption}")
            
            title = message_object.getMusicTitle()
            artist = message_object.getMusicAuthor()
            
            if debug_mode:
                log(f"[Nowfy] etg music data - Title: '{title}', Artist: '{artist}'")
            
            if not title and not artist:
                if debug_mode:
                    log("[Nowfy] No title or artist found in etg message")
                return None
                
            # Sempre ativar debug para etg covers
            self.set_setting("artwork_debug", True)
            result = self._search_music_artwork(artist, title)
            log(f"[Nowfy] etg cover search completed. Result: {'Found' if result else 'Not found'}")
            return result
            
        except Exception as e:
            log(f"[Nowfy] Error getting etg cover: {e}")
            return None

    def get_soundcloud_cover(self, title, artist):
        """Busca a capa da música no SoundCloud usando múltiplas estratégias avançadas."""
        try:
            import re
            import requests
            from secrets import choice
            import json
            import time
            from urllib.parse import quote, unquote
            
            # User agents mais variados e atualizados para evitar bloqueios
            user_agents = [
                'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36',
                'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/119.0.0.0 Safari/537.36',
                'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36',
                'Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:121.0) Gecko/20100101 Firefox/121.0',
                'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/17.2 Safari/605.1.15',
                'Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36'
            ]
            
            # Headers mais realistas
            headers = {
                'User-Agent': choice(user_agents),
                'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8',
                'Accept-Language': 'en-US,en;q=0.9,pt;q=0.8',
                'Accept-Encoding': 'gzip, deflate, br',
                'DNT': '1',
                'Connection': 'keep-alive',
                'Upgrade-Insecure-Requests': '1',
                'Sec-Fetch-Dest': 'document',
                'Sec-Fetch-Mode': 'navigate',
                'Sec-Fetch-Site': 'none',
                'Sec-Fetch-User': '?1',
                'Cache-Control': 'max-age=0'
            }
            
            # Limpar e normalizar termos de busca
            clean_title = self._clean_search_term(title) if hasattr(self, '_clean_search_term') else title
            clean_artist = self._clean_search_term(artist) if hasattr(self, '_clean_search_term') else artist
            
            # Múltiplas variações de busca para aumentar chances de sucesso
            search_queries = [
                f"{clean_title} {clean_artist}",
                f"{clean_artist} {clean_title}",
                f'"{clean_title}" "{clean_artist}"',
                f"{clean_title}",
                f"{clean_artist} - {clean_title}",
                f"{clean_title} by {clean_artist}"
            ]
            
            log(f"[Nowfy] Advanced SoundCloud search starting for: {title} by {artist}")
            
            for i, search_query in enumerate(search_queries):
                try:
                    log(f"[Nowfy] SoundCloud search attempt {i+1}: {search_query}")
                    
                    # Estratégia 1: Busca direta no SoundCloud com retry
                    search_url = f"https://soundcloud.com/search?q={quote(search_query)}"
                    
                    # Adicionar delay entre requests para evitar rate limiting
                    if i > 0:
                        time.sleep(0.5)
                    
                    resp = requests.get(search_url, timeout=15, headers=headers)
                    
                    if resp.status_code == 200:
                        # Padrões mais robustos e específicos para encontrar tracks
                        track_patterns = [
                            r'"permalink_url":"(https://soundcloud\.com/[^/]+/[^"]+)"',
                            r'href="(https://soundcloud\.com/[^/]+/[^"]+)"',
                            r'"uri":"(https://soundcloud\.com/[^/]+/[^"]+)"',
                            r'<a[^>]*href="(https://soundcloud\.com/[^/]+/[^"]+)"[^>]*>',
                            r'soundcloud\.com/([^/]+)/([^"\s]+)'
                        ]
                        
                        track_urls = []
                        for pattern in track_patterns:
                            matches = re.findall(pattern, resp.text, re.IGNORECASE)
                            for match in matches:
                                if isinstance(match, tuple):
                                    url = f"https://soundcloud.com/{match[0]}/{match[1]}"
                                else:
                                    url = match
                                
                                # Filtrar URLs válidas (não de usuários, playlists ou páginas especiais)
                                if (url not in track_urls and 
                                    '/sets/' not in url and 
                                    '/likes' not in url and 
                                    '/tracks' not in url and
                                    '/following' not in url and
                                    '/followers' not in url and
                                    url.count('/') >= 4):
                                    track_urls.append(url)
                        
                        # Tentar cada URL encontrada
                        for track_url in track_urls[:3]:  # Limitar a 3 tentativas por busca
                            try:
                                log(f"[Nowfy] Processing SoundCloud track: {track_url}")
                                
                                # Estratégia 2: oEmbed API (mais confiável)
                                oembed_url = f"https://soundcloud.com/oembed?format=json&url={quote(track_url)}"
                                oembed_resp = requests.get(oembed_url, timeout=10, headers=headers)
                                
                                if oembed_resp.status_code == 200:
                                    try:
                                        data = oembed_resp.json()
                                        thumbnail_url = data.get("thumbnail_url")
                                        
                                        if thumbnail_url and 'default_avatar' not in thumbnail_url:
                                            # Múltiplas tentativas de qualidade
                                            quality_variants = [
                                                thumbnail_url.replace('-large.jpg', '-t500x500.jpg'),
                                                thumbnail_url.replace('-large.jpg', '-original.jpg'),
                                                thumbnail_url.replace('-large.jpg', '-crop.jpg'),
                                                thumbnail_url.replace('-large.jpg', '-t300x300.jpg'),
                                                thumbnail_url
                                            ]
                                            
                                            for variant in quality_variants:
                                                try:
                                                    test_resp = requests.head(variant, timeout=5)
                                                    if test_resp.status_code == 200:
                                                        log(f"[Nowfy] SoundCloud cover found via oEmbed: {variant}")
                                                        return variant
                                                except:
                                                    continue
                                    except json.JSONDecodeError:
                                        pass
                                
                                # Estratégia 3: Scraping avançado da página do track
                                track_resp = requests.get(track_url, timeout=12, headers=headers)
                                if track_resp.status_code == 200:
                                    content = track_resp.text
                                    
                                    # Múltiplos padrões para artwork
                                    artwork_patterns = [
                                        r'"artwork_url":"([^"]+)"',
                                        r'<meta property="og:image" content="([^"]+)"',
                                        r'<meta name="twitter:image" content="([^"]+)"',
                                        r'"avatar_url":"([^"]+)"',
                                        r'artwork_url":\s*"([^"]+)"',
                                        r'image":\s*"([^"]+)"',
                                        r'"large":"([^"]+)"'
                                    ]
                                    
                                    for pattern in artwork_patterns:
                                        matches = re.findall(pattern, content, re.IGNORECASE)
                                        for match in matches:
                                            artwork_url = match.replace('\\/', '/')
                                            if (artwork_url and 
                                                'default_avatar' not in artwork_url and
                                                'avatars-000' not in artwork_url and
                                                artwork_url.startswith('http')):
                                                
                                                # Tentar diferentes qualidades
                                                quality_variants = [
                                                    artwork_url.replace('-large.jpg', '-t500x500.jpg'),
                                                    artwork_url.replace('-large.jpg', '-original.jpg'),
                                                    artwork_url.replace('-large.jpg', '-crop.jpg'),
                                                    artwork_url.replace('-large.jpg', '-t300x300.jpg'),
                                                    artwork_url
                                                ]
                                                
                                                for variant in quality_variants:
                                                    try:
                                                        test_resp = requests.head(variant, timeout=5)
                                                        if test_resp.status_code == 200:
                                                            log(f"[Nowfy] SoundCloud cover found via scraping: {variant}")
                                                            return variant
                                                    except:
                                                        continue
                                    
                                    # Estratégia 4: Buscar dados JSON embutidos (hydration data)
                                    json_patterns = [
                                        r'window\.__sc_hydration\s*=\s*(\[.*?\]);',
                                        r'__INITIAL_STATE__\s*=\s*({.*?});',
                                        r'window\.__INITIAL_DATA__\s*=\s*({.*?});'
                                    ]
                                    
                                    for json_pattern in json_patterns:
                                        json_matches = re.findall(json_pattern, content, re.DOTALL)
                                        for json_match in json_matches:
                                            try:
                                                if json_match.startswith('['):
                                                    hydration_data = json.loads(json_match)
                                                    if isinstance(hydration_data, list):
                                                        for item in hydration_data:
                                                            if isinstance(item, dict):
                                                                artwork_url = self._extract_artwork_from_json(item)
                                                                if artwork_url:
                                                                    log(f"[Nowfy] SoundCloud cover found via JSON hydration: {artwork_url}")
                                                                    return artwork_url
                                                else:
                                                    initial_data = json.loads(json_match)
                                                    artwork_url = self._extract_artwork_from_json(initial_data)
                                                    if artwork_url:
                                                        log(f"[Nowfy] SoundCloud cover found via JSON initial data: {artwork_url}")
                                                        return artwork_url
                                            except (json.JSONDecodeError, KeyError):
                                                continue
                                
                            except Exception as e:
                                log(f"[Nowfy] Error processing track URL {track_url}: {e}")
                                continue
                    
                    elif resp.status_code == 429:  # Rate limited
                        log(f"[Nowfy] Rate limited, waiting before retry...")
                        time.sleep(2)
                        continue
                        
                except Exception as e:
                    log(f"[Nowfy] Search query {i+1} failed: {e}")
                    continue
            
            # Estratégia 5: Fallback para API alternativa
            try:
                log(f"[Nowfy] Trying SoundCloud API fallback...")
                api_search_url = f"https://api-v2.soundcloud.com/search?q={quote(search_queries[0])}&client_id=YOUR_CLIENT_ID"
                # Nota: Seria necessário um client_id válido para esta estratégia funcionar completamente
                # Por enquanto, apenas logamos a tentativa
                log(f"[Nowfy] API fallback would use: {api_search_url}")
            except Exception as e:
                log(f"[Nowfy] API fallback failed: {e}")
                
            log(f"[Nowfy] No SoundCloud cover found after all strategies for: {title} by {artist}")
            return None
                
        except Exception as e:
            log(f"[Nowfy] Critical error in SoundCloud cover search: {e}")
            return None

    def _extract_artwork_from_json(self, data):
        """Extrai artwork URL de dados JSON complexos do SoundCloud"""
        try:
            if isinstance(data, dict):
                # Procurar por chaves relacionadas a artwork
                artwork_keys = ['artwork_url', 'avatar_url', 'image', 'thumbnail_url', 'cover_url']
                for key in artwork_keys:
                    if key in data and data[key]:
                        url = data[key]
                        if isinstance(url, str) and url.startswith('http') and 'default_avatar' not in url:
                            # Tentar melhorar qualidade preferindo original, depois t500
                            try:
                                if '-large.jpg' in url:
                                    quality_variants = [
                                        url.replace('-large.jpg', '-original.jpg'),
                                        url.replace('-large.jpg', '-t500x500.jpg'),
                                        url.replace('-large.jpg', '-crop.jpg'),
                                        url.replace('-large.jpg', '-t300x300.jpg'),
                                        url
                                    ]
                                else:
                                    quality_variants = [url]
                                for variant in quality_variants:
                                    try:
                                        test_resp = requests.head(variant, timeout=5)
                                        if test_resp.status_code == 200:
                                            return variant
                                    except Exception:
                                        continue
                            except Exception:
                                pass
                            return url
                
                # Busca recursiva em objetos aninhados
                for value in data.values():
                    if isinstance(value, (dict, list)):
                        result = self._extract_artwork_from_json(value)
                        if result:
                            return result
                            
            elif isinstance(data, list):
                for item in data:
                    result = self._extract_artwork_from_json(item)
                    if result:
                        return result
                        
        except Exception as e:
            log(f"[Nowfy] Error extracting artwork from JSON: {e}")
        
        return None

    def _search_music_artwork(self, artist, title):
        try:
            debug_mode = self.get_setting("artwork_debug", False)
            clean_artist = self._clean_search_term(artist)
            clean_title = self._clean_search_term(title)
            if debug_mode:
                log(f"[Nowfy] Original data - Title: '{title}', Artist: '{artist}'")
                log(f"[Nowfy] Cleaned data - Title: '{clean_title}', Artist: '{clean_artist}'")
            # Reserved:
            player = self._detect_current_player() if hasattr(self, '_detect_current_player') else None
            if player == "SoundCloud":
                # Usar a função específica do SoundCloud primeiro
                soundcloud_cover_url = self.get_soundcloud_cover(clean_title, clean_artist)
                if soundcloud_cover_url and "icondefault.png" not in soundcloud_cover_url:
                    try:
                        resp = requests.get(soundcloud_cover_url, timeout=10)
                        resp.raise_for_status()
                        return Image.open(BytesIO(resp.content)).convert("RGBA")
                    except Exception as e:
                        log(f"[Nowfy] Erro ao carregar capa do SoundCloud: {e}")
                
                # Fallback para YouTube apenas se SoundCloud falhar
                youtube_cover_url = self._get_youtube_cover(clean_title, clean_artist)
                if youtube_cover_url == "https://i.postimg.cc/4yjVLFTV/icondefault.png":
                    youtube_cover_url = self._get_youtube_thumbnail_forced(clean_title, clean_artist)
                if youtube_cover_url and "icondefault.png" not in youtube_cover_url:
                    try:
                        resp = requests.get(youtube_cover_url, timeout=10)
                        resp.raise_for_status()
                        return Image.open(BytesIO(resp.content)).convert("RGBA")
                    except Exception:
                        pass
            search_strategies = [
                (clean_title, clean_artist),
                (f"{clean_title} {clean_artist}", ""),
                (clean_title, ""),
                (clean_artist, clean_title),
            ]
            # APIs na ordem do selector
            apis = [
                ("Spotify", self._search_spotify_artwork),
                ("Deezer", self._search_deezer_artwork),
                ("iTunes", self._search_itunes_artwork),
                ("YouTube", lambda a, t: self._get_youtube_cover(t, a)),
                ("LastFM", self._search_lastfm_artwork),
                ("Cover Art Archive", self._search_coverart_archive)
            ]
            priority = self.get_setting("artwork_priority", 0)
            if debug_mode:
                log(f"[Nowfy] Priority API: {apis[priority][0]} (index: {priority})")
            # Tenta a API de prioridade
            priority_api = apis[priority]
            for title_search, artist_search in search_strategies:
                if debug_mode:
                    log(f"[Nowfy] Trying {priority_api[0]} with: '{title_search}' by '{artist_search}'")
                if priority_api[0] == "YouTube":
                    yt_cover_url = priority_api[1](artist_search, title_search)
                    if yt_cover_url and "icondefault.png" not in yt_cover_url:
                        try:
                            yt_resp = requests.get(yt_cover_url, timeout=5)
                            yt_resp.raise_for_status()
                            return Image.open(BytesIO(yt_resp.content)).convert("RGBA")
                        except Exception as e:
                            if debug_mode:
                                log(f"[Nowfy] YouTube artwork failed: {e}")
                else:
                    cover = priority_api[1](artist_search, title_search)
                    if cover:
                        log(f"[Nowfy] Found artwork using {priority_api[0]} with strategy: '{title_search}' by '{artist_search}'")
                        return cover
            # Tenta as demais em ordem
            for i, (api_name, api_func) in enumerate(apis):
                if i != priority:
                    if debug_mode:
                        log(f"[Nowfy] Trying fallback API: {api_name}")
                    for title_search, artist_search in search_strategies:
                        if debug_mode:
                            log(f"[Nowfy] Trying {api_name} with: '{title_search}' by '{artist_search}'")
                        if api_name == "YouTube":
                            yt_cover_url = api_func(artist_search, title_search)
                            if yt_cover_url and "icondefault.png" not in yt_cover_url:
                                try:
                                    yt_resp = requests.get(yt_cover_url, timeout=5)
                                    yt_resp.raise_for_status()
                                    return Image.open(BytesIO(yt_resp.content)).convert("RGBA")
                                except Exception as e:
                                    if debug_mode:
                                        log(f"[Nowfy] YouTube artwork failed: {e}")
                        else:
                            cover = api_func(artist_search, title_search)
                            if cover:
                                log(f"[Nowfy] Found artwork using {api_name} with strategy: '{title_search}' by '{artist_search}'")
                                return cover
            log(f"[Nowfy] No artwork found for any API, using default")
            return self._get_default_artwork()
        except Exception as e:
            log(f"[Nowfy] Error in _search_music_artwork: {e}")
            return self._get_default_artwork()

    def _clean_search_term(self, term):
        """Limpa e normaliza termos de busca preservando colaborações"""
        if not term:
            return ""    
        # Remove caracteres especiais e normaliza
        import re      
        # Remove parênteses e conteúdo dentro deles (remastered, live, etc)
        term = re.sub(r'\([^)]*\)', '', term)       
        # Remove colchetes e conteúdo dentro deles
        term = re.sub(r'\[[^\]]*\]', '', term)       
        # Remove apenas palavras que realmente interferem (NÃO remover feat/ft/featuring)
        common_words = ['remastered', 'remaster', 'live', 'version', 'edit', 'mix']
        for word in common_words:
            term = re.sub(rf'\b{word}\b', '', term, flags=re.IGNORECASE)       
        # Normalizar feat/ft/featuring para formato padrão
        term = re.sub(r'\b(feat\.?|ft\.?|featuring)\b', 'feat', term, flags=re.IGNORECASE)
        # Remove caracteres especiais mas mantém espaços, hífens e pontos
        term = re.sub(r'[^\w\s\-\.]', '', term)       
        # Remove espaços extras
        term = re.sub(r'\s+', ' ', term).strip()       
        # Remove hífens e pontos isolados (mas não os que estão entre palavras)
        term = re.sub(r'\s*[-\.]\s*', ' ', term)       
        # Remove espaços extras novamente
        term = re.sub(r'\s+', ' ', term).strip()
        
        return term

    def _search_spotify_artwork(self, artist, title):
        """Busca capa no Spotify com melhor processamento"""
        try:
            token = self._get_access_token()
            if not token:
                return None               
            # Constrói query baseada nos parâmetros disponíveis
            if artist and title:
                query = f"{title} {artist}"
            elif title:
                query = title
            else:
                return None
                
            log(f"[Nowfy] Searching Spotify for: {query}")
            
            response = requests.get(
                f"https://api.spotify.com/v1/search?q={query}&type=track&limit=3",
                headers={"Authorization": f"Bearer {token}"},
                timeout=5
            )
            
            if response.status_code == 200:
                data = response.json()
                items = data.get("tracks", {}).get("items", [])
                
                for item in items:
                    if item.get("album", {}).get("images"):
                        # Pega a imagem de maior resolução
                        images = item["album"]["images"]
                        best_image = max(images, key=lambda x: x.get("width", 0))
                        
                        log(f"[Nowfy] Found Spotify artwork: {best_image['url']}")
                        
                        art_response = requests.get(best_image["url"], timeout=3)
                        art_response.raise_for_status()
                        return Image.open(BytesIO(art_response.content)).convert("RGBA")
        except Exception as e:
            log(f"[Nowfy] Error fetching Spotify artwork: {e}")
        return None

    def _search_deezer_artwork(self, artist, title):
        """Busca capa no Deezer com melhor processamento"""
        try:
            # Constrói query baseada nos parâmetros disponíveis
            if artist and title:
                query = f"{title} {artist}"
            elif title:
                query = title
            else:
                return None
                
            log(f"[Nowfy] Searching Deezer for: {query}")
            
            response = requests.get(
                "https://api.deezer.com/search",
                params={"q": query, "limit": 3},
                timeout=3
            )
            response.raise_for_status()
            data = response.json()
            
            if data.get("data") and len(data["data"]) > 0:
                for track in data["data"]:
                    if track.get("album", {}).get("cover_xl"):
                        cover_url = track["album"]["cover_xl"]
                        log(f"[Nowfy] Found Deezer artwork: {cover_url}")
                        
                        art_response = requests.get(cover_url, timeout=3)
                        art_response.raise_for_status()
                        return Image.open(BytesIO(art_response.content)).convert("RGBA")
        except Exception as e:
            log(f"[Nowfy] Error fetching Deezer artwork: {e}")
        return None

    def _search_itunes_artwork(self, artist, title):
        """Busca capa no iTunes com melhor processamento"""
        try:
            # Constrói query baseada nos parâmetros disponíveis
            if artist and title:
                search_term = f"{artist} {title}"
            elif title:
                search_term = title
            else:
                return None
                
            log(f"[Nowfy] Searching iTunes for: {search_term}")
            
            response = requests.get(
                "https://itunes.apple.com/search",
                params={"term": search_term, "entity": "song", "limit": 3},
                timeout=3
            )
            response.raise_for_status()
            data = response.json()
            
            if data['resultCount'] > 0:
                for result in data['results']:
                    if result.get('artworkUrl100'):
                        artwork_url = result['artworkUrl100'].replace('100x100', '600x600')
                        log(f"[Nowfy] Found iTunes artwork: {artwork_url}")
                        
                        art_response = requests.get(artwork_url, timeout=3)
                        art_response.raise_for_status()
                        return Image.open(BytesIO(art_response.content)).convert("RGBA")
        except Exception as e:
            log(f"[Nowfy] Error fetching iTunes artwork: {e}")
        return None

    def _search_lastfm_artwork(self, artist, title):
        """Busca capa no LastFM com melhor processamento"""
        try:
            api_key = self.get_setting("lastfm_api_key", "")
            if not api_key:
                return None              
            # Constrói query baseada nos parâmetros disponíveis
            if artist and title:
                search_term = f"{title} {artist}"
            elif title:
                search_term = title
            else:
                return None
                
            log(f"[Nowfy] Searching LastFM for: {search_term}")
            
            response = requests.get(
                "http://ws.audioscrobbler.com/2.0/",
                params={
                    "method": "track.search",
                    "track": title,
                    "artist": artist,
                    "api_key": api_key,
                    "format": "json",
                    "limit": 3
                },
                timeout=3
            )
            response.raise_for_status()
            data = response.json()
            
            if data.get("results", {}).get("trackmatches", {}).get("track"):
                tracks = data["results"]["trackmatches"]["track"]
                for track in tracks:
                    if track.get("image") and len(track["image"]) > 0:
                        # Pega a imagem de maior tamanho (extralarge)
                        for img in track["image"]:
                            if img.get("size") == "extralarge" and img.get("#text"):
                                cover_url = img["#text"]
                                if cover_url and cover_url != "":
                                    log(f"[Nowfy] Found LastFM artwork: {cover_url}")
                                    art_response = requests.get(cover_url, timeout=3)
                                    art_response.raise_for_status()
                                    return Image.open(BytesIO(art_response.content)).convert("RGBA")
        except Exception as e:
            log(f"[Nowfy] Error fetching LastFM artwork: {e}")
        return None

    def _search_coverart_archive(self, artist, title):
        """Busca capa no Cover Art Archive com melhor processamento"""
        try:
            # Constrói query baseada nos parâmetros disponíveis
            if artist and title:
                query = f"{title} AND artist:{artist}"
            elif title:
                query = title
            else:
                return None
                
            log(f"[Nowfy] Searching Cover Art Archive for: {query}")
            
            # Primeiro busca o release no MusicBrainz
            response = requests.get(
                "https://musicbrainz.org/ws/2/release",
                params={
                    "query": query,
                    "fmt": "json",
                    "limit": 3
                },
                headers={"User-Agent": "Nowfy/1.0"},
                timeout=3
            )
            response.raise_for_status()
            data = response.json()
            
            if data.get("releases") and len(data["releases"]) > 0:
                for release in data["releases"]:
                    release_id = release["id"]
                    # Agora busca a capa no Cover Art Archive (experimental)
                    cover_response = requests.get(
                        f"https://coverartarchive.org/release/{release_id}/front-500",
                        timeout=3
                    )
                    if cover_response.status_code == 200:
                        log(f"[Nowfy] Found Cover Art Archive artwork for release: {release_id}")
                        return Image.open(BytesIO(cover_response.content)).convert("RGBA")
        except Exception as e:
            log(f"[Nowfy] Error fetching Cover Art Archive: {e}")
        return None

    def _get_default_artwork(self):
        """Retorna uma capa padrão quando não consegue encontrar"""
        try:
            # Cria uma capa padrão com gradiente e ícone de música
            size = 600
            img = Image.new("RGBA", (size, size), (0, 0, 0, 0))
            draw = ImageDraw.Draw(img)
            
            # Gradiente de fundo
            for y in range(size):
                alpha = int(255 * (1 - y / size))
                color = (40, 40, 40, alpha)
                draw.line([(0, y), (size, y)], fill=color)
            
            # Ícone de música simples
            icon_size = size // 3
            icon_x = (size - icon_size) // 2
            icon_y = (size - icon_size) // 2
            
            # Desenha um ícone de música estilizado
            draw.ellipse([icon_x, icon_y, icon_x + icon_size, icon_y + icon_size], 
                        fill=(100, 100, 100, 180), outline=(150, 150, 150, 255), width=3)
            
            # Notas musicais
            note_size = icon_size // 4
            draw.ellipse([icon_x + icon_size//3, icon_y + icon_size//3, 
                         icon_x + icon_size//3 + note_size, icon_y + icon_size//3 + note_size], 
                        fill=(200, 200, 200, 255))
            
            return img
        except Exception as e:
            log(f"[Nowfy] Error creating default artwork: {e}")
            return Image.new("RGBA", (600, 600), (50, 50, 50, 255))

    def test_artwork_search(self, title, artist):
        """Função para testar o sistema de busca de capas (debug)"""
        try:
            log(f"[Nowfy] Testing artwork search for: '{title}' by '{artist}'")
            result = self._search_music_artwork(artist, title)
            if result:
                log(f"[Nowfy] Artwork found successfully")
                return True
            else:
                log(f"[Nowfy] No artwork found")
                return False
        except Exception as e:
            log(f"[Nowfy] Error testing artwork search: {e}")
            return False

    def _test_lastfm_account(self):
        """Testa se a conta LastFM está funcionando e mostra última música"""
        try:
            from ui.alert import AlertDialogBuilder
            fragment = get_last_fragment()
            ctx = fragment.getParentActivity() if fragment and fragment.getParentActivity() else ApplicationLoader.applicationContext
            
            # Verificar se username está configurado
            lastfm_username = self.get_setting("lastfm_username", "")
            if not lastfm_username:
                lastfm_username = self.get_setting("lastfm_user", "")
            if not lastfm_username:
                builder = AlertDialogBuilder(ctx)
                builder.set_title(tr("lastfm_test_title"))
                builder.set_message(tr("lastfm_username_not_configured"))
                builder.set_positive_button("OK", None)
                builder.show()
                return
            
            # Mostrar dialog de loading
            builder = AlertDialogBuilder(ctx)
            builder.set_title(tr("lastfm_testing"))
            builder.set_message(tr("lastfm_checking_account").format(username=lastfm_username))
            builder.set_positive_button(tr("cancel"), None)
            dialog = builder.show()
            
            # Executar teste em background
            def run_test():
                try:
                    # Buscar informações do usuário
                    user_info = self._get_lastfm_user_info(lastfm_username)
                    if not user_info:
                        run_on_ui_thread(lambda: self._show_lastfm_test_result(False, lastfm_username, tr("lastfm_api_connection_error")))
                        return
                    
                    # Buscar última música ouvida
                    recent_tracks = self._get_lastfm_recent_tracks(lastfm_username, 1)
                    if not recent_tracks:
                        run_on_ui_thread(lambda: self._show_lastfm_test_result(False, lastfm_username, tr("lastfm_recent_tracks_error")))
                        return
                    
                    # Buscar música atual (se estiver tocando)
                    current_track = self._get_lastfm_now_playing(lastfm_username)
                    
                    run_on_ui_thread(lambda: self._show_lastfm_test_result(True, lastfm_username, None, user_info, recent_tracks, current_track))
                    
                except Exception as e:
                    log(f"[Nowfy] LastFM test error: {e}")
                    run_on_ui_thread(lambda: self._show_lastfm_test_result(False, lastfm_username, str(e)))
                finally:
                    run_on_ui_thread(lambda: dialog.dismiss())
            
            import threading
            test_thread = threading.Thread(target=run_test)
            test_thread.start()
            
        except Exception as e:
            log(f"[Nowfy] Error showing LastFM test: {e}")
            BulletinHelper.show_info(tr("error_generic").format(error=str(e)) if "error_generic" in TRANSLATIONS else f"Error: {str(e)}")

    def _get_lastfm_user_info(self, username):
        """Busca informações do usuário LastFM"""
        try:
            api_key = self.get_setting("lastfm_api_key", "")
            if not api_key:
                return None
            
            url = f"http://ws.audioscrobbler.com/2.0/?method=user.getinfo&user={username}&api_key={api_key}&format=json"
            response = requests.get(url, timeout=10)
            
            if response.status_code == 200:
                data = response.json()
                if 'user' in data:
                    return data['user']
            return None
        except Exception as e:
            log(f"[Nowfy] Error getting LastFM user info: {e}")
            return None

    def _get_lastfm_recent_tracks(self, username, limit=1):
        """Busca músicas recentes do usuário LastFM"""
        try:
            api_key = self.get_setting("lastfm_api_key", "")
            if not api_key:
                return None
            
            url = f"http://ws.audioscrobbler.com/2.0/?method=user.getrecenttracks&user={username}&api_key={api_key}&limit={limit}&format=json"
            response = requests.get(url, timeout=10)
            
            if response.status_code == 200:
                data = response.json()
                if 'recenttracks' in data and 'track' in data['recenttracks']:
                    return data['recenttracks']['track']
            return None
        except Exception as e:
            log(f"[Nowfy] Error getting LastFM recent tracks: {e}")
            return None

    def _get_lastfm_now_playing(self, username):
        """Busca música atual do usuário LastFM"""
        try:
            api_key = self.get_setting("lastfm_api_key", "")
            if not api_key:
                return None
            
            url = f"http://ws.audioscrobbler.com/2.0/?method=user.getrecenttracks&user={username}&api_key={api_key}&limit=1&format=json"
            response = requests.get(url, timeout=10)
            
            if response.status_code == 200:
                data = response.json()
                if 'recenttracks' in data and 'track' in data['recenttracks']:
                    tracks = data['recenttracks']['track']
                    if tracks and len(tracks) > 0:
                        track = tracks[0] if isinstance(tracks, list) else tracks
                        # Verificar se está tocando agora
                        if '@attr' in track and 'nowplaying' in track['@attr']:
                            return track
            return None
        except Exception as e:
            log(f"[Nowfy] Error getting LastFM now playing: {e}")
            return None

    def _show_lastfm_test_result(self, success, username, error=None, user_info=None, recent_tracks=None, current_track=None):
        """Mostra resultado do teste LastFM"""
        try:
            from ui.alert import AlertDialogBuilder
            fragment = get_last_fragment()
            ctx = fragment.getParentActivity() if fragment and fragment.getParentActivity() else ApplicationLoader.applicationContext
            
            builder = AlertDialogBuilder(ctx)
            builder.set_title(tr("lastfm_test_result"))
            
            if success:
                # Informações do usuário
                user_name = user_info.get('name', username) if user_info else username
                play_count = user_info.get('playcount', '0') if user_info else '0'
                
                message = tr("lastfm_account_working").format(username=user_name, playcount=play_count)
                
                # Música atual ou última ouvida
                if current_track:
                    track_name = current_track.get('name', 'Unknown')
                    artist_name = current_track.get('artist', {}).get('#text', 'Unknown') if isinstance(current_track.get('artist'), dict) else current_track.get('artist', 'Unknown')
                    
                    message += "\n\n" + tr("lastfm_now_playing").format(track=track_name, artist=artist_name)
                elif recent_tracks:
                    track = recent_tracks[0] if isinstance(recent_tracks, list) else recent_tracks
                    track_name = track.get('name', 'Unknown')
                    artist_name = track.get('artist', {}).get('#text', 'Unknown') if isinstance(track.get('artist'), dict) else track.get('artist', 'Unknown')
                    
                    message += "\n\n" + tr("lastfm_last_played").format(track=track_name, artist=artist_name)
            else:
                error_msg = f"\n{tr('error')}: {error}" if error else ""
                message = tr("lastfm_test_failed").format(username=username, error=error_msg)
            
            builder.set_message(message)
            builder.set_positive_button("OK", None)
            builder.show()
            
        except Exception as e:
            log(f"[Nowfy] Error showing LastFM test result: {e}")
            BulletinHelper.show_info(tr("error_generic").format(error=str(e)) if "error_generic" in TRANSLATIONS else f"Error showing result: {str(e)}")

    # Atualizar lógica de caption e quebra de linha nos temas Default e CustomFM
    def _lastfm_multiline_title(self, draw, text, font, max_width):
        words = text.split()
        lines, current_line = [], ""
        for word in words:
            test_line = current_line + " " + word if current_line else word
            if draw.textbbox((0, 0), test_line, font=font)[2] <= max_width:
                current_line = test_line
            else:
                lines.append(current_line)
                current_line = word
        if current_line:
            lines.append(current_line)
        return lines

    def _get_icondefault_cached(self, mini_cover_size=300):
        """Baixa e cacheia localmente o icondefault.png, retornando o objeto Image."""
        import os
        from PIL import Image, ImageDraw
        from io import BytesIO
        cache_dir = os.path.join(str(ApplicationLoader.getFilesDirFixed()), "nowfy_cache")
        if not os.path.exists(cache_dir):
            os.makedirs(cache_dir)
        cache_path = os.path.join(cache_dir, f"icondefault_{mini_cover_size}.png")
        # Se já existe no cache, carrega
        if os.path.exists(cache_path):
            try:
                return Image.open(cache_path).convert("RGBA")
            except Exception:
                pass
        # Se não existe, baixa e salva
        try:
            img_resp = requests.get("https://i.postimg.cc/4yjVLFTV/icondefault.png", stream=True, timeout=3)
            img_resp.raise_for_status()
            img = Image.open(BytesIO(img_resp.content)).convert("RGBA")
            img = img.resize((mini_cover_size, mini_cover_size), Image.LANCZOS)
            img.save(cache_path)
            return img
        except Exception:
            # Se tudo falhar, cria uma imagem com gradiente ao invés de cor sólida escura
            img = Image.new("RGBA", (mini_cover_size, mini_cover_size), color=(60, 60, 60, 255))
            draw = ImageDraw.Draw(img)
            # Adiciona um gradiente simples
            for i in range(mini_cover_size):
                alpha = int(255 * (1 - i / mini_cover_size) * 0.3)
                color = (80 + i // 4, 80 + i // 4, 80 + i // 4, alpha)
                draw.line([(0, i), (mini_cover_size, i)], fill=color)
            return img

    NO_TRACK_PLAYING = {
        "en": "No track playing on %s",
        "pt": "Nenhuma faixa tocando no %s",
        "es": "Ninguna pista se está reproduciendo en %s",
        "fr": "Aucune piste en cours de lecture sur %s",
        "ru": "Нет воспроизводимой дорожки в %s",
    }

    def _show_no_track_playing_bulletin(self):
        lang = Locale.getDefault().getLanguage()
        player = self._detect_current_player()
        msg = self.NO_TRACK_PLAYING.get(lang, self.NO_TRACK_PLAYING["en"]) % player
        BulletinHelper.show_info(msg)

    def _show_no_spotify_track_bulletin(self):
        """Bulletin específico para quando não há música tocando no Spotify"""
        lang = Locale.getDefault().getLanguage()
        spotify_messages = {
            "pt": "Nenhuma música tocando no Spotify",
            "en": "No track playing on Spotify",
            "es": "Ninguna música reproduciéndose en Spotify",
            "fr": "Aucune musique en cours de lecture sur Spotify",
            "ru": "Нет воспроизводимой музыки в Spotify"
        }
        msg = spotify_messages.get(lang, spotify_messages["en"])
        BulletinHelper.show_info(msg)

    def _build_lastfm_caption(self, player_name, artist, title):
        custom_caption = self.get_setting("custom_footer_text", "")
        caption_parts = []
        
        # Adiciona o custom_caption se existir
        if custom_caption:
            # Processar variáveis {track}, {artist} e {album} no custom caption
            processed_caption = custom_caption.strip()
            if "{track}" in processed_caption or "{artist}" in processed_caption or "{album}" in processed_caption:
                processed_caption = processed_caption.replace("{track}", title or "Unknown Track")
                processed_caption = processed_caption.replace("{artist}", artist or "Unknown Artist")
                processed_caption = processed_caption.replace("{album}", "Unknown Album")  # Last.fm não fornece álbum
            caption_parts.append(processed_caption)
            
        # Adiciona os links dos players
        if player_name == "YouTube":
            search_query = f"{artist} {title} official music video"
            song_link = f"https://www.youtube.com/results?search_query={quote(search_query)}"
            caption_parts.append(f"[YouTube]({song_link})")
        elif player_name == "YouTube Music":
            search_query = f"{artist} {title}"
            song_link = f"https://music.youtube.com/search?q={quote(search_query)}"
            caption_parts.append(f"[YouTube Music]({song_link})")
        elif player_name == "Spotify":
            song_link = f"https://open.spotify.com/search/{artist.replace(' ', '+')}%20{title.replace(' ', '+')}"
            caption_parts.append(f"[Spotify]({song_link})")
        elif player_name == "Apple Music":
            search_query = f"{artist} {title}"
            song_link = f"https://music.apple.com/search?term={quote(search_query)}"
            caption_parts.append(f"[Apple Music]({song_link})")
        # Suporte para outros players
        caption = " • ".join(caption_parts)
        
        # Processar emojis premium (sempre habilitado)
        if caption:
            caption = self._process_premium_emojis(caption)
        
        return caption

    def _process_premium_emojis(self, caption):
        """Processa emojis premium no caption usando a sintaxe [alt text](document_id)"""
        try:
            import re
            from markdown_parser import parse_markdown
          
            # Padrão para detectar emojis premium: [emoji](document_id)
            # Onde document_id é um número longo
            premium_emoji_pattern = r'\[([^\]]+)\]\((\d{10,})\)'
            
            def replace_premium_emoji(match):
                alt_text = match.group(1)
                document_id = match.group(2)
                
                # Retorna a sintaxe de emoji customizado do Telegram
                # Formato: <emoji id="document_id">alt_text</emoji>
                return f'<emoji id="{document_id}">{alt_text}</emoji>'         
            # Substituir todos os emojis premium encontrados
            processed_caption = re.sub(premium_emoji_pattern, replace_premium_emoji, caption)
            
            return processed_caption
            
        except Exception as e:
            log(f"[Nowfy] Erro ao processar emojis premium: {e}")
            # Em caso de erro, retorna o caption original
            return caption

    def get_current_track_etg_only(self, account, params, progress_dialog=None):
        try:
            log(f"[Nowfy] Starting etg-only track fetch...")
            
            # Detectar música do TG
            from org.telegram.messenger import MediaController
            media_controller = MediaController.getInstance()
            playing_song = media_controller.getPlayingMessageObject()
            
            log(f"[Nowfy] Playing song object: {playing_song}")
            
            etg_track = self.get_current_track_etg(account)
            log(f"[Nowfy] etg track data: {etg_track}")
            
            if not etg_track:
                log(f"[Nowfy] No etg track found")
                BulletinHelper.show_info(tr("no_track_playing_generic"))
                return
            
            title = etg_track["title"]
            artist = etg_track["artist"]
            album = etg_track.get("album", "")
            
            log(f"[Nowfy] Using etg track - Title: '{title}', Artist: '{artist}'")
            
            # Buscar capa do Telegram
            etg_cover_image = self.get_etg_cover(playing_song)
            log(f"[Nowfy] etg cover search result: {'Found' if etg_cover_image else 'Not found'}")
            
            # Detectar player (sempre será exteragram/Ayugram)
            player = self.detect_etg_player()
            
            # Atualizar a bio se habilitado
            if self.get_setting("enable_autobio", False):
                autobio_text = self.get_setting("autobio_text", "Now Playing: {track} by {artist}")
                bio = autobio_text.format(track=title, artist=artist)
                run_on_ui_thread(lambda: self._update_bio(bio, show_bulletin=False))
                # Mostrar notificação se habilitada
                if self.get_setting("show_bio_notification", True):
                    if self.get_setting("enable_auto_bio_update", True):
                        BulletinHelper.show_info(tr("bio_updated_short"))
                    else:
                        BulletinHelper.show_info(tr("bio_notification_disabled"))
            
            # Usar o tema configurado
            theme = self.get_setting("theme_selector", 0)
            
            if theme == 3:  # Default (LastFM)
                log(f"[Nowfy] Using Default theme for Telegram")
                return self._get_current_track_lastfm_default(title, artist, album, "", params, progress_dialog, player, None, etg_cover_image)
            elif theme == 4:  # CustomFM
                log(f"[Nowfy] Using CustomFM theme for Telegram")
                return self._get_current_track_lastfm_customfm(title, artist, album, "", params, progress_dialog, player, None, etg_cover_image)
            else:  # Usar Default como fallback
                log(f"[Nowfy] Using Default theme as fallback for Telegram")
                return self._get_current_track_lastfm_default(title, artist, album, "", params, progress_dialog, player, None, etg_cover_image)
                
        except Exception as e:
            BulletinHelper.show_info(tr("error_generic").format(error=str(e)) if "error_generic" in TRANSLATIONS else f"Telegram error: {str(e)}")

    def detect_etg_player(self):
        # Detecta qual cliente do Telegram está sendo usado"""
        try:
            # Verificar se é exteraGram ou AyuGram baseado no package name
            from org.telegram.messenger import ApplicationLoader
            package_name = ApplicationLoader.applicationContext.getPackageName()
            
            if "exteragram" in package_name.lower():
                return "exteraGram"
            elif "ayugram" in package_name.lower():
                return "AyuGram"
            else:
                return "Telegram"
        except Exception as e:
            log(f"[Nowfy] Error detecting Telegram player: {e}")
            return "Telegram"

    def _show_help(self, params):
        # Mostra a mensagem de ajuda com todos os comandos disponíveis"""
        try:
            def show_dialog():
                fragment = get_last_fragment()
                from ui.alert import AlertDialogBuilder
                ctx = fragment.getParentActivity() if fragment and fragment.getParentActivity() else ApplicationLoader.applicationContext
                builder = AlertDialogBuilder(ctx)
                builder.set_title(tr("help_title"))
                builder.set_message(tr("help_message"))
                builder.set_positive_button("OK", None)
                builder.show()
            run_on_ui_thread(show_dialog)
        except Exception as e:
            log(f"[Nowfy] Error showing help: {e}")
            BulletinHelper.show_info(tr("error_generic").format(error=str(e)) if "error_generic" in TRANSLATIONS else f"Error showing help: {str(e)}")

    def _show_guide_dialog(self):
        try:
            def show_dialog():
                fragment = get_last_fragment()
                from ui.alert import AlertDialogBuilder
                ctx = fragment.getParentActivity() if fragment and fragment.getParentActivity() else ApplicationLoader.applicationContext
                builder = AlertDialogBuilder(ctx, AlertDialogBuilder.ALERT_TYPE_MESSAGE)
                builder.set_title(tr("guide_title"))
                builder.set_message(tr("guide_message"))
                builder.set_positive_button(
                    tr("guide_open_link"),
                    lambda b, w: self._open_url(
                        "https://github.com/soumaki/nowFy/blob/main/guide/nowfy.md#spotify-plugin--step-by-step-login-guide"
                    )
                )
                builder.set_negative_button("OK", None)
                builder.show()
            run_on_ui_thread(show_dialog)
        except Exception as e:
            log(f"[Nowfy] Error showing guide dialog: {e}")

    def _get_fallback_cover(self, title, artists):
        """Obtém uma capa de fallback obrigatória (YouTube thumbnail ou icondefault)"""
        try:
            log(f"[Nowfy] Getting fallback cover for: {title} - {artists}")
            target_size = (298, 298)
            
            # Primeiro, tentar obter thumbnail do YouTube
            youtube_cover_url = self._get_youtube_cover(title, artists)
            # Forçar uso de thumbnails mesmo se a API falhar
            if youtube_cover_url == "https://i.postimg.cc/4yjVLFTV/icondefault.png":
                youtube_cover_url = self._get_youtube_thumbnail_forced(title, artists)
            if youtube_cover_url and youtube_cover_url != "https://i.postimg.cc/4yjVLFTV/icondefault.png":
                try:
                    resp = requests.get(youtube_cover_url, timeout=10)
                    if resp.status_code == 200:
                        cover = Image.open(BytesIO(resp.content)).convert("RGBA")
                        # Aplicar anti-aliasing avançado do Apple UI
                        cover = self._apply_apple_antialiasing(cover, target_size)
                        log(f"[Nowfy] Successfully loaded YouTube fallback cover")
                        return cover
                except Exception as e:
                    log(f"[Nowfy] Error loading YouTube fallback cover: {e}")
            
            # Se YouTube falhar, usar icondefault
            try:
                icondefault_url = "https://i.postimg.cc/4yjVLFTV/icondefault.png"
                resp = requests.get(icondefault_url, timeout=10)
                if resp.status_code == 200:
                    cover = Image.open(BytesIO(resp.content)).convert("RGBA")
                    # Aplicar anti-aliasing avançado do Apple UI
                    cover = self._apply_apple_antialiasing(cover, target_size)
                    log(f"[Nowfy] Successfully loaded icondefault cover")
                    return cover
            except Exception as e:
                log(f"[Nowfy] Error loading icondefault cover: {e}")
            
            return None
        except Exception as e:
            log(f"[Nowfy] Error in _get_fallback_cover: {e}")
            return None

    # ==================== SISTEMA DE BACKUP E RESTAURAÇÃO ====================
    
    def _export_backup(self, params):
        """Exporta as configurações do plugin para um arquivo JSON"""
        try:
            backup_manager = BackupManager(self)
            backup_manager.export_backup()
        except Exception as e:
            log(f"[Nowfy] Error exporting backup: {e}")
            BulletinHelper.show_info(f"{tr('backup_export_error')}: {str(e)}")
    
    def _import_backup(self, params):
        """Importa configurações de um arquivo de backup"""
        try:
            log(f"[Nowfy] _import_backup called - starting backup import process")
            backup_manager = BackupManager(self)
            backup_manager.import_backup()
            log(f"[Nowfy] _import_backup completed successfully")
        except Exception as e:
            log(f"[Nowfy] Error importing backup: {e}")
            import traceback
            log(f"[Nowfy] Traceback: {traceback.format_exc()}")
            BulletinHelper.show_info(f"{tr('backup_import_error')}: {str(e)}")
    
    def _import_backup_with_progress(self, progress_dialog, params):
        """Importa configurações com AlertDialog de progresso de 0 a 100%"""
        try:
            log(f"[Nowfy] Starting import process with progress")
            
            # Etapa 1: Verificar diretório de backup (10%)
            run_on_ui_thread(lambda: progress_dialog.set_progress(10))
            run_on_ui_thread(lambda: progress_dialog.set_message(tr("backup_checking_directory")))
            time.sleep(0.5)
            
            backup_manager = BackupManager(self)
            if not os.path.exists(backup_manager.backup_dir):
                run_on_ui_thread(lambda: progress_dialog.dismiss())
                BulletinHelper.show_info(tr("backup_directory_not_found"))
                return
            
            # Etapa 2: Listar arquivos de backup (20%)
            run_on_ui_thread(lambda: progress_dialog.set_progress(20))
            run_on_ui_thread(lambda: progress_dialog.set_message(tr("backup_listing_files")))
            time.sleep(0.6)
            
            backup_files = self._get_backup_files(backup_manager.backup_dir)
            if not backup_files:
                run_on_ui_thread(lambda: progress_dialog.dismiss())
                BulletinHelper.show_info(tr("backup_no_files_available"))
                return
            
            log(f"[Nowfy] Found {len(backup_files)} backup files")
            
            # Etapa 3: Selecionar backup mais recente (30%)
            run_on_ui_thread(lambda: progress_dialog.set_progress(30))
            run_on_ui_thread(lambda: progress_dialog.set_message(tr("backup_selecting_recent")))
            time.sleep(0.4)
            
            latest_backup = backup_files[0]  # Assumindo que está ordenado
            backup_path = os.path.join(backup_manager.backup_dir, latest_backup)
            
            # Etapa 4: Ler arquivo de backup (40%)
            run_on_ui_thread(lambda: progress_dialog.set_progress(40))
            run_on_ui_thread(lambda: progress_dialog.set_message(tr("backup_reading_file")))
            time.sleep(0.7)
            
            backup_data = self._read_backup_file(backup_path)
            if not backup_data:
                run_on_ui_thread(lambda: progress_dialog.dismiss())
                BulletinHelper.show_info(tr("backup_read_error"))
                return
            
            # Etapa 5: Validar estrutura do backup (50%)
            run_on_ui_thread(lambda: progress_dialog.set_progress(50))
            run_on_ui_thread(lambda: progress_dialog.set_message(tr("backup_validating_structure")))
            time.sleep(0.5)
            
            if not backup_manager.validate_backup_data(backup_data):
                run_on_ui_thread(lambda: progress_dialog.dismiss())
                BulletinHelper.show_info(tr("backup_invalid_structure"))
                return
            
            # Etapa 6: Preparar aplicação das configurações (60%)
            run_on_ui_thread(lambda: progress_dialog.set_progress(60))
            run_on_ui_thread(lambda: progress_dialog.set_message(tr("backup_preparing_import")))
            time.sleep(0.5)
            
            # Etapa 7: Aplicar configurações do backup (70%)
            run_on_ui_thread(lambda: progress_dialog.set_progress(70))
            run_on_ui_thread(lambda: progress_dialog.set_message(tr("backup_applying_settings")))
            time.sleep(0.9)
            
            applied_count = self._apply_backup_settings_with_progress(backup_data, progress_dialog)
            
            # Etapa 8: Verificar configurações aplicadas (85%)
            run_on_ui_thread(lambda: progress_dialog.set_progress(85))
            run_on_ui_thread(lambda: progress_dialog.set_message(tr("backup_verifying_settings")))
            time.sleep(0.6)
            
            self._verify_applied_settings(backup_data)
            
            # Etapa 9: Limpar cache e arquivos temporários (95%)
            run_on_ui_thread(lambda: progress_dialog.set_progress(95))
            run_on_ui_thread(lambda: progress_dialog.set_message(tr("backup_cleaning_cache")))
            time.sleep(0.4)
            
            self._cleanup_temp_files()
            
            # Etapa 10: Concluído (100%)
            run_on_ui_thread(lambda: progress_dialog.set_progress(100))
            run_on_ui_thread(lambda: progress_dialog.set_message(tr("backup_import_completed")))
            time.sleep(0.5)
            
            # Fechar dialog
            run_on_ui_thread(lambda: progress_dialog.dismiss())
            
            # Mostrar resultado
            BulletinHelper.show_info(tr("backup_imported_success"))
            
            log(f"[Nowfy] Import completed successfully: {applied_count} settings applied")
            
        except Exception as e:
            log(f"[Nowfy] Error in import process: {e}")
            run_on_ui_thread(lambda: progress_dialog.dismiss())
            BulletinHelper.show_info(f"{tr('backup_import_error')}: {str(e)}")
    
    def _get_backup_files(self, backup_dir):
        """Lista e ordena arquivos de backup por data de modificação"""
        try:
            files = [f for f in os.listdir(backup_dir) if f.endswith('.json')]
            files.sort(key=lambda x: os.path.getmtime(os.path.join(backup_dir, x)), reverse=True)
            return files
        except Exception as e:
            log(f"[Nowfy] Error listing backup files: {e}")
            return []
    
    def _read_backup_file(self, backup_path):
        """Lê e decodifica arquivo de backup JSON"""
        try:
            with open(backup_path, 'r', encoding='utf-8') as f:
                return json.load(f)
        except Exception as e:
            log(f"[Nowfy] Error reading backup file {backup_path}: {e}")
            return None
    
    
    def _apply_backup_settings_with_progress(self, backup_data, progress_dialog):
        """Aplica configurações do backup com atualização de progresso"""
        try:
            settings = backup_data.get('settings', {})
            applied_count = 0
            total_settings = len(settings)
            
            for i, (key, value) in enumerate(settings.items()):
                try:
                    self.set_setting(key, value)
                    applied_count += 1
                    
                    # Atualizar progresso entre 70% e 80%
                    progress = 70 + int((i + 1) / total_settings * 10)
                    run_on_ui_thread(lambda p=progress: progress_dialog.set_progress(p))
                    
                    if i % 5 == 0:  # Atualizar mensagem a cada 5 configurações
                        run_on_ui_thread(lambda: progress_dialog.set_message(f"Aplicando configurações... ({applied_count}/{total_settings})"))
                    
                except Exception as e:
                    log(f"[Nowfy] Error applying setting {key}: {e}")
            
            return applied_count
        except Exception as e:
            log(f"[Nowfy] Error applying backup settings: {e}")
            return 0
    
    def _verify_applied_settings(self, backup_data):
        """Verifica se as configurações foram aplicadas corretamente"""
        try:
            settings = backup_data.get('settings', {})
            verified_count = 0
            
            for key, expected_value in settings.items():
                try:
                    current_value = self.get_setting(key)
                    if current_value == expected_value:
                        verified_count += 1
                except Exception as e:
                    log(f"[Nowfy] Error verifying setting {key}: {e}")
            
            log(f"[Nowfy] Verified {verified_count}/{len(settings)} settings")
        except Exception as e:
            log(f"[Nowfy] Error verifying settings: {e}")
    
    def _cleanup_temp_files(self):
        """Limpa arquivos temporários e cache"""
        try:
            # Simular limpeza de cache
            log(f"[Nowfy] Cleanup completed")
        except Exception as e:
            log(f"[Nowfy] Error during cleanup: {e}")
     
    def exteraBarSeek_dark_opposite(self, draw, track, progress_ms=None):
        # --- Barra de progresso estilo seekbar no topo da capa (Apple Dark, oposta e ajustada) ---
        bar_width = 260
        bar_height = 5
        bar_x = 70 + (298 - bar_width) // 2
        bar_y = 153 - 30
        duration_ms = track.get("duration_ms", 225000)
        if progress_ms is None:
            progress_ms = 0
        if duration_ms <= 0:
            progress_width = 0
        else:
            progress_width = int((progress_ms / duration_ms) * bar_width)
            progress_width = min(progress_width, bar_width)
        # Barra de fundo (#313a41)
        draw.rounded_rectangle(
            (bar_x, bar_y, bar_x + bar_width, bar_y + bar_height),
            radius=bar_height // 2,
            fill=(49, 58, 65, 255)  # #313a41
        )
        # Barra de progresso (#8e959d)
        draw.rounded_rectangle(
            (bar_x, bar_y, bar_x + progress_width, bar_y + bar_height),
            radius=bar_height // 2,
            fill=(142, 149, 157, 255)  # #8e959d
        )
        # Handle (círculo #8e959d)
        handle_radius = 10
        handle_x = bar_x + progress_width
        handle_y = bar_y + bar_height // 2
        draw.ellipse(
            (handle_x - handle_radius, handle_y - handle_radius, handle_x + handle_radius, handle_y + handle_radius),
            fill=(142, 149, 157, 255)  # #8e959d
        )
        # Tempos (#8e959d)
        # Nota: Esta função só é chamada quando não é Last.FM com Spotify
        if True:  # Sempre mostrar tempos quando a barra é exibida
            def ms_to_minsec(ms):
                m = int(ms // 60000)
                s = int((ms % 60000) // 1000)
                return f"{m}:{s:02d}"
            font = ImageFont.truetype("/system/fonts/SourceSansPro-Regular.ttf", 24)
            time_current = ms_to_minsec(progress_ms)
            time_total = ms_to_minsec(duration_ms)
            # Usar textbbox em vez de getsize (depreciado)
            bbox = draw.textbbox((0, 0), "Ay", font=font)
            text_height = bbox[3] - bbox[1]
            text_y = bar_y + bar_height // 2 - text_height // 2
            
            draw.text((bar_x, text_y - 28), time_current, font=font, fill=(142, 149, 157, 255))  # #8e959d
            
            # Calcular largura do texto do tempo total
            time_total_bbox = draw.textbbox((0, 0), time_total, font=font)
            time_total_width = time_total_bbox[2] - time_total_bbox[0]
            draw.text((bar_x + bar_width - time_total_width, text_y - 28), time_total, font=font, fill=(142, 149, 157, 255))  # #8e959d

    def exteraBarSeek_light_opposite(self, draw, track, progress_ms=None):
        # --- Barra de progresso estilo seekbar no topo da capa (Apple Light, oposta e ajustada) ---
        bar_width = 260
        bar_height = 5
        bar_x = 70 + (298 - bar_width) // 2
        bar_y = 153 - 30
        duration_ms = track.get("duration_ms", 225000)
        if progress_ms is None:
            progress_ms = 0
        if duration_ms <= 0:
            progress_width = 0
        else:
            progress_width = int((progress_ms / duration_ms) * bar_width)
            progress_width = min(progress_width, bar_width)
        # Barra de fundo (cinza claro)
        draw.rounded_rectangle(
            (bar_x, bar_y, bar_x + bar_width, bar_y + bar_height),
            radius=bar_height // 2,
            fill=(180, 180, 180, 255)
        )
        # Barra de progresso (preto)
        draw.rounded_rectangle(
            (bar_x, bar_y, bar_x + progress_width, bar_y + bar_height),
            radius=bar_height // 2,
            fill=(40, 40, 40, 255)
        )
        # Handle (círculo preto)
        handle_radius = 10
        handle_x = bar_x + progress_width
        handle_y = bar_y + bar_height // 2
        draw.ellipse(
            (handle_x - handle_radius, handle_y - handle_radius, handle_x + handle_radius, handle_y + handle_radius),
            fill=(40, 40, 40, 255)
        )
        # Tempos (preto)
        if True:  # Sempre mostrar tempos quando a barra é exibida
            def ms_to_minsec(ms):
                m = int(ms // 60000)
                s = int((ms % 60000) // 1000)
                return f"{m}:{s:02d}"
            font = ImageFont.truetype("/system/fonts/SourceSansPro-Regular.ttf", 24)
            time_current = ms_to_minsec(progress_ms)
            time_total = ms_to_minsec(duration_ms)
            text_y = bar_y + bar_height // 2 - self.get_text_dimensions("Ay", font)[1] // 2
            draw.text((bar_x, text_y - 28), time_current, font=font, fill=(40, 40, 40, 255))
            draw.text((bar_x + bar_width - self.get_text_dimensions(time_total, font)[0], text_y - 28), time_total, font=font, fill=(40, 40, 40, 255))

    def exteraBarSeek_red_opposite(self, draw, track, progress_ms=None):
        # --- Barra de progresso estilo seekbar no topo da capa (Apple Red, oposta e ajustada) ---
        bar_width = 260
        bar_height = 5
        bar_x = 70 + (298 - bar_width) // 2
        bar_y = 153 - 30
        duration_ms = track.get("duration_ms", 225000)
        if progress_ms is None:
            progress_ms = 0
        if duration_ms <= 0:
            progress_width = 0
        else:
            progress_width = int((progress_ms / duration_ms) * bar_width)
            progress_width = min(progress_width, bar_width)
        # Barra de fundo (#bf0a0a)
        draw.rounded_rectangle(
            (bar_x, bar_y, bar_x + bar_width, bar_y + bar_height),
            radius=bar_height // 2,
            fill=(191, 10, 10, 255)  # #bf0a0a
        )
        # Barra de progresso (#ffcfd6)
        draw.rounded_rectangle(
            (bar_x, bar_y, bar_x + progress_width, bar_y + bar_height),
            radius=bar_height // 2,
            fill=(255, 207, 214, 255)  # #ffcfd6
        )
        # Handle (círculo #ffcfd6)
        handle_radius = 10
        handle_x = bar_x + progress_width
        handle_y = bar_y + bar_height // 2
        draw.ellipse(
            (handle_x - handle_radius, handle_y - handle_radius, handle_x + handle_radius, handle_y + handle_radius),
            fill=(255, 207, 214, 255)  # #ffcfd6
        )
        # Tempos (#ffcfd6)
        if True:  # Sempre mostrar tempos quando a barra é exibida
            def ms_to_minsec(ms):
                m = int(ms // 60000)
                s = int((ms % 60000) // 1000)
                return f"{m}:{s:02d}"
            font = ImageFont.truetype("/system/fonts/SourceSansPro-Regular.ttf", 24)
            time_current = ms_to_minsec(progress_ms)
            time_total = ms_to_minsec(duration_ms)
            text_y = bar_y + bar_height // 2 - self.get_text_dimensions("Ay", font)[1] // 2
            draw.text((bar_x, text_y - 28), time_current, font=font, fill=(255, 207, 214, 255))  # #ffcfd6
            draw.text((bar_x + bar_width - self.get_text_dimensions(time_total, font)[0], text_y - 28), time_total, font=font, fill=(255, 207, 214, 255))  # #ffcfd6

    def _list_backups(self, params):
        """Lista todos os backups disponíveis"""
        try:
            backup_manager = BackupManager(self)
            backup_manager.list_backups()
        except Exception as e:
            log(f"[Nowfy] Error listing backups: {e}")
            BulletinHelper.show_info(f"{tr('backup_list_error')}: {str(e)}")


class BackupManager:
    """Gerenciador de backup e restauração de configurações do Nowfy"""
    
    def __init__(self, plugin_instance):
        self.plugin = plugin_instance
        self.backup_dir = "/storage/emulated/0/Android/media/com.exteragram.messenger/nowfy_backups"
        self.ensure_backup_directory()
    
    def ensure_backup_directory(self):
        """Garante que o diretório de backup existe"""
        try:
            import os
            if not os.path.exists(self.backup_dir):
                os.makedirs(self.backup_dir)
                log(f"[Nowfy] Created backup directory: {self.backup_dir}")
        except Exception as e:
            log(f"[Nowfy] Error creating backup directory: {e}")
    
    def get_timestamp(self):
        """Retorna timestamp formatado para nome do arquivo"""
        import datetime
        return datetime.datetime.now().strftime("%Y%m%d_%H%M%S")
    
    def export_backup(self):
        """Exporta todas as configurações para um arquivo JSON"""
        try:
            import json
            import os
            
            # Garantir que o diretório existe
            self.ensure_backup_directory()
            
            # Coletar todas as configurações
            collected_settings = self.collect_all_settings()
            log(f"[Nowfy] Export: Collected {len(collected_settings)} settings: {list(collected_settings.keys())}")
            
            if not collected_settings:
                log(f"[Nowfy] Warning: No settings collected for backup")
                BulletinHelper.show_info(tr('backup_no_files_found'))
                return
            
            backup_data = {
                "version": "1.0.5",
                "timestamp": self.get_timestamp(),
                "plugin_name": "nowfy",
                "settings": collected_settings,
                "total_settings": len(collected_settings)
            }
            
            # Gerar nome do arquivo com timestamp
            filename = f"nowfy_backup_{self.get_timestamp()}.json"
            filepath = os.path.join(self.backup_dir, filename)
            
            # Salvar arquivo
            with open(filepath, 'w', encoding='utf-8') as f:
                json.dump(backup_data, f, indent=2, ensure_ascii=False)
            
            # Verificar se o arquivo foi criado corretamente
            if os.path.exists(filepath):
                file_size = os.path.getsize(filepath)
                log(f"[Nowfy] Backup exported successfully: {filepath} ({file_size} bytes)")
                BulletinHelper.show_info(f"{tr('backup_export_success')} ({len(collected_settings)} {tr('backup_settings_count').lower()})")
            else:
                log(f"[Nowfy] Error: Backup file was not created")
                BulletinHelper.show_info(tr('backup_file_not_found'))
            
        except Exception as e:
            log(f"[Nowfy] Error exporting backup: {e}")
            import traceback
            log(f"[Nowfy] Traceback: {traceback.format_exc()}")
            BulletinHelper.show_info(f"{tr('backup_export_error')}: {str(e)}")
    
    def collect_all_settings(self):
        """Coleta todas as configurações do plugin que possuem inputs do usuário"""
        settings = {}
        
        # Lista de configurações que possuem inputs do usuário (não valores padrão)
        setting_keys = [
            # Credenciais Spotify
            "client_id", "client_secret", "refresh_token",
            
            # Credenciais NowCast
            "nowcast_bot_token", "nowcast_channel_id", "nowcast_enabled",
            "nowcast_link_option", "nowcast_post_interval",
            
            # APIs externas
            "lastfm_user", "lastfm_api_key", "statsfm_username",
            "youtube_api_key", "exteragram_username",
            
            # Configurações de Bio personalizadas
            "autobio_text", "restore_bio_text", "custom_footer_text",
            "bot_caption_text", "original_bio",
            
            # Configurações de tema e aparência personalizadas
            "theme_selector", "font_selector", "custom_command",
            "lastfm_customfm_background_color", "lastfm_customfm_text_color",
            "lastfm_customfm_overlay_url", "customfm_icon_color",
            
            # Configurações de comportamento personalizadas
            "media_source", "current_player", "performance_mode",
            "fm_link_option", "artwork_priority", "lastfm_theme_style",
            "lastfm_customfm_cover_position", "lastfm_customfm_radius",
            
            # Configurações de switches importantes
            "enable_autobio", "enable_auto_bio_update", "show_bio_notification",
            "enable_cache", "enable_compression", "enhanced_cache", "enable_preload",
            "show_credentials", "show_cache_settings", "show_smart_bio_panel",
            "show_diversos", "random_theme_mode", "show_caption", "enable_aurasend_on_send", "enable_quick_dismiss",
            "platform_links", "show_track_link", "enable_premium_emoji",
            "lastfm_customfm_use_background", "lastfm_customfm_blur",
            "lastfm_customfm_darken_background", "lastfm_customfm_use_overlay",
            "lastfm_customfm_bold_text", "show_extera_bar", "vinify_show_device",
            "enable_soundcloud_thumbnail_cache", "enable_quality_fallback",
            "enable_url_cache", "enable_youtube_thumbnail_cache",
            "artwork_debug",
            "lastfm_username",
            "theme_mode", "spotlight_skin",
            "statsfm_device_type",
            "use_song_link", "show_spotify_link",
            "vinify_background_effect", "vinify_colors_effect", "vinify_swap_layout",
            "vinify_device_profile_mode", "vinify_device_name",
            "vinify_bar_color", "vinify_bar_bg_color",
            "vinify_bar_gradient", "vinify_bar_blur",
            "vinify_album_playlist_mode",
            "dynamic_skins_selector",
            "customfm_high_resolution",
            "fm_custom_icon_url", "fm_custom_player_name",
            "visual_avancado_gradiente_enable",
            "visual_avancado_gradiente_modo",
            "visual_avancado_gradiente_style",
            "visual_avancado_gradiente_direction",
            "visual_avancado_gradiente_intensity",
            "visual_avancado_color_extraction",
            "visual_avancado_gradiente_cor1",
            "visual_avancado_gradiente_cor2",
            "apple_skin",
            "apple_antialiasing_quality",
            "apple_resize_algorithm",
            "apple_cover_quality",
            "apple_enhanced_smoothing",
            "apple_edge_enhancement",
            "apple_color_enhancement",
            "apple_cache_processed_covers",
            "apple_async_processing"
        ]
        
        for key in setting_keys:
            try:
                value = self.plugin.get_setting(key, None)
                log(f"[Nowfy] DEBUG: {key} = {value} (type: {type(value)})")
                if value is not None:
                    settings[key] = value
                    log(f"[Nowfy] SAVED: {key} = {value}")
                else:
                    log(f"[Nowfy] SKIPPED: {key} (value is None)")
            except Exception as e:
                log(f"[Nowfy] Error collecting setting {key}: {e}")
        
        return settings
    
    def import_backup(self):
        """Mostra seletor de arquivos de backup para importação"""
        try:
            import os
            
            log(f"[Nowfy] Starting import_backup process")
            log(f"[Nowfy] Backup directory: {self.backup_dir}")
            
            # Listar arquivos de backup disponíveis
            backup_files = []
            if os.path.exists(self.backup_dir):
                all_files = os.listdir(self.backup_dir)
                log(f"[Nowfy] Found {len(all_files)} files in backup directory")
                
                for file in all_files:
                    if file.endswith('.json') and file.startswith('nowfy_backup_'):
                        backup_files.append(file)
                        log(f"[Nowfy] Found backup file: {file}")
            else:
                log(f"[Nowfy] Backup directory does not exist: {self.backup_dir}")
                BulletinHelper.show_info(f"{tr('backup_directory_not_found')}: {self.backup_dir}")
                return
            
            log(f"[Nowfy] Total backup files found: {len(backup_files)}")
            
            if not backup_files:
                log(f"[Nowfy] No backup files found, showing info message")
                BulletinHelper.show_info(f"{tr('backup_no_files_found')}")
                return
            
            # Ordenar por data (mais recente primeiro)
            backup_files.sort(reverse=True)
            log(f"[Nowfy] Backup files sorted: {backup_files}")
            
            # Mostrar seletor de arquivos se houver múltiplos backups
            if len(backup_files) == 1:
                log(f"[Nowfy] Only one backup found, using: {backup_files[0]}")
                BulletinHelper.show_info(f"{tr('backup_using_recent')}: {backup_files[0]}")
                self.restore_from_backup(backup_files[0])
            else:
                log(f"[Nowfy] Multiple backups found, showing selector")
                self.show_backup_selector(backup_files)
            
        except Exception as e:
            log(f"[Nowfy] Error in import_backup: {e}")
            import traceback
            log(f"[Nowfy] Traceback: {traceback.format_exc()}")
            BulletinHelper.show_info(f"{tr('backup_import_error')}: {str(e)}")
    
    def show_backup_selector(self, backup_files):
        """Mostra dialog para seleção de arquivo de backup"""
        try:
            log(f"[Nowfy] show_backup_selector called with {len(backup_files)} files")
            
            fragment = get_last_fragment()
            if not fragment:
                log(f"[Nowfy] Fragment not found in show_backup_selector")
                BulletinHelper.show_info(f"{tr('error_fragment_not_found')}")
                return
            
            ctx = fragment.getParentActivity() if fragment.getParentActivity() else ApplicationLoader.applicationContext
            log(f"[Nowfy] Context obtained: {ctx}")
            
            # Criar lista de opções formatadas
            options = []
            for file in backup_files:
                # Extrair timestamp do nome do arquivo
                try:
                    timestamp_part = file.replace('nowfy_backup_', '').replace('.json', '')
                    # Formatar timestamp para exibição
                    if len(timestamp_part) >= 13:
                        date_part = timestamp_part[:8]
                        time_part = timestamp_part[9:15] if len(timestamp_part) > 8 else timestamp_part[8:14]
                        formatted_date = f"{date_part[:4]}/{date_part[4:6]}/{date_part[6:8]}"
                        formatted_time = f"{time_part[:2]}:{time_part[2:4]}:{time_part[4:6]}"
                        display_name = f"{formatted_date} {formatted_time}"
                    else:
                        display_name = file
                except:
                    display_name = file
                
                options.append(display_name)
            
            def on_backup_selected(index):
                log(f"[Nowfy] Backup selected at index: {index}")
                if 0 <= index < len(backup_files):
                    selected_file = backup_files[index]
                    log(f"[Nowfy] Selected backup file: {selected_file}")
                    self.restore_from_backup(selected_file)
                else:
                    log(f"[Nowfy] Invalid backup index: {index}")
            
            log(f"[Nowfy] About to show backup list dialog with {len(options)} options")
            # Mostrar AlertDialog com lista de backups
            run_on_ui_thread(lambda: self.show_backup_list_dialog(ctx, options, on_backup_selected))
            
        except Exception as e:
            log(f"[Nowfy] Error showing backup selector: {e}")
            BulletinHelper.show_info(f"{tr('backup_list_error')}: {str(e)}")
    
    def show_backup_list_dialog(self, context, options, callback):
        """Mostra dialog com lista de backups"""
        try:
            from org.telegram.ui.ActionBar import AlertDialog, Theme
            from android.graphics.drawable import Drawable
            from java.util import ArrayList

            def show_dialog():
                try:
                    builder = AlertDialog.Builder(context)
                    builder.setTitle(tr('backup_select_title'))
                    
                    # Converter para array Java
                    java_options = ArrayList()
                    for option in options:
                        java_options.add(option)
                    
                    builder.setItems(java_options.toArray(), lambda dialog, which: callback(which))
                    builder.setNegativeButton(f"{tr('backup_cancel')}", None)
                    
                    dialog = builder.create()
                    dialog.show()
                    
                    log(f"[Nowfy] Backup selection dialog shown with {len(options)} options")
                
                except Exception as e:
                    log(f"[Nowfy] Error in show_dialog: {e}")
                    # Fallback para seleção simples
                    if options:
                        log(f"[Nowfy] Using fallback - selecting first backup")
                        callback(0)  # Selecionar o primeiro backup
            
            # Executar na UI thread
            run_on_ui_thread(show_dialog)
        
        except Exception as e:
            log(f"[Nowfy] Error creating backup list dialog: {e}")
            # Fallback para seleção simples
            if options:
                log(f"[Nowfy] Using fallback - selecting first backup")
                callback(0)  # Selecionar o primeiro backup

    
    def restore_from_backup(self, filename):
        """Restaura configurações de um arquivo de backup específico"""
        try:
            import json
            import os
            
            log(f"[Nowfy] restore_from_backup called with filename: {filename}")
            filepath = os.path.join(self.backup_dir, filename)
            log(f"[Nowfy] Full filepath: {filepath}")
            
            if not os.path.exists(filepath):
                log(f"[Nowfy] Backup file not found: {filepath}")
                BulletinHelper.show_info(f"{tr('backup_file_not_found')}: {filename}")
                return
            
            # Ler arquivo de backup
            log(f"[Nowfy] Reading backup file...")
            with open(filepath, 'r', encoding='utf-8') as f:
                backup_data = json.load(f)
            
            log(f"[Nowfy] Backup data loaded successfully")
            
            # Validar estrutura do backup
            if not self.validate_backup_data(backup_data):
                log(f"[Nowfy] Backup validation failed")
                BulletinHelper.show_info(tr('backup_invalid_file'))
                return
            
            log(f"[Nowfy] Backup validation passed, proceeding to confirm restore")
            
            # Confirmar restauração
            self.confirm_restore(backup_data, filename)
            
        except Exception as e:
            log(f"[Nowfy] Error restoring from backup: {e}")
            BulletinHelper.show_info(f"{tr('backup_restore_error')}: {str(e)}")
    
    def validate_backup_data(self, data):
        """Valida a estrutura dos dados de backup"""
        try:
            log(f"[Nowfy] Validating backup data structure")
            
            required_fields = ['version', 'timestamp', 'plugin_name', 'settings']
            for field in required_fields:
                if field not in data:
                    log(f"[Nowfy] Validation failed: Missing field '{field}'")
                    return False
            
            if data.get('plugin_name') != 'nowfy':
                log(f"[Nowfy] Validation failed: Invalid plugin name '{data.get('plugin_name')}'")
                return False
            
            settings = data.get('settings')
            if not isinstance(settings, dict):
                log(f"[Nowfy] Validation failed: Settings is not a dict, type: {type(settings)}")
                return False
            
            if len(settings) == 0:
                log(f"[Nowfy] Validation warning: No settings found in backup")
                return False
            
            log(f"[Nowfy] Backup validation passed: {len(settings)} settings found")
            return True
            
        except Exception as e:
            log(f"[Nowfy] Validation error: {e}")
            return False
    
    def confirm_restore(self, backup_data, filename):
        """Confirma a restauração do backup"""
        try:
            fragment = get_last_fragment()
            if not fragment:
                BulletinHelper.show_info(f"{tr('error_fragment_not_found')}")
                return
            
            ctx = fragment.getParentActivity() if fragment.getParentActivity() else ApplicationLoader.applicationContext
            
            # Informações do backup
            timestamp = backup_data.get('timestamp', tr('unknown'))
            version = backup_data.get('version', tr('unknown'))
            settings_count = len(backup_data.get('settings', {}))
            
            message = f"{tr('backup_confirm_restore')}\n\n{tr('backup_file')}: {filename}\n{tr('backup_date')}: {timestamp}\n{tr('backup_version')}: {version}\n{tr('backup_settings_count')}: {settings_count}\n\n{tr('backup_warning_replace')}"
            
            def on_confirm():
                self.apply_backup_settings(backup_data)
            
            run_on_ui_thread(lambda: self.show_confirmation_dialog(ctx, message, on_confirm))
            
        except Exception as e:
            log(f"[Nowfy] Error in confirm_restore: {e}")
            BulletinHelper.show_info(f"{tr('backup_restore_error')}: {str(e)}")
    
    def show_confirmation_dialog(self, context, message, on_confirm):
        """Mostra dialog de confirmação"""
        try:
            from org.telegram.ui.ActionBar import AlertDialog
            
            builder = AlertDialog.Builder(context)
            builder.setTitle(tr('backup_restore_title'))
            builder.setMessage(message)
            builder.setPositiveButton(f"{tr('backup_confirm_button')}", lambda dialog, which: on_confirm())
            builder.setNegativeButton(f"{tr('backup_cancel')}", None)
            
            dialog = builder.create()
            dialog.show()
            
        except Exception as e:
            log(f"[Nowfy] Error creating confirmation dialog: {e}")
            # Fallback - aplicar diretamente
            on_confirm()
    
    def show_universal_link_dialog(self):
        """Mostra dialog explicativo sobre Universal Link"""
        try:
            from org.telegram.ui.ActionBar import AlertDialog
            from org.telegram.messenger import AndroidUtilities
            
            # Obter contexto atual
            ctx = AndroidUtilities.findActivity(ApplicationLoader.applicationContext)
            if not ctx:
                return
            
            builder = AlertDialog.Builder(ctx)
            builder.setTitle(tr('universal_link_dialog_title'))
            builder.setMessage(tr('universal_link_dialog_message'))
            builder.setPositiveButton("OK", None)
            
            dialog = builder.create()
            dialog.show()
            
        except Exception as e:
            log(f"[Nowfy] Error creating universal link dialog: {e}")
    
    
    def apply_backup_settings(self, backup_data):
        """Aplica as configurações do backup"""
        try:
            log(f"[Nowfy] apply_backup_settings called")
            settings = backup_data.get('settings', {})
            log(f"[Nowfy] Found {len(settings)} settings to apply")
            applied_count = 0
            failed_count = 0
            failed_settings = []
            
            # Aplicar configurações do backup importado
            log(f"[Nowfy] Starting to apply {len(settings)} settings from backup")
            
            for key, value in settings.items():
                try:
                    # Validar se o valor não é None ou vazio
                    if value is not None and value != "":
                        log(f"[Nowfy] Applying setting: {key} = {value} (type: {type(value)})")
                        self.plugin.set_setting(key, value)
                        applied_count += 1
                        log(f"[Nowfy] Successfully applied setting: {key}")
                    else:
                        log(f"[Nowfy] Skipping empty/null setting: {key}")
                except Exception as e:
                    failed_count += 1
                    failed_settings.append(key)
                    log(f"[Nowfy] Error applying setting {key}: {e}")
            
            timestamp = backup_data.get('timestamp', tr('unknown'))
            
            # Mostrar resultado detalhado
            if failed_count > 0:
                log(f"[Nowfy] Backup restored with issues: {applied_count} applied, {failed_count} failed")
                log(f"[Nowfy] Failed settings: {failed_settings}")
                BulletinHelper.show_info(f"{tr('backup_restore_success')} ({applied_count}/{len(settings)}) {tr('backup_restart_required')}")
            else:
                log(f"[Nowfy] Backup restored successfully: {applied_count} settings applied")
                BulletinHelper.show_info(f"{tr('backup_restore_success')} ({applied_count} {tr('backup_settings_count').lower()}) {tr('backup_restart_required')}")
            
        except Exception as e:
            log(f"[Nowfy] Error applying backup settings: {e}")
            import traceback
            log(f"[Nowfy] Traceback: {traceback.format_exc()}")
            BulletinHelper.show_info(f"{tr('backup_apply_error')}: {str(e)}")
    
    def list_backups(self):
        """Lista todos os backups disponíveis"""
        try:
            import os
            
            if not os.path.exists(self.backup_dir):
                self.show_backup_list_dialog([], 0)
                return
            
            backup_files = []
            total_size = 0
            
            for file in os.listdir(self.backup_dir):
                if file.endswith('.json') and file.startswith('nowfy_backup_'):
                    filepath = os.path.join(self.backup_dir, file)
                    try:
                        size = os.path.getsize(filepath)
                        total_size += size
                        
                        # Extrair timestamp
                        timestamp_part = file.replace('nowfy_backup_', '').replace('.json', '')
                        if len(timestamp_part) >= 13:
                            date_part = timestamp_part[:8]
                            time_part = timestamp_part[9:15] if len(timestamp_part) > 8 else timestamp_part[8:14]
                            formatted_date = f"{date_part[:4]}/{date_part[4:6]}/{date_part[6:8]}"
                            formatted_time = f"{time_part[:2]}:{time_part[2:4]}:{time_part[4:6]}"
                            display_info = f"{formatted_date} {formatted_time} ({size} bytes)"
                        else:
                            display_info = f"{file} ({size} bytes)"
                        
                        backup_files.append({
                            'filename': file,
                            'display': display_info,
                            'size': size
                        })
                    except Exception as e:
                        backup_files.append({
                            'filename': file,
                            'display': f"{file} ({tr('backup_read_error')})",
                            'size': 0
                        })
            
            if not backup_files:
                self.show_backup_list_dialog([], 0)
                return
            
            # Ordenar por data (mais recente primeiro)
            backup_files.sort(key=lambda x: x['display'], reverse=True)
            
            total_size_mb = total_size / (1024 * 1024)
            self.show_backup_list_dialog(backup_files, total_size_mb)
            
        except Exception as e:
            log(f"[Nowfy] Error listing backups: {e}")
            BulletinHelper.show_info(f"{tr('backup_list_error')}: {str(e)}")
    
    def show_backup_list_dialog(self, backup_files, total_size_mb):
        """Exibe dialog com lista de backups"""
        try:
            from org.telegram.ui.ActionBar import AlertDialog
            
            def show_dialog():
                try:
                    if not backup_files:
                        message = f"{tr('backup_no_backups_found')}\n\n{tr('backup_directory')}: {self.backup_dir}\n\n{tr('backup_use_export')}"
                        fragment = get_last_fragment()
                        if fragment:
                            ctx = fragment.getParentActivity() if fragment.getParentActivity() else ApplicationLoader.applicationContext
                            AlertDialog.Builder(ctx) \
                                .setTitle(tr('backup_list_title')) \
                                .setMessage(message) \
                                .setPositiveButton("OK", None) \
                                .show()
                        return
                    
                    # Formatar lista de backups
                    backup_list = []
                    for i, backup in enumerate(backup_files[:15]):  # Mostrar até 15 backups
                        backup_list.append(f"{i+1}. {backup['display']}")
                    
                    if len(backup_files) > 15:
                         more_count = len(backup_files) - 15
                         backup_list.append(f"\n... {tr('backup_and_more').replace('{}', str(more_count))}")
                    
                    message = "\n".join(backup_list)
                    message += f"\n\n{tr('backup_total_size')}: {total_size_mb:.2f} MB"
                    message += f"\n{tr('backup_directory')}: {self.backup_dir}"
                    message += f"\n\n{tr('backup_use_import')}"
                    
                    fragment = get_last_fragment()
                    if fragment:
                        ctx = fragment.getParentActivity() if fragment.getParentActivity() else ApplicationLoader.applicationContext
                        AlertDialog.Builder(ctx) \
                            .setTitle(f"{tr('backup_list_title')} ({len(backup_files)})") \
                            .setMessage(message) \
                            .setPositiveButton("OK", None) \
                            .show()
                except Exception as e:
                    log(f"[Nowfy] Error in show_dialog: {e}")
            
            # Executar na UI thread
            run_on_ui_thread(show_dialog)
                
        except Exception as e:
            log(f"[Nowfy] Error showing backup list dialog: {e}")
            BulletinHelper.show_info(f"{tr('backup_list_error')}: {str(e)}")
    
    def export_data(self):
        """Export plugin data for backup system compatibility"""
        try:
            # Coletar todas as configurações do plugin
            data = {
                "spotify": {
                    "client_id": self.get_setting("client_id", ""),
                    "client_secret": self.get_setting("client_secret", ""),
                    "access_token": self.get_setting("access_token", ""),
                    "refresh_token": self.get_setting("refresh_token", ""),
                    "username": self.get_setting("spotify_username", "")
                },
                "lastfm": {
                    "username": self.get_setting("lastfm_username", ""),
                    "api_key": self.get_setting("lastfm_api_key", "")
                },
                "statsfm": {
                    "username": self.get_setting("statsfm_username", "")
                },
                "ui_preferences": {
                    "theme_id": self.get_setting("theme_id", 1),
                    "show_progress_bar": self.get_setting("show_progress_bar", True),
                    "show_bio_notification": self.get_setting("show_bio_notification", False),
                    "custom_command": self.get_setting("custom_command", ".now"),
                    "bio_text": self.get_setting("bio_text", "🎵 {track} - {artist}"),
                    "bio_default": self.get_setting("bio_default", "")
                },
                "advanced": {
                    "auto_bio_update": self.get_setting("auto_bio_update", True),
                    "show_lastfm_profile": self.get_setting("show_lastfm_profile", True),
                    "use_custom_covers": self.get_setting("use_custom_covers", False),
                    "cache_enabled": self.get_setting("cache_enabled", True),
                    "cache_ttl": self.get_setting("cache_ttl", 300),
                    "cache_max_size": self.get_setting("cache_max_size", 10)
                },
                "metadata": {
                    "export_version": "1.0",
                    "plugin_version": __version__,
                    "export_timestamp": str(int(time.time() * 1000))
                }
            }
            log("[Nowfy] Plugin data exported successfully")
            return data
        except Exception as e:
            log(f"[Nowfy] Error exporting plugin data: {e}")
            return {}
    
    def import_data(self, data):
        """Import plugin data from backup system"""
        try:
            if not isinstance(data, dict):
                log("[Nowfy] Invalid import data format")
                return False
            
            # Importar configurações do Spotify
            if "spotify" in data:
                spotify_data = data["spotify"]
                if spotify_data.get("client_id"):
                    self.set_setting("client_id", spotify_data["client_id"])
                if spotify_data.get("client_secret"):
                    self.set_setting("client_secret", spotify_data["client_secret"])
                if spotify_data.get("access_token"):
                    self.set_setting("access_token", spotify_data["access_token"])
                if spotify_data.get("refresh_token"):
                    self.set_setting("refresh_token", spotify_data["refresh_token"])
                if spotify_data.get("username"):
                    self.set_setting("spotify_username", spotify_data["username"])
            
            # Importar configurações do Last.fm
            if "lastfm" in data:
                lastfm_data = data["lastfm"]
                if lastfm_data.get("username"):
                    self.set_setting("lastfm_username", lastfm_data["username"])
                if lastfm_data.get("api_key"):
                    self.set_setting("lastfm_api_key", lastfm_data["api_key"])
            
            # Importar configurações do Stats.fm
            if "statsfm" in data:
                statsfm_data = data["statsfm"]
                if statsfm_data.get("username"):
                    self.set_setting("statsfm_username", statsfm_data["username"])
            
            # Importar preferências de UI
            if "ui_preferences" in data:
                ui_data = data["ui_preferences"]
                if "theme_id" in ui_data:
                    self.set_setting("theme_id", ui_data["theme_id"])
                if "show_progress_bar" in ui_data:
                    self.set_setting("show_progress_bar", ui_data["show_progress_bar"])
                if "show_bio_notification" in ui_data:
                    self.set_setting("show_bio_notification", ui_data["show_bio_notification"])
                if ui_data.get("custom_command"):
                    self.set_setting("custom_command", ui_data["custom_command"])
                if ui_data.get("bio_text"):
                    self.set_setting("bio_text", ui_data["bio_text"])
                if ui_data.get("bio_default"):
                    self.set_setting("bio_default", ui_data["bio_default"])
            
            # Importar configurações avançadas
            if "advanced" in data:
                advanced_data = data["advanced"]
                if "auto_bio_update" in advanced_data:
                    self.set_setting("auto_bio_update", advanced_data["auto_bio_update"])
                if "show_lastfm_profile" in advanced_data:
                    self.set_setting("show_lastfm_profile", advanced_data["show_lastfm_profile"])
                if "use_custom_covers" in advanced_data:
                    self.set_setting("use_custom_covers", advanced_data["use_custom_covers"])
                if "cache_enabled" in advanced_data:
                    self.set_setting("cache_enabled", advanced_data["cache_enabled"])
                if "cache_ttl" in advanced_data:
                    self.set_setting("cache_ttl", advanced_data["cache_ttl"])
                if "cache_max_size" in advanced_data:
                    self.set_setting("cache_max_size", advanced_data["cache_max_size"])
            
            log("[Nowfy] Plugin data imported successfully")
            
            # Reinicializar cache e configurações se necessário
            try:
                self._cache_enabled = self.get_setting("cache_enabled", True)
                self._cache_ttl = self.get_setting("cache_ttl", 300)
                self._cache_max_size = self.get_setting("cache_max_size", 10)
                if hasattr(self, '_image_cache'):
                    self._image_cache.clear()
                if hasattr(self, '_cache_timestamps'):
                    self._cache_timestamps.clear()
            except Exception as cache_error:
                log(f"[Nowfy] Warning: Error reinitializing cache after import: {cache_error}")
            
            return True
            
        except Exception as e:
            log(f"[Nowfy] Error importing plugin data: {e}")
            return False
